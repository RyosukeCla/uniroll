// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`build 1`] = `
Object {
  "code": "/*
 * [Pika CDN - Package Error] \\"process\\" does not exist.
 *
 * A package that you requested from our CDN depends on a Node.js built-in module.
 * Node.js built-in modules (like \\"fs\\", \\"http\\", etc.) are Node.js-specific, and do
 * not exist in other environments like your web browser. Pika CDN polyfills these
 * modules whenever possible, but this one could not be polyfilled.
 * 
 * How to fix:
 *   - Let the package author know that you'd like to run their package in the browser.
 *   - Use https://pika.dev/ to find a more web-friendly alternative to the package that required this one.
 */
throw new Error('[Pika CDN - Package Error] The Node.js builtin module \\"process\\" does not exist outside of Node.js.');
var process$1 = null;

var matchOperatorsRe = /[|\\\\\\\\{}()[\\\\]^$+*?.]/g;

var escapeStringRegexp = function escapeStringRegexp(str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }

  return str.replace(matchOperatorsRe, '\\\\\\\\$&');
};

var colorName = {
  \\"aliceblue\\": [240, 248, 255],
  \\"antiquewhite\\": [250, 235, 215],
  \\"aqua\\": [0, 255, 255],
  \\"aquamarine\\": [127, 255, 212],
  \\"azure\\": [240, 255, 255],
  \\"beige\\": [245, 245, 220],
  \\"bisque\\": [255, 228, 196],
  \\"black\\": [0, 0, 0],
  \\"blanchedalmond\\": [255, 235, 205],
  \\"blue\\": [0, 0, 255],
  \\"blueviolet\\": [138, 43, 226],
  \\"brown\\": [165, 42, 42],
  \\"burlywood\\": [222, 184, 135],
  \\"cadetblue\\": [95, 158, 160],
  \\"chartreuse\\": [127, 255, 0],
  \\"chocolate\\": [210, 105, 30],
  \\"coral\\": [255, 127, 80],
  \\"cornflowerblue\\": [100, 149, 237],
  \\"cornsilk\\": [255, 248, 220],
  \\"crimson\\": [220, 20, 60],
  \\"cyan\\": [0, 255, 255],
  \\"darkblue\\": [0, 0, 139],
  \\"darkcyan\\": [0, 139, 139],
  \\"darkgoldenrod\\": [184, 134, 11],
  \\"darkgray\\": [169, 169, 169],
  \\"darkgreen\\": [0, 100, 0],
  \\"darkgrey\\": [169, 169, 169],
  \\"darkkhaki\\": [189, 183, 107],
  \\"darkmagenta\\": [139, 0, 139],
  \\"darkolivegreen\\": [85, 107, 47],
  \\"darkorange\\": [255, 140, 0],
  \\"darkorchid\\": [153, 50, 204],
  \\"darkred\\": [139, 0, 0],
  \\"darksalmon\\": [233, 150, 122],
  \\"darkseagreen\\": [143, 188, 143],
  \\"darkslateblue\\": [72, 61, 139],
  \\"darkslategray\\": [47, 79, 79],
  \\"darkslategrey\\": [47, 79, 79],
  \\"darkturquoise\\": [0, 206, 209],
  \\"darkviolet\\": [148, 0, 211],
  \\"deeppink\\": [255, 20, 147],
  \\"deepskyblue\\": [0, 191, 255],
  \\"dimgray\\": [105, 105, 105],
  \\"dimgrey\\": [105, 105, 105],
  \\"dodgerblue\\": [30, 144, 255],
  \\"firebrick\\": [178, 34, 34],
  \\"floralwhite\\": [255, 250, 240],
  \\"forestgreen\\": [34, 139, 34],
  \\"fuchsia\\": [255, 0, 255],
  \\"gainsboro\\": [220, 220, 220],
  \\"ghostwhite\\": [248, 248, 255],
  \\"gold\\": [255, 215, 0],
  \\"goldenrod\\": [218, 165, 32],
  \\"gray\\": [128, 128, 128],
  \\"green\\": [0, 128, 0],
  \\"greenyellow\\": [173, 255, 47],
  \\"grey\\": [128, 128, 128],
  \\"honeydew\\": [240, 255, 240],
  \\"hotpink\\": [255, 105, 180],
  \\"indianred\\": [205, 92, 92],
  \\"indigo\\": [75, 0, 130],
  \\"ivory\\": [255, 255, 240],
  \\"khaki\\": [240, 230, 140],
  \\"lavender\\": [230, 230, 250],
  \\"lavenderblush\\": [255, 240, 245],
  \\"lawngreen\\": [124, 252, 0],
  \\"lemonchiffon\\": [255, 250, 205],
  \\"lightblue\\": [173, 216, 230],
  \\"lightcoral\\": [240, 128, 128],
  \\"lightcyan\\": [224, 255, 255],
  \\"lightgoldenrodyellow\\": [250, 250, 210],
  \\"lightgray\\": [211, 211, 211],
  \\"lightgreen\\": [144, 238, 144],
  \\"lightgrey\\": [211, 211, 211],
  \\"lightpink\\": [255, 182, 193],
  \\"lightsalmon\\": [255, 160, 122],
  \\"lightseagreen\\": [32, 178, 170],
  \\"lightskyblue\\": [135, 206, 250],
  \\"lightslategray\\": [119, 136, 153],
  \\"lightslategrey\\": [119, 136, 153],
  \\"lightsteelblue\\": [176, 196, 222],
  \\"lightyellow\\": [255, 255, 224],
  \\"lime\\": [0, 255, 0],
  \\"limegreen\\": [50, 205, 50],
  \\"linen\\": [250, 240, 230],
  \\"magenta\\": [255, 0, 255],
  \\"maroon\\": [128, 0, 0],
  \\"mediumaquamarine\\": [102, 205, 170],
  \\"mediumblue\\": [0, 0, 205],
  \\"mediumorchid\\": [186, 85, 211],
  \\"mediumpurple\\": [147, 112, 219],
  \\"mediumseagreen\\": [60, 179, 113],
  \\"mediumslateblue\\": [123, 104, 238],
  \\"mediumspringgreen\\": [0, 250, 154],
  \\"mediumturquoise\\": [72, 209, 204],
  \\"mediumvioletred\\": [199, 21, 133],
  \\"midnightblue\\": [25, 25, 112],
  \\"mintcream\\": [245, 255, 250],
  \\"mistyrose\\": [255, 228, 225],
  \\"moccasin\\": [255, 228, 181],
  \\"navajowhite\\": [255, 222, 173],
  \\"navy\\": [0, 0, 128],
  \\"oldlace\\": [253, 245, 230],
  \\"olive\\": [128, 128, 0],
  \\"olivedrab\\": [107, 142, 35],
  \\"orange\\": [255, 165, 0],
  \\"orangered\\": [255, 69, 0],
  \\"orchid\\": [218, 112, 214],
  \\"palegoldenrod\\": [238, 232, 170],
  \\"palegreen\\": [152, 251, 152],
  \\"paleturquoise\\": [175, 238, 238],
  \\"palevioletred\\": [219, 112, 147],
  \\"papayawhip\\": [255, 239, 213],
  \\"peachpuff\\": [255, 218, 185],
  \\"peru\\": [205, 133, 63],
  \\"pink\\": [255, 192, 203],
  \\"plum\\": [221, 160, 221],
  \\"powderblue\\": [176, 224, 230],
  \\"purple\\": [128, 0, 128],
  \\"rebeccapurple\\": [102, 51, 153],
  \\"red\\": [255, 0, 0],
  \\"rosybrown\\": [188, 143, 143],
  \\"royalblue\\": [65, 105, 225],
  \\"saddlebrown\\": [139, 69, 19],
  \\"salmon\\": [250, 128, 114],
  \\"sandybrown\\": [244, 164, 96],
  \\"seagreen\\": [46, 139, 87],
  \\"seashell\\": [255, 245, 238],
  \\"sienna\\": [160, 82, 45],
  \\"silver\\": [192, 192, 192],
  \\"skyblue\\": [135, 206, 235],
  \\"slateblue\\": [106, 90, 205],
  \\"slategray\\": [112, 128, 144],
  \\"slategrey\\": [112, 128, 144],
  \\"snow\\": [255, 250, 250],
  \\"springgreen\\": [0, 255, 127],
  \\"steelblue\\": [70, 130, 180],
  \\"tan\\": [210, 180, 140],
  \\"teal\\": [0, 128, 128],
  \\"thistle\\": [216, 191, 216],
  \\"tomato\\": [255, 99, 71],
  \\"turquoise\\": [64, 224, 208],
  \\"violet\\": [238, 130, 238],
  \\"wheat\\": [245, 222, 179],
  \\"white\\": [255, 255, 255],
  \\"whitesmoke\\": [245, 245, 245],
  \\"yellow\\": [255, 255, 0],
  \\"yellowgreen\\": [154, 205, 50]
};

function createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var conversions = createCommonjsModule(function (module) {
  /* MIT license */
  // NOTE: conversions should only return primitive values (i.e. arrays, or
  //       values that give correct \`typeof\` results).
  //       do not use box values types (i.e. Number(), String(), etc.)
  var reverseKeywords = {};

  for (var key in colorName) {
    if (colorName.hasOwnProperty(key)) {
      reverseKeywords[colorName[key]] = key;
    }
  }

  var convert = module.exports = {
    rgb: {
      channels: 3,
      labels: 'rgb'
    },
    hsl: {
      channels: 3,
      labels: 'hsl'
    },
    hsv: {
      channels: 3,
      labels: 'hsv'
    },
    hwb: {
      channels: 3,
      labels: 'hwb'
    },
    cmyk: {
      channels: 4,
      labels: 'cmyk'
    },
    xyz: {
      channels: 3,
      labels: 'xyz'
    },
    lab: {
      channels: 3,
      labels: 'lab'
    },
    lch: {
      channels: 3,
      labels: 'lch'
    },
    hex: {
      channels: 1,
      labels: ['hex']
    },
    keyword: {
      channels: 1,
      labels: ['keyword']
    },
    ansi16: {
      channels: 1,
      labels: ['ansi16']
    },
    ansi256: {
      channels: 1,
      labels: ['ansi256']
    },
    hcg: {
      channels: 3,
      labels: ['h', 'c', 'g']
    },
    apple: {
      channels: 3,
      labels: ['r16', 'g16', 'b16']
    },
    gray: {
      channels: 1,
      labels: ['gray']
    }
  }; // hide .channels and .labels properties

  for (var model in convert) {
    if (convert.hasOwnProperty(model)) {
      if (!('channels' in convert[model])) {
        throw new Error('missing channels property: ' + model);
      }

      if (!('labels' in convert[model])) {
        throw new Error('missing channel labels property: ' + model);
      }

      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error('channel and label counts mismatch: ' + model);
      }

      var channels = convert[model].channels;
      var labels = convert[model].labels;
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], 'channels', {
        value: channels
      });
      Object.defineProperty(convert[model], 'labels', {
        value: labels
      });
    }
  }

  convert.rgb.hsl = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h;
    var s;
    var l;

    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }

    h = Math.min(h * 60, 360);

    if (h < 0) {
      h += 360;
    }

    l = (min + max) / 2;

    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }

    return [h, s * 100, l * 100];
  };

  convert.rgb.hsv = function (rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h;
    var s;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff = v - Math.min(r, g, b);

    var diffc = function diffc(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };

    if (diff === 0) {
      h = s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);

      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }

      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }

    return [h * 360, s * 100, v * 100];
  };

  convert.rgb.hwb = function (rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h = convert.rgb.hsl(rgb)[0];
    var w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };

  convert.rgb.cmyk = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m;
    var y;
    var k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  /**
   * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
   * */


  function comparativeDistance(x, y) {
    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
  }

  convert.rgb.keyword = function (rgb) {
    var reversed = reverseKeywords[rgb];

    if (reversed) {
      return reversed;
    }

    var currentClosestDistance = Infinity;
    var currentClosestKeyword;

    for (var keyword in colorName) {
      if (colorName.hasOwnProperty(keyword)) {
        var value = colorName[keyword]; // Compute comparative distance

        var distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest

        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }

    return currentClosestKeyword;
  };

  convert.keyword.rgb = function (keyword) {
    return colorName[keyword];
  };

  convert.rgb.xyz = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255; // assume sRGB

    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };

  convert.rgb.lab = function (rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };

  convert.hsl.rgb = function (hsl) {
    var h = hsl[0] / 360;
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;

    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }

    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }

    t1 = 2 * l - t2;
    rgb = [0, 0, 0];

    for (var i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);

      if (t3 < 0) {
        t3++;
      }

      if (t3 > 1) {
        t3--;
      }

      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }

      rgb[i] = val * 255;
    }

    return rgb;
  };

  convert.hsl.hsv = function (hsl) {
    var h = hsl[0];
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };

  convert.hsv.rgb = function (hsv) {
    var h = hsv[0] / 60;
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h) % 6;
    var f = h - Math.floor(h);
    var p = 255 * v * (1 - s);
    var q = 255 * v * (1 - s * f);
    var t = 255 * v * (1 - s * (1 - f));
    v *= 255;

    switch (hi) {
      case 0:
        return [v, t, p];

      case 1:
        return [q, v, p];

      case 2:
        return [p, v, t];

      case 3:
        return [p, q, v];

      case 4:
        return [t, p, v];

      case 5:
        return [v, p, q];
    }
  };

  convert.hsv.hsl = function (hsv) {
    var h = hsv[0];
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s) * v;
    lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  }; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


  convert.hwb.rgb = function (hwb) {
    var h = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v;
    var f;
    var n; // wh + bl cant be > 1

    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }

    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;

    if ((i & 0x01) !== 0) {
      f = 1 - f;
    }

    n = wh + f * (v - wh); // linear interpolation

    var r;
    var g;
    var b;

    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;

      case 1:
        r = n;
        g = v;
        b = wh;
        break;

      case 2:
        r = wh;
        g = v;
        b = n;
        break;

      case 3:
        r = wh;
        g = n;
        b = v;
        break;

      case 4:
        r = n;
        g = wh;
        b = v;
        break;

      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }

    return [r * 255, g * 255, b * 255];
  };

  convert.cmyk.rgb = function (cmyk) {
    var c = cmyk[0] / 100;
    var m = cmyk[1] / 100;
    var y = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };

  convert.xyz.rgb = function (xyz) {
    var x = xyz[0] / 100;
    var y = xyz[1] / 100;
    var z = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };

  convert.xyz.lab = function (xyz) {
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };

  convert.lab.xyz = function (lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y;
    var z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    var y2 = Math.pow(y, 3);
    var x2 = Math.pow(x, 3);
    var z2 = Math.pow(z, 3);
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };

  convert.lab.lch = function (lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h;
    var c;
    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;

    if (h < 0) {
      h += 360;
    }

    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };

  convert.lch.lab = function (lch) {
    var l = lch[0];
    var c = lch[1];
    var h = lch[2];
    var a;
    var b;
    var hr;
    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };

  convert.rgb.ansi16 = function (args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

    value = Math.round(value / 50);

    if (value === 0) {
      return 30;
    }

    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

    if (value === 2) {
      ansi += 60;
    }

    return ansi;
  };

  convert.hsv.ansi16 = function (args) {
    // optimization here; we already know the value and don't need to get
    // it converted for us.
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };

  convert.rgb.ansi256 = function (args) {
    var r = args[0];
    var g = args[1];
    var b = args[2]; // we use the extended greyscale palette here, with the exception of
    // black and white. normal palette only has 4 greyscale shades.

    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }

      if (r > 248) {
        return 231;
      }

      return Math.round((r - 8) / 247 * 24) + 232;
    }

    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };

  convert.ansi16.rgb = function (args) {
    var color = args % 10; // handle greyscale

    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }

      color = color / 10.5 * 255;
      return [color, color, color];
    }

    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };

  convert.ansi256.rgb = function (args) {
    // handle greyscale
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }

    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };

  convert.rgb.hex = function (args) {
    var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
    var string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  convert.hex.rgb = function (args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

    if (!match) {
      return [0, 0, 0];
    }

    var colorString = match[0];

    if (match[0].length === 3) {
      colorString = colorString.split('').map(function (char) {
        return char + char;
      }).join('');
    }

    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 0xFF;
    var g = integer >> 8 & 0xFF;
    var b = integer & 0xFF;
    return [r, g, b];
  };

  convert.rgb.hcg = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max = Math.max(Math.max(r, g), b);
    var min = Math.min(Math.min(r, g), b);
    var chroma = max - min;
    var grayscale;
    var hue;

    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }

    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }

    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };

  convert.hsl.hcg = function (hsl) {
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;

    if (l < 0.5) {
      c = 2.0 * s * l;
    } else {
      c = 2.0 * s * (1.0 - l);
    }

    if (c < 1.0) {
      f = (l - 0.5 * c) / (1.0 - c);
    }

    return [hsl[0], c * 100, f * 100];
  };

  convert.hsv.hcg = function (hsv) {
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s * v;
    var f = 0;

    if (c < 1.0) {
      f = (v - c) / (1 - c);
    }

    return [hsv[0], c * 100, f * 100];
  };

  convert.hcg.rgb = function (hcg) {
    var h = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;

    if (c === 0.0) {
      return [g * 255, g * 255, g * 255];
    }

    var pure = [0, 0, 0];
    var hi = h % 1 * 6;
    var v = hi % 1;
    var w = 1 - v;
    var mg = 0;

    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;

      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;

      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;

      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;

      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;

      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }

    mg = (1.0 - c) * g;
    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
  };

  convert.hcg.hsv = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1.0 - c);
    var f = 0;

    if (v > 0.0) {
      f = c / v;
    }

    return [hcg[0], f * 100, v * 100];
  };

  convert.hcg.hsl = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1.0 - c) + 0.5 * c;
    var s = 0;

    if (l > 0.0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1.0) {
      s = c / (2 * (1 - l));
    }

    return [hcg[0], s * 100, l * 100];
  };

  convert.hcg.hwb = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1.0 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };

  convert.hwb.hcg = function (hwb) {
    var w = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w;
    var g = 0;

    if (c < 1) {
      g = (v - c) / (1 - c);
    }

    return [hwb[0], c * 100, g * 100];
  };

  convert.apple.rgb = function (apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };

  convert.rgb.apple = function (rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };

  convert.gray.rgb = function (args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };

  convert.gray.hsl = convert.gray.hsv = function (args) {
    return [0, 0, args[0]];
  };

  convert.gray.hwb = function (gray) {
    return [0, 100, gray[0]];
  };

  convert.gray.cmyk = function (gray) {
    return [0, 0, 0, gray[0]];
  };

  convert.gray.lab = function (gray) {
    return [gray[0], 0, 0];
  };

  convert.gray.hex = function (gray) {
    var val = Math.round(gray[0] / 100 * 255) & 0xFF;
    var integer = (val << 16) + (val << 8) + val;
    var string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  convert.rgb.gray = function (rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});
var conversions_1 = conversions.rgb;
var conversions_2 = conversions.hsl;
var conversions_3 = conversions.hsv;
var conversions_4 = conversions.hwb;
var conversions_5 = conversions.cmyk;
var conversions_6 = conversions.xyz;
var conversions_7 = conversions.lab;
var conversions_8 = conversions.lch;
var conversions_9 = conversions.hex;
var conversions_10 = conversions.keyword;
var conversions_11 = conversions.ansi16;
var conversions_12 = conversions.ansi256;
var conversions_13 = conversions.hcg;
var conversions_14 = conversions.apple;
var conversions_15 = conversions.gray;
/*
	this function routes a model to all other models.

	all functions that are routed have a property \`.conversion\` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
  var graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3

  var models = Object.keys(conversions);

  for (var len = models.length, i = 0; i < len; i++) {
    graph[models[i]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  }

  return graph;
} // https://en.wikipedia.org/wiki/Breadth-first_search


function deriveBFS(fromModel) {
  var graph = buildGraph();
  var queue = [fromModel]; // unshift -> queue -> pop

  graph[fromModel].distance = 0;

  while (queue.length) {
    var current = queue.pop();
    var adjacents = Object.keys(conversions[current]);

    for (var len = adjacents.length, i = 0; i < len; i++) {
      var adjacent = adjacents[i];
      var node = graph[adjacent];

      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }

  return graph;
}

function link(from, to) {
  return function (args) {
    return to(from(args));
  };
}

function wrapConversion(toModel, graph) {
  var path = [graph[toModel].parent, toModel];
  var fn = conversions[graph[toModel].parent][toModel];
  var cur = graph[toModel].parent;

  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = link(conversions[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }

  fn.conversion = path;
  return fn;
}

var route = function route(fromModel) {
  var graph = deriveBFS(fromModel);
  var conversion = {};
  var models = Object.keys(graph);

  for (var len = models.length, i = 0; i < len; i++) {
    var toModel = models[i];
    var node = graph[toModel];

    if (node.parent === null) {
      // no possible conversion, or this node is the source model.
      continue;
    }

    conversion[toModel] = wrapConversion(toModel, graph);
  }

  return conversion;
};

var convert = {};
var models = Object.keys(conversions);

function wrapRaw(fn) {
  var wrappedFn = function wrappedFn(args) {
    if (args === undefined || args === null) {
      return args;
    }

    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }

    return fn(args);
  }; // preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

function wrapRounded(fn) {
  var wrappedFn = function wrappedFn(args) {
    if (args === undefined || args === null) {
      return args;
    }

    if (arguments.length > 1) {
      args = Array.prototype.slice.call(arguments);
    }

    var result = fn(args); // we're assuming the result is an array here.
    // see notice in conversions.js; don't use box types
    // in conversion functions.

    if (typeof result === 'object') {
      for (var len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i]);
      }
    }

    return result;
  }; // preserve .conversion property if there is one


  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }

  return wrappedFn;
}

models.forEach(function (fromModel) {
  convert[fromModel] = {};
  Object.defineProperty(convert[fromModel], 'channels', {
    value: conversions[fromModel].channels
  });
  Object.defineProperty(convert[fromModel], 'labels', {
    value: conversions[fromModel].labels
  });
  var routes = route(fromModel);
  var routeModels = Object.keys(routes);
  routeModels.forEach(function (toModel) {
    var fn = routes[toModel];
    convert[fromModel][toModel] = wrapRounded(fn);
    convert[fromModel][toModel].raw = wrapRaw(fn);
  });
});
var colorConvert = convert;

function createCommonjsModule$1(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var ansiStyles = createCommonjsModule$1(function (module) {
  const wrapAnsi16 = (fn, offset) => function () {
    const code = fn.apply(colorConvert, arguments);
    return \`\\\\u001B[\${code + offset}m\`;
  };

  const wrapAnsi256 = (fn, offset) => function () {
    const code = fn.apply(colorConvert, arguments);
    return \`\\\\u001B[\${38 + offset};5;\${code}m\`;
  };

  const wrapAnsi16m = (fn, offset) => function () {
    const rgb = fn.apply(colorConvert, arguments);
    return \`\\\\u001B[\${38 + offset};2;\${rgb[0]};\${rgb[1]};\${rgb[2]}m\`;
  };

  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        // Bright color
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    }; // Fix humans

    styles.color.grey = styles.color.gray;

    for (const groupName of Object.keys(styles)) {
      const group = styles[groupName];

      for (const styleName of Object.keys(group)) {
        const style = group[styleName];
        styles[styleName] = {
          open: \`\\\\u001B[\${style[0]}m\`,
          close: \`\\\\u001B[\${style[1]}m\`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }

      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
      Object.defineProperty(styles, 'codes', {
        value: codes,
        enumerable: false
      });
    }

    const ansi2ansi = n => n;

    const rgb2rgb = (r, g, b) => [r, g, b];

    styles.color.close = '\\\\u001B[39m';
    styles.bgColor.close = '\\\\u001B[49m';
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };

    for (let key of Object.keys(colorConvert)) {
      if (typeof colorConvert[key] !== 'object') {
        continue;
      }

      const suite = colorConvert[key];

      if (key === 'ansi16') {
        key = 'ansi';
      }

      if ('ansi16' in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }

      if ('ansi256' in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }

      if ('rgb' in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }

    return styles;
  } // Make the export immutable


  Object.defineProperty(module, 'exports', {
    enumerable: true,
    get: assembleStyles
  });
});

var browser = {
  stdout: false,
  stderr: false
};

function createCommonjsModule$2(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

const TEMPLATE_REGEX = /(?:\\\\\\\\(u[a-f\\\\d]{4}|x[a-f\\\\d]{2}|.))|(?:\\\\{(~)?(\\\\w+(?:\\\\([^)]*\\\\))?(?:\\\\.\\\\w+(?:\\\\([^)]*\\\\))?)*)(?:[ \\\\t]|(?=\\\\r?\\\\n)))|(\\\\})|((?:.|[\\\\r\\\\n\\\\f])+?)/gi;
const STYLE_REGEX = /(?:^|\\\\.)(\\\\w+)(?:\\\\(([^)]*)\\\\))?/g;
const STRING_REGEX = /^(['\\"])((?:\\\\\\\\.|(?!\\\\1)[^\\\\\\\\])*)\\\\1$/;
const ESCAPE_REGEX = /\\\\\\\\(u[a-f\\\\d]{4}|x[a-f\\\\d]{2}|.)|([^\\\\\\\\])/gi;
const ESCAPES = new Map([['n', '\\\\n'], ['r', '\\\\r'], ['t', '\\\\t'], ['b', '\\\\b'], ['f', '\\\\f'], ['v', '\\\\v'], ['0', '\\\\0'], ['\\\\\\\\', '\\\\\\\\'], ['e', '\\\\u001B'], ['a', '\\\\u0007']]);

function unescape(c) {
  if (c[0] === 'u' && c.length === 5 || c[0] === 'x' && c.length === 3) {
    return String.fromCharCode(parseInt(c.slice(1), 16));
  }

  return ESCAPES.get(c) || c;
}

function parseArguments(name, args) {
  const results = [];
  const chunks = args.trim().split(/\\\\s*,\\\\s*/g);
  let matches;

  for (const chunk of chunks) {
    if (!isNaN(chunk)) {
      results.push(Number(chunk));
    } else if (matches = chunk.match(STRING_REGEX)) {
      results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
    } else {
      throw new Error(\`Invalid Chalk template style argument: \${chunk} (in style '\${name}')\`);
    }
  }

  return results;
}

function parseStyle(style) {
  STYLE_REGEX.lastIndex = 0;
  const results = [];
  let matches;

  while ((matches = STYLE_REGEX.exec(style)) !== null) {
    const name = matches[1];

    if (matches[2]) {
      const args = parseArguments(name, matches[2]);
      results.push([name].concat(args));
    } else {
      results.push([name]);
    }
  }

  return results;
}

function buildStyle(chalk, styles) {
  const enabled = {};

  for (const layer of styles) {
    for (const style of layer.styles) {
      enabled[style[0]] = layer.inverse ? null : style.slice(1);
    }
  }

  let current = chalk;

  for (const styleName of Object.keys(enabled)) {
    if (Array.isArray(enabled[styleName])) {
      if (!(styleName in current)) {
        throw new Error(\`Unknown Chalk style: \${styleName}\`);
      }

      if (enabled[styleName].length > 0) {
        current = current[styleName].apply(current, enabled[styleName]);
      } else {
        current = current[styleName];
      }
    }
  }

  return current;
}

var templates = (chalk, tmp) => {
  const styles = [];
  const chunks = [];
  let chunk = []; // eslint-disable-next-line max-params

  tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
    if (escapeChar) {
      chunk.push(unescape(escapeChar));
    } else if (style) {
      const str = chunk.join('');
      chunk = [];
      chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
      styles.push({
        inverse,
        styles: parseStyle(style)
      });
    } else if (close) {
      if (styles.length === 0) {
        throw new Error('Found extraneous } in Chalk template literal');
      }

      chunks.push(buildStyle(chalk, styles)(chunk.join('')));
      chunk = [];
      styles.pop();
    } else {
      chunk.push(chr);
    }
  });
  chunks.push(chunk.join(''));

  if (styles.length > 0) {
    const errMsg = \`Chalk template literal is missing \${styles.length} closing bracket\${styles.length === 1 ? '' : 's'} (\\\\\`}\\\\\`)\`;
    throw new Error(errMsg);
  }

  return chunks.join('');
};

var chalk = createCommonjsModule$2(function (module) {
  const stdoutColor = browser.stdout;
  const isSimpleWindowsTerm = process.platform === 'win32' && !''.toLowerCase().startsWith('xterm'); // \`supportsColor.level\` → \`ansiStyles.color[name]\` mapping

  const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m']; // \`color-convert\` models to exclude from the Chalk API due to conflicts and such

  const skipModels = new Set(['gray']);
  const styles = Object.create(null);

  function applyOptions(obj, options) {
    options = options || {}; // Detect level if not set manually

    const scLevel =  0;
    obj.level = options.level === undefined ? scLevel : options.level;
    obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
  }

  function Chalk(options) {
    // We check for this.template here since calling \`chalk.constructor()\`
    // by itself will have a \`this\` of a previously constructed chalk object
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk = {};
      applyOptions(chalk, options);

      chalk.template = function () {
        const args = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk.template].concat(args));
      };

      Object.setPrototypeOf(chalk, Chalk.prototype);
      Object.setPrototypeOf(chalk.template, chalk);
      chalk.template.constructor = Chalk;
      return chalk.template;
    }

    applyOptions(this, options);
  } // Use bright blue on Windows as the normal blue color is illegible


  if (isSimpleWindowsTerm) {
    ansiStyles.blue.open = '\\\\u001B[94m';
  }

  for (const key of Object.keys(ansiStyles)) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    styles[key] = {
      get() {
        const codes = ansiStyles[key];
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
      }

    };
  }

  styles.visible = {
    get() {
      return build.call(this, this._styles || [], true, 'visible');
    }

  };
  ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');

  for (const model of Object.keys(ansiStyles.color.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }

    styles[model] = {
      get() {
        const level = this.level;
        return function () {
          const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles.color.close,
            closeRe: ansiStyles.color.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }

    };
  }

  ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');

  for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }

    const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const level = this.level;
        return function () {
          const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles.bgColor.close,
            closeRe: ansiStyles.bgColor.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }

    };
  }

  const proto = Object.defineProperties(() => {}, styles);

  function build(_styles, _empty, key) {
    const builder = function builder() {
      return applyStyle.apply(builder, arguments);
    };

    builder._styles = _styles;
    builder._empty = _empty;
    const self = this;
    Object.defineProperty(builder, 'level', {
      enumerable: true,

      get() {
        return self.level;
      },

      set(level) {
        self.level = level;
      }

    });
    Object.defineProperty(builder, 'enabled', {
      enumerable: true,

      get() {
        return self.enabled;
      },

      set(enabled) {
        self.enabled = enabled;
      }

    }); // See below for fix regarding invisible grey/dim combination on Windows

    builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey'; // \`__proto__\` is used because we must return a function, but there is
    // no way to create a function with a different prototype

    builder.__proto__ = proto; // eslint-disable-line no-proto

    return builder;
  }

  function applyStyle() {
    // Support varags, but simply cast to string in case there's only one arg
    const args = arguments;
    const argsLen = args.length;
    let str = String(arguments[0]);

    if (argsLen === 0) {
      return '';
    }

    if (argsLen > 1) {
      // Don't slice \`arguments\`, it prevents V8 optimizations
      for (let a = 1; a < argsLen; a++) {
        str += ' ' + args[a];
      }
    }

    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? '' : str;
    } // Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
    // see https://github.com/chalk/chalk/issues/58
    // If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.


    const originalDim = ansiStyles.dim.open;

    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles.dim.open = '';
    }

    for (const code of this._styles.slice().reverse()) {
      // Replace any instances already present with a re-opening code
      // otherwise only the part of the string until said closing code
      // will be colored, and the rest will simply be 'plain'.
      str = code.open + str.replace(code.closeRe, code.open) + code.close; // Close the styling before a linebreak and reopen
      // after next line to fix a bleed issue on macOS
      // https://github.com/chalk/chalk/pull/92

      str = str.replace(/\\\\r?\\\\n/g, \`\${code.close}$&\${code.open}\`);
    } // Reset the original \`dim\` if we changed it to work around the Windows dimmed gray issue


    ansiStyles.dim.open = originalDim;
    return str;
  }

  function chalkTag(chalk, strings) {
    if (!Array.isArray(strings)) {
      // If chalk() was called by itself or with a string,
      // return the string itself as a string.
      return [].slice.call(arguments, 1).join(' ');
    }

    const args = [].slice.call(arguments, 2);
    const parts = [strings.raw[0]];

    for (let i = 1; i < strings.length; i++) {
      parts.push(String(args[i - 1]).replace(/[{}\\\\\\\\]/g, '\\\\\\\\$&'));
      parts.push(String(strings.raw[i]));
    }

    return templates(chalk, parts.join(''));
  }

  Object.defineProperties(Chalk.prototype, styles);
  module.exports = Chalk(); // eslint-disable-line new-cap

  module.exports.supportsColor = stdoutColor;
  module.exports.default = module.exports; // For TypeScript
});
var chalk_1 = chalk.supportsColor;

var chalk$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': chalk,
  supportsColor: chalk_1
});

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: \`lodash modularize exports=\\"npm\\" -o ./\`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various \`Number\` constants. */

var MAX_SAFE_INTEGER = 9007199254740991;
/** \`Object#toString\` result references. */

var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/**
 * Used to match \`RegExp\`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\\\\\\\^$.*+?()[\\\\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\\\\[object .+?Constructor\\\\]$/;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\\\\d*)$/;
/** Used to compose unicode character classes. */

var rsAstralRange = '\\\\\\\\ud800-\\\\\\\\udfff',
    rsComboMarksRange = '\\\\\\\\u0300-\\\\\\\\u036f\\\\\\\\ufe20-\\\\\\\\ufe23',
    rsComboSymbolsRange = '\\\\\\\\u20d0-\\\\\\\\u20f0',
    rsVarRange = '\\\\\\\\ufe0e\\\\\\\\ufe0f';
/** Used to compose unicode capture groups. */

var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsFitz = '\\\\\\\\ud83c[\\\\\\\\udffb-\\\\\\\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\\\\\\\ud83c[\\\\\\\\udde6-\\\\\\\\uddff]){2}',
    rsSurrPair = '[\\\\\\\\ud800-\\\\\\\\udbff][\\\\\\\\udc00-\\\\\\\\udfff]',
    rsZWJ = '\\\\\\\\u200d';
/** Used to compose unicode regexes. */

var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
/** Detect free variable \`global\` from Node.js. */

var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
/** Detect free variable \`self\`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
/**
 * A specialized version of \`_.map\` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}
/**
 * Converts an ASCII \`string\` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */


function asciiToArray(string) {
  return string.split('');
}
/**
 * The base implementation of \`_.times\` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke \`iteratee\`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */


function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}
/**
 * The base implementation of \`_.values\` and \`_.valuesIn\` which creates an
 * array of \`object\` property values corresponding to the property names
 * of \`props\`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */


function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}
/**
 * Gets the value at \`key\` of \`object\`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */


function getValue(object, key) {
  return object == null ? undefined : object[key];
}
/**
 * Checks if \`string\` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns \`true\` if a symbol is found, else \`false\`.
 */


function hasUnicode(string) {
  return reHasUnicode.test(string);
}
/**
 * Checks if \`value\` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a host object, else \`false\`.
 */


function isHostObject(value) {
  // Many host objects are \`Object\` objects that can coerce to strings
  // despite having improperly defined \`toString\` methods.
  var result = false;

  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }

  return result;
}
/**
 * Converts \`iterator\` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */


function iteratorToArray(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }

  return result;
}
/**
 * Converts \`map\` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */


function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}
/**
 * Creates a unary function that invokes \`func\` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */


function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}
/**
 * Converts \`set\` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */


function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}
/**
 * Converts \`string\` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */


function stringToArray(string) {
  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
}
/**
 * Converts a Unicode \`string\` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */


function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
/** Used for built-in method references. */


var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */

var coreJsData = root['__core-js_shared__'];
/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/** Used to resolve the decompiled source of functions. */


var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [\`toStringTag\`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\\\\\\\()| for .+?(?=\\\\\\\\\\\\])/g, '$1.*?') + '$');
/** Built-in value references. */

var Symbol = root.Symbol,
    iteratorSymbol = Symbol ? Symbol.iterator : undefined,
    propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other \`lodash\` methods. */

var nativeKeys = overArg(Object.keys, Object);
/* Built-in method references that are verified to be native. */

var DataView$1 = getNative(root, 'DataView'),
    Map$1 = getNative(root, 'Map'),
    Promise$1 = getNative(root, 'Promise'),
    Set$1 = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap');
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView$1),
    mapCtorString = toSource(Map$1),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap);
/**
 * Creates an array of the enumerable property names of the array-like \`value\`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes \`arguments.callee\` enumerable in strict mode.
  // Safari 9 makes \`arguments.length\` enumerable in strict mode.
  var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}
/**
 * The base implementation of \`getTag\`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the \`toStringTag\`.
 */


function baseGetTag(value) {
  return objectToString.call(value);
}
/**
 * The base implementation of \`_.isNative\` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a native function,
 *  else \`false\`.
 */


function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
/**
 * The base implementation of \`_.keys\` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */


function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}
/**
 * Copies the values of \`source\` to \`array\`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns \`array\`.
 */


function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}
/**
 * Gets the native function at \`key\` of \`object\`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else \`undefined\`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}
/**
 * Gets the \`toStringTag\` of \`value\`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the \`toStringTag\`.
 */


var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.

if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag(new Map$1()) != mapTag || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function (value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;

        case mapCtorString:
          return mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag;

        case weakMapCtorString:
          return weakMapTag;
      }
    }

    return result;
  };
}
/**
 * Checks if \`value\` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns \`true\` if \`value\` is a valid index, else \`false\`.
 */


function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if \`func\` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns \`true\` if \`func\` is masked, else \`false\`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Checks if \`value\` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a prototype, else \`false\`.
 */


function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}
/**
 * Converts \`func\` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */


function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}
/**
 * Checks if \`value\` is likely an \`arguments\` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an \`arguments\` object,
 *  else \`false\`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */


function isArguments(value) {
  // Safari 8.1 makes \`arguments.callee\` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
/**
 * Checks if \`value\` is classified as an \`Array\` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an array, else \`false\`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */


var isArray = Array.isArray;
/**
 * Checks if \`value\` is array-like. A value is considered array-like if it's
 * not a function and has a \`value.length\` that's an integer greater than or
 * equal to \`0\` and less than or equal to \`Number.MAX_SAFE_INTEGER\`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is array-like, else \`false\`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like \`_.isArrayLike\` except that it also checks if \`value\`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an array-like object,
 *  else \`false\`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */


function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if \`value\` is classified as a \`Function\` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a function, else \`false\`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */


function isFunction(value) {
  // The use of \`Object#toString\` avoids issues with the \`typeof\` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}
/**
 * Checks if \`value\` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [\`ToLength\`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a valid length, else \`false\`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */


function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if \`value\` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of \`Object\`. (e.g. arrays, functions, objects, regexes, \`new Number(0)\`, and \`new String('')\`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an object, else \`false\`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if \`value\` is object-like. A value is object-like if it's not \`null\`
 * and has a \`typeof\` result of \\"object\\".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is object-like, else \`false\`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return !!value && typeof value == 'object';
}
/**
 * Checks if \`value\` is classified as a \`String\` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is a string, else \`false\`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */


function isString(value) {
  return typeof value == 'string' || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
}
/**
 * Converts \`value\` to an array.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Array} Returns the converted array.
 * @example
 *
 * _.toArray({ 'a': 1, 'b': 2 });
 * // => [1, 2]
 *
 * _.toArray('abc');
 * // => ['a', 'b', 'c']
 *
 * _.toArray(1);
 * // => []
 *
 * _.toArray(null);
 * // => []
 */


function toArray(value) {
  if (!value) {
    return [];
  }

  if (isArrayLike(value)) {
    return isString(value) ? stringToArray(value) : copyArray(value);
  }

  if (iteratorSymbol && value[iteratorSymbol]) {
    return iteratorToArray(value[iteratorSymbol]());
  }

  var tag = getTag(value),
      func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
  return func(value);
}
/**
 * Creates an array of the own enumerable property names of \`object\`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
/**
 * Creates an array of the own enumerable string keyed property values of \`object\`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */


function values(object) {
  return object ? baseValues(object, keys(object)) : [];
}

var lodash_toarray = toArray;

const umbrella_with_rain_drops = \\"☔\\";
const coffee = \\"☕\\";
const aries = \\"♈\\";
const taurus = \\"♉\\";
const sagittarius = \\"♐\\";
const capricorn = \\"♑\\";
const aquarius = \\"♒\\";
const pisces = \\"♓\\";
const anchor = \\"⚓\\";
const white_check_mark = \\"✅\\";
const sparkles = \\"✨\\";
const question = \\"❓\\";
const grey_question = \\"❔\\";
const grey_exclamation = \\"❕\\";
const exclamation = \\"❗\\";
const heavy_exclamation_mark = \\"❗\\";
const heavy_plus_sign = \\"➕\\";
const heavy_minus_sign = \\"➖\\";
const heavy_division_sign = \\"➗\\";
const hash = \\"#️⃣\\";
const keycap_star = \\"*️⃣\\";
const zero = \\"0️⃣\\";
const one = \\"1️⃣\\";
const two = \\"2️⃣\\";
const three = \\"3️⃣\\";
const four = \\"4️⃣\\";
const five = \\"5️⃣\\";
const six = \\"6️⃣\\";
const seven = \\"7️⃣\\";
const eight = \\"8️⃣\\";
const nine = \\"9️⃣\\";
const copyright = \\"©️\\";
const registered = \\"®️\\";
const mahjong = \\"🀄\\";
const black_joker = \\"🃏\\";
const a = \\"🅰️\\";
const b = \\"🅱️\\";
const o2 = \\"🅾️\\";
const parking = \\"🅿️\\";
const ab = \\"🆎\\";
const cl = \\"🆑\\";
const cool = \\"🆒\\";
const free = \\"🆓\\";
const id = \\"🆔\\";
const ng = \\"🆖\\";
const ok = \\"🆗\\";
const sos = \\"🆘\\";
const up = \\"🆙\\";
const vs = \\"🆚\\";
const cn = \\"🇨🇳\\";
const de = \\"🇩🇪\\";
const es = \\"🇪🇸\\";
const fr = \\"🇫🇷\\";
const gb = \\"🇬🇧\\";
const uk = \\"🇬🇧\\";
const it = \\"🇮🇹\\";
const jp = \\"🇯🇵\\";
const kr = \\"🇰🇷\\";
const ru = \\"🇷🇺\\";
const us = \\"🇺🇸\\";
const koko = \\"🈁\\";
const sa = \\"🈂️\\";
const u7121 = \\"🈚\\";
const u6307 = \\"🈯\\";
const u7981 = \\"🈲\\";
const u7a7a = \\"🈳\\";
const u5408 = \\"🈴\\";
const u6e80 = \\"🈵\\";
const u6709 = \\"🈶\\";
const u6708 = \\"🈷️\\";
const u7533 = \\"🈸\\";
const u5272 = \\"🈹\\";
const u55b6 = \\"🈺\\";
const ideograph_advantage = \\"🉐\\";
const accept = \\"🉑\\";
const cyclone = \\"🌀\\";
const foggy = \\"🌁\\";
const closed_umbrella = \\"🌂\\";
const night_with_stars = \\"🌃\\";
const sunrise_over_mountains = \\"🌄\\";
const sunrise = \\"🌅\\";
const city_sunset = \\"🌆\\";
const city_sunrise = \\"🌇\\";
const rainbow = \\"🌈\\";
const bridge_at_night = \\"🌉\\";
const ocean = \\"🌊\\";
const volcano = \\"🌋\\";
const milky_way = \\"🌌\\";
const earth_africa = \\"🌍\\";
const earth_americas = \\"🌎\\";
const earth_asia = \\"🌏\\";
const globe_with_meridians = \\"🌐\\";
const new_moon = \\"🌑\\";
const waxing_crescent_moon = \\"🌒\\";
const first_quarter_moon = \\"🌓\\";
const moon = \\"🌔\\";
const waxing_gibbous_moon = \\"🌔\\";
const full_moon = \\"🌕\\";
const waning_gibbous_moon = \\"🌖\\";
const last_quarter_moon = \\"🌗\\";
const waning_crescent_moon = \\"🌘\\";
const crescent_moon = \\"🌙\\";
const new_moon_with_face = \\"🌚\\";
const first_quarter_moon_with_face = \\"🌛\\";
const last_quarter_moon_with_face = \\"🌜\\";
const full_moon_with_face = \\"🌝\\";
const sun_with_face = \\"🌞\\";
const star2 = \\"🌟\\";
const stars = \\"🌠\\";
const thermometer = \\"🌡️\\";
const mostly_sunny = \\"🌤️\\";
const sun_small_cloud = \\"🌤️\\";
const barely_sunny = \\"🌥️\\";
const sun_behind_cloud = \\"🌥️\\";
const partly_sunny_rain = \\"🌦️\\";
const sun_behind_rain_cloud = \\"🌦️\\";
const rain_cloud = \\"🌧️\\";
const snow_cloud = \\"🌨️\\";
const lightning = \\"🌩️\\";
const lightning_cloud = \\"🌩️\\";
const tornado = \\"🌪️\\";
const tornado_cloud = \\"🌪️\\";
const fog = \\"🌫️\\";
const wind_blowing_face = \\"🌬️\\";
const hotdog = \\"🌭\\";
const taco = \\"🌮\\";
const burrito = \\"🌯\\";
const chestnut = \\"🌰\\";
const seedling = \\"🌱\\";
const evergreen_tree = \\"🌲\\";
const deciduous_tree = \\"🌳\\";
const palm_tree = \\"🌴\\";
const cactus = \\"🌵\\";
const hot_pepper = \\"🌶️\\";
const tulip = \\"🌷\\";
const cherry_blossom = \\"🌸\\";
const rose = \\"🌹\\";
const hibiscus = \\"🌺\\";
const sunflower = \\"🌻\\";
const blossom = \\"🌼\\";
const corn = \\"🌽\\";
const ear_of_rice = \\"🌾\\";
const herb = \\"🌿\\";
const four_leaf_clover = \\"🍀\\";
const maple_leaf = \\"🍁\\";
const fallen_leaf = \\"🍂\\";
const leaves = \\"🍃\\";
const mushroom = \\"🍄\\";
const tomato = \\"🍅\\";
const eggplant = \\"🍆\\";
const grapes = \\"🍇\\";
const melon = \\"🍈\\";
const watermelon = \\"🍉\\";
const tangerine = \\"🍊\\";
const lemon = \\"🍋\\";
const banana = \\"🍌\\";
const pineapple = \\"🍍\\";
const apple = \\"🍎\\";
const green_apple = \\"🍏\\";
const pear = \\"🍐\\";
const peach = \\"🍑\\";
const cherries = \\"🍒\\";
const strawberry = \\"🍓\\";
const hamburger = \\"🍔\\";
const pizza = \\"🍕\\";
const meat_on_bone = \\"🍖\\";
const poultry_leg = \\"🍗\\";
const rice_cracker = \\"🍘\\";
const rice_ball = \\"🍙\\";
const rice = \\"🍚\\";
const curry = \\"🍛\\";
const ramen = \\"🍜\\";
const spaghetti = \\"🍝\\";
const bread = \\"🍞\\";
const fries = \\"🍟\\";
const sweet_potato = \\"🍠\\";
const dango = \\"🍡\\";
const oden = \\"🍢\\";
const sushi = \\"🍣\\";
const fried_shrimp = \\"🍤\\";
const fish_cake = \\"🍥\\";
const icecream = \\"🍦\\";
const shaved_ice = \\"🍧\\";
const ice_cream = \\"🍨\\";
const doughnut = \\"🍩\\";
const cookie = \\"🍪\\";
const chocolate_bar = \\"🍫\\";
const candy = \\"🍬\\";
const lollipop = \\"🍭\\";
const custard = \\"🍮\\";
const honey_pot = \\"🍯\\";
const cake = \\"🍰\\";
const bento = \\"🍱\\";
const stew = \\"🍲\\";
const fried_egg = \\"🍳\\";
const cooking = \\"🍳\\";
const fork_and_knife = \\"🍴\\";
const tea = \\"🍵\\";
const sake = \\"🍶\\";
const wine_glass = \\"🍷\\";
const cocktail = \\"🍸\\";
const tropical_drink = \\"🍹\\";
const beer = \\"🍺\\";
const beers = \\"🍻\\";
const baby_bottle = \\"🍼\\";
const knife_fork_plate = \\"🍽️\\";
const champagne = \\"🍾\\";
const popcorn = \\"🍿\\";
const ribbon = \\"🎀\\";
const gift = \\"🎁\\";
const birthday = \\"🎂\\";
const jack_o_lantern = \\"🎃\\";
const christmas_tree = \\"🎄\\";
const santa = \\"🎅\\";
const fireworks = \\"🎆\\";
const sparkler = \\"🎇\\";
const balloon = \\"🎈\\";
const tada = \\"🎉\\";
const confetti_ball = \\"🎊\\";
const tanabata_tree = \\"🎋\\";
const crossed_flags = \\"🎌\\";
const bamboo = \\"🎍\\";
const dolls = \\"🎎\\";
const flags = \\"🎏\\";
const wind_chime = \\"🎐\\";
const rice_scene = \\"🎑\\";
const school_satchel = \\"🎒\\";
const mortar_board = \\"🎓\\";
const medal = \\"🎖️\\";
const reminder_ribbon = \\"🎗️\\";
const studio_microphone = \\"🎙️\\";
const level_slider = \\"🎚️\\";
const control_knobs = \\"🎛️\\";
const film_frames = \\"🎞️\\";
const admission_tickets = \\"🎟️\\";
const carousel_horse = \\"🎠\\";
const ferris_wheel = \\"🎡\\";
const roller_coaster = \\"🎢\\";
const fishing_pole_and_fish = \\"🎣\\";
const microphone = \\"🎤\\";
const movie_camera = \\"🎥\\";
const cinema = \\"🎦\\";
const headphones = \\"🎧\\";
const art = \\"🎨\\";
const tophat = \\"🎩\\";
const circus_tent = \\"🎪\\";
const ticket = \\"🎫\\";
const clapper = \\"🎬\\";
const performing_arts = \\"🎭\\";
const video_game = \\"🎮\\";
const dart = \\"🎯\\";
const slot_machine = \\"🎰\\";
const game_die = \\"🎲\\";
const bowling = \\"🎳\\";
const flower_playing_cards = \\"🎴\\";
const musical_note = \\"🎵\\";
const notes = \\"🎶\\";
const saxophone = \\"🎷\\";
const guitar = \\"🎸\\";
const musical_keyboard = \\"🎹\\";
const trumpet = \\"🎺\\";
const violin = \\"🎻\\";
const musical_score = \\"🎼\\";
const running_shirt_with_sash = \\"🎽\\";
const tennis = \\"🎾\\";
const ski = \\"🎿\\";
const basketball = \\"🏀\\";
const checkered_flag = \\"🏁\\";
const snowboarder = \\"🏂\\";
const runner = \\"🏃‍♂️\\";
const running = \\"🏃‍♂️\\";
const surfer = \\"🏄‍♂️\\";
const sports_medal = \\"🏅\\";
const trophy = \\"🏆\\";
const horse_racing = \\"🏇\\";
const football = \\"🏈\\";
const rugby_football = \\"🏉\\";
const swimmer = \\"🏊‍♂️\\";
const weight_lifter = \\"🏋️‍♂️\\";
const golfer = \\"🏌️‍♂️\\";
const racing_motorcycle = \\"🏍️\\";
const racing_car = \\"🏎️\\";
const cricket_bat_and_ball = \\"🏏\\";
const volleyball = \\"🏐\\";
const field_hockey_stick_and_ball = \\"🏑\\";
const ice_hockey_stick_and_puck = \\"🏒\\";
const table_tennis_paddle_and_ball = \\"🏓\\";
const snow_capped_mountain = \\"🏔️\\";
const camping = \\"🏕️\\";
const beach_with_umbrella = \\"🏖️\\";
const building_construction = \\"🏗️\\";
const house_buildings = \\"🏘️\\";
const cityscape = \\"🏙️\\";
const derelict_house_building = \\"🏚️\\";
const classical_building = \\"🏛️\\";
const desert = \\"🏜️\\";
const desert_island = \\"🏝️\\";
const national_park = \\"🏞️\\";
const stadium = \\"🏟️\\";
const house = \\"🏠\\";
const house_with_garden = \\"🏡\\";
const office = \\"🏢\\";
const post_office = \\"🏣\\";
const european_post_office = \\"🏤\\";
const hospital = \\"🏥\\";
const bank = \\"🏦\\";
const atm = \\"🏧\\";
const hotel = \\"🏨\\";
const love_hotel = \\"🏩\\";
const convenience_store = \\"🏪\\";
const school = \\"🏫\\";
const department_store = \\"🏬\\";
const factory = \\"🏭\\";
const izakaya_lantern = \\"🏮\\";
const lantern = \\"🏮\\";
const japanese_castle = \\"🏯\\";
const european_castle = \\"🏰\\";
const waving_white_flag = \\"🏳️\\";
const waving_black_flag = \\"🏴\\";
const rosette = \\"🏵️\\";
const label = \\"🏷️\\";
const badminton_racquet_and_shuttlecock = \\"🏸\\";
const bow_and_arrow = \\"🏹\\";
const amphora = \\"🏺\\";
const rat = \\"🐀\\";
const mouse2 = \\"🐁\\";
const ox = \\"🐂\\";
const water_buffalo = \\"🐃\\";
const cow2 = \\"🐄\\";
const tiger2 = \\"🐅\\";
const leopard = \\"🐆\\";
const rabbit2 = \\"🐇\\";
const cat2 = \\"🐈\\";
const dragon = \\"🐉\\";
const crocodile = \\"🐊\\";
const whale2 = \\"🐋\\";
const snail = \\"🐌\\";
const snake = \\"🐍\\";
const racehorse = \\"🐎\\";
const ram = \\"🐏\\";
const goat = \\"🐐\\";
const sheep = \\"🐑\\";
const monkey = \\"🐒\\";
const rooster = \\"🐓\\";
const chicken = \\"🐔\\";
const dog2 = \\"🐕\\";
const pig2 = \\"🐖\\";
const boar = \\"🐗\\";
const elephant = \\"🐘\\";
const octopus = \\"🐙\\";
const shell = \\"🐚\\";
const bug = \\"🐛\\";
const ant = \\"🐜\\";
const bee = \\"🐝\\";
const honeybee = \\"🐝\\";
const beetle = \\"🐞\\";
const fish = \\"🐟\\";
const tropical_fish = \\"🐠\\";
const blowfish = \\"🐡\\";
const turtle = \\"🐢\\";
const hatching_chick = \\"🐣\\";
const baby_chick = \\"🐤\\";
const hatched_chick = \\"🐥\\";
const bird = \\"🐦\\";
const penguin = \\"🐧\\";
const koala = \\"🐨\\";
const poodle = \\"🐩\\";
const dromedary_camel = \\"🐪\\";
const camel = \\"🐫\\";
const dolphin = \\"🐬\\";
const flipper = \\"🐬\\";
const mouse = \\"🐭\\";
const cow = \\"🐮\\";
const tiger = \\"🐯\\";
const rabbit = \\"🐰\\";
const cat = \\"🐱\\";
const dragon_face = \\"🐲\\";
const whale = \\"🐳\\";
const horse = \\"🐴\\";
const monkey_face = \\"🐵\\";
const dog = \\"🐶\\";
const pig = \\"🐷\\";
const frog = \\"🐸\\";
const hamster = \\"🐹\\";
const wolf = \\"🐺\\";
const bear = \\"🐻\\";
const panda_face = \\"🐼\\";
const pig_nose = \\"🐽\\";
const feet = \\"🐾\\";
const paw_prints = \\"🐾\\";
const chipmunk = \\"🐿️\\";
const eyes = \\"👀\\";
const eye = \\"👁️\\";
const ear = \\"👂\\";
const nose = \\"👃\\";
const lips = \\"👄\\";
const tongue = \\"👅\\";
const point_up_2 = \\"👆\\";
const point_down = \\"👇\\";
const point_left = \\"👈\\";
const point_right = \\"👉\\";
const facepunch = \\"👊\\";
const punch = \\"👊\\";
const wave = \\"👋\\";
const ok_hand = \\"👌\\";
const thumbsup = \\"👍\\";
const thumbsdown = \\"👎\\";
const clap = \\"👏\\";
const open_hands = \\"👐\\";
const crown = \\"👑\\";
const womans_hat = \\"👒\\";
const eyeglasses = \\"👓\\";
const necktie = \\"👔\\";
const shirt = \\"👕\\";
const tshirt = \\"👕\\";
const jeans = \\"👖\\";
const dress = \\"👗\\";
const kimono = \\"👘\\";
const bikini = \\"👙\\";
const womans_clothes = \\"👚\\";
const purse = \\"👛\\";
const handbag = \\"👜\\";
const pouch = \\"👝\\";
const mans_shoe = \\"👞\\";
const shoe = \\"👞\\";
const athletic_shoe = \\"👟\\";
const high_heel = \\"👠\\";
const sandal = \\"👡\\";
const boot = \\"👢\\";
const footprints = \\"👣\\";
const bust_in_silhouette = \\"👤\\";
const busts_in_silhouette = \\"👥\\";
const boy = \\"👦\\";
const girl = \\"👧\\";
const family = \\"👨‍👩‍👦\\";
const man = \\"👨\\";
const couple_with_heart = \\"👩‍❤️‍👨\\";
const couplekiss = \\"👩‍❤️‍💋‍👨\\";
const woman = \\"👩\\";
const couple = \\"👫\\";
const man_and_woman_holding_hands = \\"👫\\";
const two_men_holding_hands = \\"👬\\";
const two_women_holding_hands = \\"👭\\";
const cop = \\"👮‍♂️\\";
const dancers = \\"👯‍♀️\\";
const bride_with_veil = \\"👰\\";
const person_with_blond_hair = \\"👱‍♂️\\";
const man_with_gua_pi_mao = \\"👲\\";
const man_with_turban = \\"👳‍♂️\\";
const older_man = \\"👴\\";
const older_woman = \\"👵\\";
const baby = \\"👶\\";
const construction_worker = \\"👷‍♂️\\";
const princess = \\"👸\\";
const japanese_ogre = \\"👹\\";
const japanese_goblin = \\"👺\\";
const ghost = \\"👻\\";
const angel = \\"👼\\";
const alien = \\"👽\\";
const space_invader = \\"👾\\";
const imp = \\"👿\\";
const skull = \\"💀\\";
const information_desk_person = \\"💁‍♀️\\";
const guardsman = \\"💂‍♂️\\";
const dancer = \\"💃\\";
const lipstick = \\"💄\\";
const nail_care = \\"💅\\";
const massage = \\"💆‍♀️\\";
const haircut = \\"💇‍♀️\\";
const barber = \\"💈\\";
const syringe = \\"💉\\";
const pill = \\"💊\\";
const kiss = \\"💋\\";
const love_letter = \\"💌\\";
const ring = \\"💍\\";
const gem = \\"💎\\";
const bouquet = \\"💐\\";
const wedding = \\"💒\\";
const heartbeat = \\"💓\\";
const broken_heart = \\"💔\\";
const two_hearts = \\"💕\\";
const sparkling_heart = \\"💖\\";
const heartpulse = \\"💗\\";
const cupid = \\"💘\\";
const blue_heart = \\"💙\\";
const green_heart = \\"💚\\";
const yellow_heart = \\"💛\\";
const purple_heart = \\"💜\\";
const gift_heart = \\"💝\\";
const revolving_hearts = \\"💞\\";
const heart_decoration = \\"💟\\";
const diamond_shape_with_a_dot_inside = \\"💠\\";
const bulb = \\"💡\\";
const anger = \\"💢\\";
const bomb = \\"💣\\";
const zzz = \\"💤\\";
const boom = \\"💥\\";
const collision = \\"💥\\";
const sweat_drops = \\"💦\\";
const droplet = \\"💧\\";
const dash = \\"💨\\";
const hankey = \\"💩\\";
const poop = \\"💩\\";
const shit = \\"💩\\";
const muscle = \\"💪\\";
const dizzy = \\"💫\\";
const speech_balloon = \\"💬\\";
const thought_balloon = \\"💭\\";
const white_flower = \\"💮\\";
const moneybag = \\"💰\\";
const currency_exchange = \\"💱\\";
const heavy_dollar_sign = \\"💲\\";
const credit_card = \\"💳\\";
const yen = \\"💴\\";
const dollar = \\"💵\\";
const euro = \\"💶\\";
const pound = \\"💷\\";
const money_with_wings = \\"💸\\";
const chart = \\"💹\\";
const seat = \\"💺\\";
const computer = \\"💻\\";
const briefcase = \\"💼\\";
const minidisc = \\"💽\\";
const floppy_disk = \\"💾\\";
const cd = \\"💿\\";
const dvd = \\"📀\\";
const file_folder = \\"📁\\";
const open_file_folder = \\"📂\\";
const page_with_curl = \\"📃\\";
const page_facing_up = \\"📄\\";
const date = \\"📅\\";
const calendar = \\"📆\\";
const card_index = \\"📇\\";
const chart_with_upwards_trend = \\"📈\\";
const chart_with_downwards_trend = \\"📉\\";
const bar_chart = \\"📊\\";
const clipboard = \\"📋\\";
const pushpin = \\"📌\\";
const round_pushpin = \\"📍\\";
const paperclip = \\"📎\\";
const straight_ruler = \\"📏\\";
const triangular_ruler = \\"📐\\";
const bookmark_tabs = \\"📑\\";
const ledger = \\"📒\\";
const notebook = \\"📓\\";
const notebook_with_decorative_cover = \\"📔\\";
const closed_book = \\"📕\\";
const book = \\"📖\\";
const open_book = \\"📖\\";
const green_book = \\"📗\\";
const blue_book = \\"📘\\";
const orange_book = \\"📙\\";
const books = \\"📚\\";
const name_badge = \\"📛\\";
const scroll = \\"📜\\";
const memo = \\"📝\\";
const pencil = \\"📝\\";
const telephone_receiver = \\"📞\\";
const pager = \\"📟\\";
const fax = \\"📠\\";
const satellite_antenna = \\"📡\\";
const loudspeaker = \\"📢\\";
const mega = \\"📣\\";
const outbox_tray = \\"📤\\";
const inbox_tray = \\"📥\\";
const incoming_envelope = \\"📨\\";
const envelope_with_arrow = \\"📩\\";
const mailbox_closed = \\"📪\\";
const mailbox = \\"📫\\";
const mailbox_with_mail = \\"📬\\";
const mailbox_with_no_mail = \\"📭\\";
const postbox = \\"📮\\";
const postal_horn = \\"📯\\";
const newspaper = \\"📰\\";
const iphone = \\"📱\\";
const calling = \\"📲\\";
const vibration_mode = \\"📳\\";
const mobile_phone_off = \\"📴\\";
const no_mobile_phones = \\"📵\\";
const signal_strength = \\"📶\\";
const camera = \\"📷\\";
const camera_with_flash = \\"📸\\";
const video_camera = \\"📹\\";
const tv = \\"📺\\";
const radio = \\"📻\\";
const vhs = \\"📼\\";
const film_projector = \\"📽️\\";
const prayer_beads = \\"📿\\";
const twisted_rightwards_arrows = \\"🔀\\";
const repeat = \\"🔁\\";
const repeat_one = \\"🔂\\";
const arrows_clockwise = \\"🔃\\";
const arrows_counterclockwise = \\"🔄\\";
const low_brightness = \\"🔅\\";
const high_brightness = \\"🔆\\";
const mute = \\"🔇\\";
const speaker = \\"🔈\\";
const sound = \\"🔉\\";
const loud_sound = \\"🔊\\";
const battery = \\"🔋\\";
const electric_plug = \\"🔌\\";
const mag = \\"🔍\\";
const mag_right = \\"🔎\\";
const lock_with_ink_pen = \\"🔏\\";
const closed_lock_with_key = \\"🔐\\";
const key = \\"🔑\\";
const lock = \\"🔒\\";
const unlock = \\"🔓\\";
const bell = \\"🔔\\";
const no_bell = \\"🔕\\";
const bookmark = \\"🔖\\";
const link$1 = \\"🔗\\";
const radio_button = \\"🔘\\";
const back = \\"🔙\\";
const end = \\"🔚\\";
const on = \\"🔛\\";
const soon = \\"🔜\\";
const top = \\"🔝\\";
const underage = \\"🔞\\";
const keycap_ten = \\"🔟\\";
const capital_abcd = \\"🔠\\";
const abcd = \\"🔡\\";
const symbols = \\"🔣\\";
const abc = \\"🔤\\";
const fire = \\"🔥\\";
const flashlight = \\"🔦\\";
const wrench = \\"🔧\\";
const hammer = \\"🔨\\";
const nut_and_bolt = \\"🔩\\";
const hocho = \\"🔪\\";
const knife = \\"🔪\\";
const gun = \\"🔫\\";
const microscope = \\"🔬\\";
const telescope = \\"🔭\\";
const crystal_ball = \\"🔮\\";
const six_pointed_star = \\"🔯\\";
const beginner = \\"🔰\\";
const trident = \\"🔱\\";
const black_square_button = \\"🔲\\";
const white_square_button = \\"🔳\\";
const red_circle = \\"🔴\\";
const large_blue_circle = \\"🔵\\";
const large_orange_diamond = \\"🔶\\";
const large_blue_diamond = \\"🔷\\";
const small_orange_diamond = \\"🔸\\";
const small_blue_diamond = \\"🔹\\";
const small_red_triangle = \\"🔺\\";
const small_red_triangle_down = \\"🔻\\";
const arrow_up_small = \\"🔼\\";
const arrow_down_small = \\"🔽\\";
const om_symbol = \\"🕉️\\";
const dove_of_peace = \\"🕊️\\";
const kaaba = \\"🕋\\";
const mosque = \\"🕌\\";
const synagogue = \\"🕍\\";
const menorah_with_nine_branches = \\"🕎\\";
const clock1 = \\"🕐\\";
const clock2 = \\"🕑\\";
const clock3 = \\"🕒\\";
const clock4 = \\"🕓\\";
const clock5 = \\"🕔\\";
const clock6 = \\"🕕\\";
const clock7 = \\"🕖\\";
const clock8 = \\"🕗\\";
const clock9 = \\"🕘\\";
const clock10 = \\"🕙\\";
const clock11 = \\"🕚\\";
const clock12 = \\"🕛\\";
const clock130 = \\"🕜\\";
const clock230 = \\"🕝\\";
const clock330 = \\"🕞\\";
const clock430 = \\"🕟\\";
const clock530 = \\"🕠\\";
const clock630 = \\"🕡\\";
const clock730 = \\"🕢\\";
const clock830 = \\"🕣\\";
const clock930 = \\"🕤\\";
const clock1030 = \\"🕥\\";
const clock1130 = \\"🕦\\";
const clock1230 = \\"🕧\\";
const candle = \\"🕯️\\";
const mantelpiece_clock = \\"🕰️\\";
const hole = \\"🕳️\\";
const man_in_business_suit_levitating = \\"🕴️\\";
const sleuth_or_spy = \\"🕵️‍♂️\\";
const dark_sunglasses = \\"🕶️\\";
const spider = \\"🕷️\\";
const spider_web = \\"🕸️\\";
const joystick = \\"🕹️\\";
const man_dancing = \\"🕺\\";
const linked_paperclips = \\"🖇️\\";
const lower_left_ballpoint_pen = \\"🖊️\\";
const lower_left_fountain_pen = \\"🖋️\\";
const lower_left_paintbrush = \\"🖌️\\";
const lower_left_crayon = \\"🖍️\\";
const raised_hand_with_fingers_splayed = \\"🖐️\\";
const middle_finger = \\"🖕\\";
const reversed_hand_with_middle_finger_extended = \\"🖕\\";
const black_heart = \\"🖤\\";
const desktop_computer = \\"🖥️\\";
const printer = \\"🖨️\\";
const three_button_mouse = \\"🖱️\\";
const trackball = \\"🖲️\\";
const frame_with_picture = \\"🖼️\\";
const card_index_dividers = \\"🗂️\\";
const card_file_box = \\"🗃️\\";
const file_cabinet = \\"🗄️\\";
const wastebasket = \\"🗑️\\";
const spiral_note_pad = \\"🗒️\\";
const spiral_calendar_pad = \\"🗓️\\";
const compression = \\"🗜️\\";
const old_key = \\"🗝️\\";
const rolled_up_newspaper = \\"🗞️\\";
const dagger_knife = \\"🗡️\\";
const speaking_head_in_silhouette = \\"🗣️\\";
const left_speech_bubble = \\"🗨️\\";
const right_anger_bubble = \\"🗯️\\";
const ballot_box_with_ballot = \\"🗳️\\";
const world_map = \\"🗺️\\";
const mount_fuji = \\"🗻\\";
const tokyo_tower = \\"🗼\\";
const statue_of_liberty = \\"🗽\\";
const japan = \\"🗾\\";
const moyai = \\"🗿\\";
const grinning = \\"😀\\";
const grin = \\"😁\\";
const joy = \\"😂\\";
const smiley = \\"😃\\";
const smile = \\"😄\\";
const sweat_smile = \\"😅\\";
const laughing = \\"😆\\";
const satisfied = \\"😆\\";
const innocent = \\"😇\\";
const smiling_imp = \\"😈\\";
const wink = \\"😉\\";
const blush = \\"😊\\";
const yum = \\"😋\\";
const relieved = \\"😌\\";
const heart_eyes = \\"😍\\";
const sunglasses = \\"😎\\";
const smirk = \\"😏\\";
const neutral_face = \\"😐\\";
const expressionless = \\"😑\\";
const unamused = \\"😒\\";
const sweat = \\"😓\\";
const pensive = \\"😔\\";
const confused = \\"😕\\";
const confounded = \\"😖\\";
const kissing = \\"😗\\";
const kissing_heart = \\"😘\\";
const kissing_smiling_eyes = \\"😙\\";
const kissing_closed_eyes = \\"😚\\";
const stuck_out_tongue = \\"😛\\";
const stuck_out_tongue_winking_eye = \\"😜\\";
const stuck_out_tongue_closed_eyes = \\"😝\\";
const disappointed = \\"😞\\";
const worried = \\"😟\\";
const angry = \\"😠\\";
const rage = \\"😡\\";
const cry = \\"😢\\";
const persevere = \\"😣\\";
const triumph = \\"😤\\";
const disappointed_relieved = \\"😥\\";
const frowning = \\"😦\\";
const anguished = \\"😧\\";
const fearful = \\"😨\\";
const weary = \\"😩\\";
const sleepy = \\"😪\\";
const tired_face = \\"😫\\";
const grimacing = \\"😬\\";
const sob = \\"😭\\";
const open_mouth = \\"😮\\";
const hushed = \\"😯\\";
const cold_sweat = \\"😰\\";
const scream = \\"😱\\";
const astonished = \\"😲\\";
const flushed = \\"😳\\";
const sleeping = \\"😴\\";
const dizzy_face = \\"😵\\";
const no_mouth = \\"😶\\";
const mask = \\"😷\\";
const smile_cat = \\"😸\\";
const joy_cat = \\"😹\\";
const smiley_cat = \\"😺\\";
const heart_eyes_cat = \\"😻\\";
const smirk_cat = \\"😼\\";
const kissing_cat = \\"😽\\";
const pouting_cat = \\"😾\\";
const crying_cat_face = \\"😿\\";
const scream_cat = \\"🙀\\";
const slightly_frowning_face = \\"🙁\\";
const slightly_smiling_face = \\"🙂\\";
const upside_down_face = \\"🙃\\";
const face_with_rolling_eyes = \\"🙄\\";
const no_good = \\"🙅‍♀️\\";
const ok_woman = \\"🙆‍♀️\\";
const bow = \\"🙇‍♂️\\";
const see_no_evil = \\"🙈\\";
const hear_no_evil = \\"🙉\\";
const speak_no_evil = \\"🙊\\";
const raising_hand = \\"🙋‍♀️\\";
const raised_hands = \\"🙌\\";
const person_frowning = \\"🙍‍♀️\\";
const person_with_pouting_face = \\"🙎‍♀️\\";
const pray = \\"🙏\\";
const rocket = \\"🚀\\";
const helicopter = \\"🚁\\";
const steam_locomotive = \\"🚂\\";
const railway_car = \\"🚃\\";
const bullettrain_side = \\"🚄\\";
const bullettrain_front = \\"🚅\\";
const train2 = \\"🚆\\";
const metro = \\"🚇\\";
const light_rail = \\"🚈\\";
const station = \\"🚉\\";
const tram = \\"🚊\\";
const train = \\"🚋\\";
const bus = \\"🚌\\";
const oncoming_bus = \\"🚍\\";
const trolleybus = \\"🚎\\";
const busstop = \\"🚏\\";
const minibus = \\"🚐\\";
const ambulance = \\"🚑\\";
const fire_engine = \\"🚒\\";
const police_car = \\"🚓\\";
const oncoming_police_car = \\"🚔\\";
const taxi = \\"🚕\\";
const oncoming_taxi = \\"🚖\\";
const car = \\"🚗\\";
const red_car = \\"🚗\\";
const oncoming_automobile = \\"🚘\\";
const blue_car = \\"🚙\\";
const truck = \\"🚚\\";
const articulated_lorry = \\"🚛\\";
const tractor = \\"🚜\\";
const monorail = \\"🚝\\";
const mountain_railway = \\"🚞\\";
const suspension_railway = \\"🚟\\";
const mountain_cableway = \\"🚠\\";
const aerial_tramway = \\"🚡\\";
const ship = \\"🚢\\";
const rowboat = \\"🚣‍♂️\\";
const speedboat = \\"🚤\\";
const traffic_light = \\"🚥\\";
const vertical_traffic_light = \\"🚦\\";
const construction = \\"🚧\\";
const rotating_light = \\"🚨\\";
const triangular_flag_on_post = \\"🚩\\";
const door = \\"🚪\\";
const no_entry_sign = \\"🚫\\";
const smoking = \\"🚬\\";
const no_smoking = \\"🚭\\";
const put_litter_in_its_place = \\"🚮\\";
const do_not_litter = \\"🚯\\";
const potable_water = \\"🚰\\";
const bike = \\"🚲\\";
const no_bicycles = \\"🚳\\";
const bicyclist = \\"🚴‍♂️\\";
const mountain_bicyclist = \\"🚵‍♂️\\";
const walking = \\"🚶‍♂️\\";
const no_pedestrians = \\"🚷\\";
const children_crossing = \\"🚸\\";
const mens = \\"🚹\\";
const womens = \\"🚺\\";
const restroom = \\"🚻\\";
const baby_symbol = \\"🚼\\";
const toilet = \\"🚽\\";
const wc = \\"🚾\\";
const shower = \\"🚿\\";
const bath = \\"🛀\\";
const bathtub = \\"🛁\\";
const passport_control = \\"🛂\\";
const customs = \\"🛃\\";
const baggage_claim = \\"🛄\\";
const left_luggage = \\"🛅\\";
const couch_and_lamp = \\"🛋️\\";
const sleeping_accommodation = \\"🛌\\";
const shopping_bags = \\"🛍️\\";
const bellhop_bell = \\"🛎️\\";
const bed = \\"🛏️\\";
const place_of_worship = \\"🛐\\";
const octagonal_sign = \\"🛑\\";
const shopping_trolley = \\"🛒\\";
const hammer_and_wrench = \\"🛠️\\";
const shield = \\"🛡️\\";
const oil_drum = \\"🛢️\\";
const motorway = \\"🛣️\\";
const railway_track = \\"🛤️\\";
const motor_boat = \\"🛥️\\";
const small_airplane = \\"🛩️\\";
const airplane_departure = \\"🛫\\";
const airplane_arriving = \\"🛬\\";
const satellite = \\"🛰️\\";
const passenger_ship = \\"🛳️\\";
const scooter = \\"🛴\\";
const motor_scooter = \\"🛵\\";
const canoe = \\"🛶\\";
const sled = \\"🛷\\";
const flying_saucer = \\"🛸\\";
const zipper_mouth_face = \\"🤐\\";
const money_mouth_face = \\"🤑\\";
const face_with_thermometer = \\"🤒\\";
const nerd_face = \\"🤓\\";
const thinking_face = \\"🤔\\";
const face_with_head_bandage = \\"🤕\\";
const robot_face = \\"🤖\\";
const hugging_face = \\"🤗\\";
const the_horns = \\"🤘\\";
const sign_of_the_horns = \\"🤘\\";
const call_me_hand = \\"🤙\\";
const raised_back_of_hand = \\"🤚\\";
const handshake = \\"🤝\\";
const crossed_fingers = \\"🤞\\";
const hand_with_index_and_middle_fingers_crossed = \\"🤞\\";
const i_love_you_hand_sign = \\"🤟\\";
const face_with_cowboy_hat = \\"🤠\\";
const clown_face = \\"🤡\\";
const nauseated_face = \\"🤢\\";
const rolling_on_the_floor_laughing = \\"🤣\\";
const drooling_face = \\"🤤\\";
const lying_face = \\"🤥\\";
const face_palm = \\"🤦\\";
const sneezing_face = \\"🤧\\";
const face_with_raised_eyebrow = \\"🤨\\";
const face_with_one_eyebrow_raised = \\"🤨\\";
const grinning_face_with_star_eyes = \\"🤩\\";
const zany_face = \\"🤪\\";
const grinning_face_with_one_large_and_one_small_eye = \\"🤪\\";
const shushing_face = \\"🤫\\";
const face_with_finger_covering_closed_lips = \\"🤫\\";
const face_with_symbols_on_mouth = \\"🤬\\";
const serious_face_with_symbols_covering_mouth = \\"🤬\\";
const face_with_hand_over_mouth = \\"🤭\\";
const smiling_face_with_smiling_eyes_and_hand_covering_mouth = \\"🤭\\";
const face_vomiting = \\"🤮\\";
const face_with_open_mouth_vomiting = \\"🤮\\";
const exploding_head = \\"🤯\\";
const shocked_face_with_exploding_head = \\"🤯\\";
const pregnant_woman = \\"🤰\\";
const palms_up_together = \\"🤲\\";
const selfie = \\"🤳\\";
const prince = \\"🤴\\";
const man_in_tuxedo = \\"🤵\\";
const mrs_claus = \\"🤶\\";
const mother_christmas = \\"🤶\\";
const shrug = \\"🤷\\";
const person_doing_cartwheel = \\"🤸\\";
const juggling = \\"🤹\\";
const fencer = \\"🤺\\";
const wrestlers = \\"🤼\\";
const water_polo = \\"🤽\\";
const handball = \\"🤾\\";
const wilted_flower = \\"🥀\\";
const drum_with_drumsticks = \\"🥁\\";
const clinking_glasses = \\"🥂\\";
const tumbler_glass = \\"🥃\\";
const spoon = \\"🥄\\";
const goal_net = \\"🥅\\";
const first_place_medal = \\"🥇\\";
const second_place_medal = \\"🥈\\";
const third_place_medal = \\"🥉\\";
const boxing_glove = \\"🥊\\";
const martial_arts_uniform = \\"🥋\\";
const curling_stone = \\"🥌\\";
const croissant = \\"🥐\\";
const avocado = \\"🥑\\";
const cucumber = \\"🥒\\";
const bacon = \\"🥓\\";
const potato = \\"🥔\\";
const carrot = \\"🥕\\";
const baguette_bread = \\"🥖\\";
const green_salad = \\"🥗\\";
const shallow_pan_of_food = \\"🥘\\";
const stuffed_flatbread = \\"🥙\\";
const egg = \\"🥚\\";
const glass_of_milk = \\"🥛\\";
const peanuts = \\"🥜\\";
const kiwifruit = \\"🥝\\";
const pancakes = \\"🥞\\";
const dumpling = \\"🥟\\";
const fortune_cookie = \\"🥠\\";
const takeout_box = \\"🥡\\";
const chopsticks = \\"🥢\\";
const bowl_with_spoon = \\"🥣\\";
const cup_with_straw = \\"🥤\\";
const coconut = \\"🥥\\";
const broccoli = \\"🥦\\";
const pie = \\"🥧\\";
const pretzel = \\"🥨\\";
const cut_of_meat = \\"🥩\\";
const sandwich = \\"🥪\\";
const canned_food = \\"🥫\\";
const crab = \\"🦀\\";
const lion_face = \\"🦁\\";
const scorpion = \\"🦂\\";
const turkey = \\"🦃\\";
const unicorn_face = \\"🦄\\";
const eagle = \\"🦅\\";
const duck = \\"🦆\\";
const bat = \\"🦇\\";
const shark = \\"🦈\\";
const owl = \\"🦉\\";
const fox_face = \\"🦊\\";
const butterfly = \\"🦋\\";
const deer = \\"🦌\\";
const gorilla = \\"🦍\\";
const lizard = \\"🦎\\";
const rhinoceros = \\"🦏\\";
const shrimp = \\"🦐\\";
const squid = \\"🦑\\";
const giraffe_face = \\"🦒\\";
const zebra_face = \\"🦓\\";
const hedgehog = \\"🦔\\";
const sauropod = \\"🦕\\";
const cricket = \\"🦗\\";
const cheese_wedge = \\"🧀\\";
const face_with_monocle = \\"🧐\\";
const adult = \\"🧑\\";
const child = \\"🧒\\";
const older_adult = \\"🧓\\";
const bearded_person = \\"🧔\\";
const person_with_headscarf = \\"🧕\\";
const woman_in_steamy_room = \\"🧖‍♀️\\";
const man_in_steamy_room = \\"🧖‍♂️\\";
const person_in_steamy_room = \\"🧖‍♂️\\";
const woman_climbing = \\"🧗‍♀️\\";
const person_climbing = \\"🧗‍♀️\\";
const man_climbing = \\"🧗‍♂️\\";
const woman_in_lotus_position = \\"🧘‍♀️\\";
const person_in_lotus_position = \\"🧘‍♀️\\";
const man_in_lotus_position = \\"🧘‍♂️\\";
const female_mage = \\"🧙‍♀️\\";
const mage = \\"🧙‍♀️\\";
const male_mage = \\"🧙‍♂️\\";
const female_fairy = \\"🧚‍♀️\\";
const fairy = \\"🧚‍♀️\\";
const male_fairy = \\"🧚‍♂️\\";
const female_vampire = \\"🧛‍♀️\\";
const vampire = \\"🧛‍♀️\\";
const male_vampire = \\"🧛‍♂️\\";
const mermaid = \\"🧜‍♀️\\";
const merman = \\"🧜‍♂️\\";
const merperson = \\"🧜‍♂️\\";
const female_elf = \\"🧝‍♀️\\";
const male_elf = \\"🧝‍♂️\\";
const elf = \\"🧝‍♂️\\";
const female_genie = \\"🧞‍♀️\\";
const male_genie = \\"🧞‍♂️\\";
const genie = \\"🧞‍♂️\\";
const female_zombie = \\"🧟‍♀️\\";
const male_zombie = \\"🧟‍♂️\\";
const zombie = \\"🧟‍♂️\\";
const brain = \\"🧠\\";
const orange_heart = \\"🧡\\";
const billed_cap = \\"🧢\\";
const scarf = \\"🧣\\";
const gloves = \\"🧤\\";
const coat = \\"🧥\\";
const socks = \\"🧦\\";
const bangbang = \\"‼️\\";
const interrobang = \\"⁉️\\";
const tm = \\"™️\\";
const information_source = \\"ℹ️\\";
const left_right_arrow = \\"↔️\\";
const arrow_up_down = \\"↕️\\";
const arrow_upper_left = \\"↖️\\";
const arrow_upper_right = \\"↗️\\";
const arrow_lower_right = \\"↘️\\";
const arrow_lower_left = \\"↙️\\";
const leftwards_arrow_with_hook = \\"↩️\\";
const arrow_right_hook = \\"↪️\\";
const watch = \\"⌚\\";
const hourglass = \\"⌛\\";
const keyboard = \\"⌨️\\";
const eject = \\"⏏️\\";
const fast_forward = \\"⏩\\";
const rewind = \\"⏪\\";
const arrow_double_up = \\"⏫\\";
const arrow_double_down = \\"⏬\\";
const black_right_pointing_double_triangle_with_vertical_bar = \\"⏭️\\";
const black_left_pointing_double_triangle_with_vertical_bar = \\"⏮️\\";
const black_right_pointing_triangle_with_double_vertical_bar = \\"⏯️\\";
const alarm_clock = \\"⏰\\";
const stopwatch = \\"⏱️\\";
const timer_clock = \\"⏲️\\";
const hourglass_flowing_sand = \\"⏳\\";
const double_vertical_bar = \\"⏸️\\";
const black_square_for_stop = \\"⏹️\\";
const black_circle_for_record = \\"⏺️\\";
const m = \\"Ⓜ️\\";
const black_small_square = \\"▪️\\";
const white_small_square = \\"▫️\\";
const arrow_forward = \\"▶️\\";
const arrow_backward = \\"◀️\\";
const white_medium_square = \\"◻️\\";
const black_medium_square = \\"◼️\\";
const white_medium_small_square = \\"◽\\";
const black_medium_small_square = \\"◾\\";
const sunny = \\"☀️\\";
const cloud = \\"☁️\\";
const umbrella = \\"☂️\\";
const snowman = \\"☃️\\";
const comet = \\"☄️\\";
const phone = \\"☎️\\";
const telephone = \\"☎️\\";
const ballot_box_with_check = \\"☑️\\";
const shamrock = \\"☘️\\";
const point_up = \\"☝️\\";
const skull_and_crossbones = \\"☠️\\";
const radioactive_sign = \\"☢️\\";
const biohazard_sign = \\"☣️\\";
const orthodox_cross = \\"☦️\\";
const star_and_crescent = \\"☪️\\";
const peace_symbol = \\"☮️\\";
const yin_yang = \\"☯️\\";
const wheel_of_dharma = \\"☸️\\";
const white_frowning_face = \\"☹️\\";
const relaxed = \\"☺️\\";
const female_sign = \\"♀️\\";
const male_sign = \\"♂️\\";
const gemini = \\"♊\\";
const cancer = \\"♋\\";
const leo = \\"♌\\";
const virgo = \\"♍\\";
const libra = \\"♎\\";
const scorpius = \\"♏\\";
const spades = \\"♠️\\";
const clubs = \\"♣️\\";
const hearts = \\"♥️\\";
const diamonds = \\"♦️\\";
const hotsprings = \\"♨️\\";
const recycle = \\"♻️\\";
const wheelchair = \\"♿\\";
const hammer_and_pick = \\"⚒️\\";
const crossed_swords = \\"⚔️\\";
const medical_symbol = \\"⚕️\\";
const staff_of_aesculapius = \\"⚕️\\";
const scales = \\"⚖️\\";
const alembic = \\"⚗️\\";
const gear = \\"⚙️\\";
const atom_symbol = \\"⚛️\\";
const fleur_de_lis = \\"⚜️\\";
const warning = \\"⚠️\\";
const zap = \\"⚡\\";
const white_circle = \\"⚪\\";
const black_circle = \\"⚫\\";
const coffin = \\"⚰️\\";
const funeral_urn = \\"⚱️\\";
const soccer = \\"⚽\\";
const baseball = \\"⚾\\";
const snowman_without_snow = \\"⛄\\";
const partly_sunny = \\"⛅\\";
const thunder_cloud_and_rain = \\"⛈️\\";
const ophiuchus = \\"⛎\\";
const pick = \\"⛏️\\";
const helmet_with_white_cross = \\"⛑️\\";
const chains = \\"⛓️\\";
const no_entry = \\"⛔\\";
const shinto_shrine = \\"⛩️\\";
const church = \\"⛪\\";
const mountain = \\"⛰️\\";
const umbrella_on_ground = \\"⛱️\\";
const fountain = \\"⛲\\";
const golf = \\"⛳\\";
const ferry = \\"⛴️\\";
const boat = \\"⛵\\";
const sailboat = \\"⛵\\";
const skier = \\"⛷️\\";
const ice_skate = \\"⛸️\\";
const person_with_ball = \\"⛹️‍♂️\\";
const tent = \\"⛺\\";
const fuelpump = \\"⛽\\";
const scissors = \\"✂️\\";
const airplane = \\"✈️\\";
const email = \\"✉️\\";
const envelope = \\"✉️\\";
const fist = \\"✊\\";
const hand = \\"✋\\";
const raised_hand = \\"✋\\";
const v = \\"✌️\\";
const writing_hand = \\"✍️\\";
const pencil2 = \\"✏️\\";
const black_nib = \\"✒️\\";
const heavy_check_mark = \\"✔️\\";
const heavy_multiplication_x = \\"✖️\\";
const latin_cross = \\"✝️\\";
const star_of_david = \\"✡️\\";
const eight_spoked_asterisk = \\"✳️\\";
const eight_pointed_black_star = \\"✴️\\";
const snowflake = \\"❄️\\";
const sparkle = \\"❇️\\";
const x = \\"❌\\";
const negative_squared_cross_mark = \\"❎\\";
const heavy_heart_exclamation_mark_ornament = \\"❣️\\";
const heart = \\"❤️\\";
const arrow_right = \\"➡️\\";
const curly_loop = \\"➰\\";
const loop = \\"➿\\";
const arrow_heading_up = \\"⤴️\\";
const arrow_heading_down = \\"⤵️\\";
const arrow_left = \\"⬅️\\";
const arrow_up = \\"⬆️\\";
const arrow_down = \\"⬇️\\";
const black_large_square = \\"⬛\\";
const white_large_square = \\"⬜\\";
const star = \\"⭐\\";
const o = \\"⭕\\";
const wavy_dash = \\"〰️\\";
const part_alternation_mark = \\"〽️\\";
const congratulations = \\"㊗️\\";
const secret = \\"㊙️\\";
var emoji = {
  \\"100\\": \\"💯\\",
  \\"1234\\": \\"🔢\\",
  umbrella_with_rain_drops: umbrella_with_rain_drops,
  coffee: coffee,
  aries: aries,
  taurus: taurus,
  sagittarius: sagittarius,
  capricorn: capricorn,
  aquarius: aquarius,
  pisces: pisces,
  anchor: anchor,
  white_check_mark: white_check_mark,
  sparkles: sparkles,
  question: question,
  grey_question: grey_question,
  grey_exclamation: grey_exclamation,
  exclamation: exclamation,
  heavy_exclamation_mark: heavy_exclamation_mark,
  heavy_plus_sign: heavy_plus_sign,
  heavy_minus_sign: heavy_minus_sign,
  heavy_division_sign: heavy_division_sign,
  hash: hash,
  keycap_star: keycap_star,
  zero: zero,
  one: one,
  two: two,
  three: three,
  four: four,
  five: five,
  six: six,
  seven: seven,
  eight: eight,
  nine: nine,
  copyright: copyright,
  registered: registered,
  mahjong: mahjong,
  black_joker: black_joker,
  a: a,
  b: b,
  o2: o2,
  parking: parking,
  ab: ab,
  cl: cl,
  cool: cool,
  free: free,
  id: id,
  \\"new\\": \\"🆕\\",
  ng: ng,
  ok: ok,
  sos: sos,
  up: up,
  vs: vs,
  \\"flag-ac\\": \\"🇦🇨\\",
  \\"flag-ad\\": \\"🇦🇩\\",
  \\"flag-ae\\": \\"🇦🇪\\",
  \\"flag-af\\": \\"🇦🇫\\",
  \\"flag-ag\\": \\"🇦🇬\\",
  \\"flag-ai\\": \\"🇦🇮\\",
  \\"flag-al\\": \\"🇦🇱\\",
  \\"flag-am\\": \\"🇦🇲\\",
  \\"flag-ao\\": \\"🇦🇴\\",
  \\"flag-aq\\": \\"🇦🇶\\",
  \\"flag-ar\\": \\"🇦🇷\\",
  \\"flag-as\\": \\"🇦🇸\\",
  \\"flag-at\\": \\"🇦🇹\\",
  \\"flag-au\\": \\"🇦🇺\\",
  \\"flag-aw\\": \\"🇦🇼\\",
  \\"flag-ax\\": \\"🇦🇽\\",
  \\"flag-az\\": \\"🇦🇿\\",
  \\"flag-ba\\": \\"🇧🇦\\",
  \\"flag-bb\\": \\"🇧🇧\\",
  \\"flag-bd\\": \\"🇧🇩\\",
  \\"flag-be\\": \\"🇧🇪\\",
  \\"flag-bf\\": \\"🇧🇫\\",
  \\"flag-bg\\": \\"🇧🇬\\",
  \\"flag-bh\\": \\"🇧🇭\\",
  \\"flag-bi\\": \\"🇧🇮\\",
  \\"flag-bj\\": \\"🇧🇯\\",
  \\"flag-bl\\": \\"🇧🇱\\",
  \\"flag-bm\\": \\"🇧🇲\\",
  \\"flag-bn\\": \\"🇧🇳\\",
  \\"flag-bo\\": \\"🇧🇴\\",
  \\"flag-bq\\": \\"🇧🇶\\",
  \\"flag-br\\": \\"🇧🇷\\",
  \\"flag-bs\\": \\"🇧🇸\\",
  \\"flag-bt\\": \\"🇧🇹\\",
  \\"flag-bv\\": \\"🇧🇻\\",
  \\"flag-bw\\": \\"🇧🇼\\",
  \\"flag-by\\": \\"🇧🇾\\",
  \\"flag-bz\\": \\"🇧🇿\\",
  \\"flag-ca\\": \\"🇨🇦\\",
  \\"flag-cc\\": \\"🇨🇨\\",
  \\"flag-cd\\": \\"🇨🇩\\",
  \\"flag-cf\\": \\"🇨🇫\\",
  \\"flag-cg\\": \\"🇨🇬\\",
  \\"flag-ch\\": \\"🇨🇭\\",
  \\"flag-ci\\": \\"🇨🇮\\",
  \\"flag-ck\\": \\"🇨🇰\\",
  \\"flag-cl\\": \\"🇨🇱\\",
  \\"flag-cm\\": \\"🇨🇲\\",
  cn: cn,
  \\"flag-cn\\": \\"🇨🇳\\",
  \\"flag-co\\": \\"🇨🇴\\",
  \\"flag-cp\\": \\"🇨🇵\\",
  \\"flag-cr\\": \\"🇨🇷\\",
  \\"flag-cu\\": \\"🇨🇺\\",
  \\"flag-cv\\": \\"🇨🇻\\",
  \\"flag-cw\\": \\"🇨🇼\\",
  \\"flag-cx\\": \\"🇨🇽\\",
  \\"flag-cy\\": \\"🇨🇾\\",
  \\"flag-cz\\": \\"🇨🇿\\",
  de: de,
  \\"flag-de\\": \\"🇩🇪\\",
  \\"flag-dg\\": \\"🇩🇬\\",
  \\"flag-dj\\": \\"🇩🇯\\",
  \\"flag-dk\\": \\"🇩🇰\\",
  \\"flag-dm\\": \\"🇩🇲\\",
  \\"flag-do\\": \\"🇩🇴\\",
  \\"flag-dz\\": \\"🇩🇿\\",
  \\"flag-ea\\": \\"🇪🇦\\",
  \\"flag-ec\\": \\"🇪🇨\\",
  \\"flag-ee\\": \\"🇪🇪\\",
  \\"flag-eg\\": \\"🇪🇬\\",
  \\"flag-eh\\": \\"🇪🇭\\",
  \\"flag-er\\": \\"🇪🇷\\",
  es: es,
  \\"flag-es\\": \\"🇪🇸\\",
  \\"flag-et\\": \\"🇪🇹\\",
  \\"flag-eu\\": \\"🇪🇺\\",
  \\"flag-fi\\": \\"🇫🇮\\",
  \\"flag-fj\\": \\"🇫🇯\\",
  \\"flag-fk\\": \\"🇫🇰\\",
  \\"flag-fm\\": \\"🇫🇲\\",
  \\"flag-fo\\": \\"🇫🇴\\",
  fr: fr,
  \\"flag-fr\\": \\"🇫🇷\\",
  \\"flag-ga\\": \\"🇬🇦\\",
  gb: gb,
  uk: uk,
  \\"flag-gb\\": \\"🇬🇧\\",
  \\"flag-gd\\": \\"🇬🇩\\",
  \\"flag-ge\\": \\"🇬🇪\\",
  \\"flag-gf\\": \\"🇬🇫\\",
  \\"flag-gg\\": \\"🇬🇬\\",
  \\"flag-gh\\": \\"🇬🇭\\",
  \\"flag-gi\\": \\"🇬🇮\\",
  \\"flag-gl\\": \\"🇬🇱\\",
  \\"flag-gm\\": \\"🇬🇲\\",
  \\"flag-gn\\": \\"🇬🇳\\",
  \\"flag-gp\\": \\"🇬🇵\\",
  \\"flag-gq\\": \\"🇬🇶\\",
  \\"flag-gr\\": \\"🇬🇷\\",
  \\"flag-gs\\": \\"🇬🇸\\",
  \\"flag-gt\\": \\"🇬🇹\\",
  \\"flag-gu\\": \\"🇬🇺\\",
  \\"flag-gw\\": \\"🇬🇼\\",
  \\"flag-gy\\": \\"🇬🇾\\",
  \\"flag-hk\\": \\"🇭🇰\\",
  \\"flag-hm\\": \\"🇭🇲\\",
  \\"flag-hn\\": \\"🇭🇳\\",
  \\"flag-hr\\": \\"🇭🇷\\",
  \\"flag-ht\\": \\"🇭🇹\\",
  \\"flag-hu\\": \\"🇭🇺\\",
  \\"flag-ic\\": \\"🇮🇨\\",
  \\"flag-id\\": \\"🇮🇩\\",
  \\"flag-ie\\": \\"🇮🇪\\",
  \\"flag-il\\": \\"🇮🇱\\",
  \\"flag-im\\": \\"🇮🇲\\",
  \\"flag-in\\": \\"🇮🇳\\",
  \\"flag-io\\": \\"🇮🇴\\",
  \\"flag-iq\\": \\"🇮🇶\\",
  \\"flag-ir\\": \\"🇮🇷\\",
  \\"flag-is\\": \\"🇮🇸\\",
  it: it,
  \\"flag-it\\": \\"🇮🇹\\",
  \\"flag-je\\": \\"🇯🇪\\",
  \\"flag-jm\\": \\"🇯🇲\\",
  \\"flag-jo\\": \\"🇯🇴\\",
  jp: jp,
  \\"flag-jp\\": \\"🇯🇵\\",
  \\"flag-ke\\": \\"🇰🇪\\",
  \\"flag-kg\\": \\"🇰🇬\\",
  \\"flag-kh\\": \\"🇰🇭\\",
  \\"flag-ki\\": \\"🇰🇮\\",
  \\"flag-km\\": \\"🇰🇲\\",
  \\"flag-kn\\": \\"🇰🇳\\",
  \\"flag-kp\\": \\"🇰🇵\\",
  kr: kr,
  \\"flag-kr\\": \\"🇰🇷\\",
  \\"flag-kw\\": \\"🇰🇼\\",
  \\"flag-ky\\": \\"🇰🇾\\",
  \\"flag-kz\\": \\"🇰🇿\\",
  \\"flag-la\\": \\"🇱🇦\\",
  \\"flag-lb\\": \\"🇱🇧\\",
  \\"flag-lc\\": \\"🇱🇨\\",
  \\"flag-li\\": \\"🇱🇮\\",
  \\"flag-lk\\": \\"🇱🇰\\",
  \\"flag-lr\\": \\"🇱🇷\\",
  \\"flag-ls\\": \\"🇱🇸\\",
  \\"flag-lt\\": \\"🇱🇹\\",
  \\"flag-lu\\": \\"🇱🇺\\",
  \\"flag-lv\\": \\"🇱🇻\\",
  \\"flag-ly\\": \\"🇱🇾\\",
  \\"flag-ma\\": \\"🇲🇦\\",
  \\"flag-mc\\": \\"🇲🇨\\",
  \\"flag-md\\": \\"🇲🇩\\",
  \\"flag-me\\": \\"🇲🇪\\",
  \\"flag-mf\\": \\"🇲🇫\\",
  \\"flag-mg\\": \\"🇲🇬\\",
  \\"flag-mh\\": \\"🇲🇭\\",
  \\"flag-mk\\": \\"🇲🇰\\",
  \\"flag-ml\\": \\"🇲🇱\\",
  \\"flag-mm\\": \\"🇲🇲\\",
  \\"flag-mn\\": \\"🇲🇳\\",
  \\"flag-mo\\": \\"🇲🇴\\",
  \\"flag-mp\\": \\"🇲🇵\\",
  \\"flag-mq\\": \\"🇲🇶\\",
  \\"flag-mr\\": \\"🇲🇷\\",
  \\"flag-ms\\": \\"🇲🇸\\",
  \\"flag-mt\\": \\"🇲🇹\\",
  \\"flag-mu\\": \\"🇲🇺\\",
  \\"flag-mv\\": \\"🇲🇻\\",
  \\"flag-mw\\": \\"🇲🇼\\",
  \\"flag-mx\\": \\"🇲🇽\\",
  \\"flag-my\\": \\"🇲🇾\\",
  \\"flag-mz\\": \\"🇲🇿\\",
  \\"flag-na\\": \\"🇳🇦\\",
  \\"flag-nc\\": \\"🇳🇨\\",
  \\"flag-ne\\": \\"🇳🇪\\",
  \\"flag-nf\\": \\"🇳🇫\\",
  \\"flag-ng\\": \\"🇳🇬\\",
  \\"flag-ni\\": \\"🇳🇮\\",
  \\"flag-nl\\": \\"🇳🇱\\",
  \\"flag-no\\": \\"🇳🇴\\",
  \\"flag-np\\": \\"🇳🇵\\",
  \\"flag-nr\\": \\"🇳🇷\\",
  \\"flag-nu\\": \\"🇳🇺\\",
  \\"flag-nz\\": \\"🇳🇿\\",
  \\"flag-om\\": \\"🇴🇲\\",
  \\"flag-pa\\": \\"🇵🇦\\",
  \\"flag-pe\\": \\"🇵🇪\\",
  \\"flag-pf\\": \\"🇵🇫\\",
  \\"flag-pg\\": \\"🇵🇬\\",
  \\"flag-ph\\": \\"🇵🇭\\",
  \\"flag-pk\\": \\"🇵🇰\\",
  \\"flag-pl\\": \\"🇵🇱\\",
  \\"flag-pm\\": \\"🇵🇲\\",
  \\"flag-pn\\": \\"🇵🇳\\",
  \\"flag-pr\\": \\"🇵🇷\\",
  \\"flag-ps\\": \\"🇵🇸\\",
  \\"flag-pt\\": \\"🇵🇹\\",
  \\"flag-pw\\": \\"🇵🇼\\",
  \\"flag-py\\": \\"🇵🇾\\",
  \\"flag-qa\\": \\"🇶🇦\\",
  \\"flag-re\\": \\"🇷🇪\\",
  \\"flag-ro\\": \\"🇷🇴\\",
  \\"flag-rs\\": \\"🇷🇸\\",
  ru: ru,
  \\"flag-ru\\": \\"🇷🇺\\",
  \\"flag-rw\\": \\"🇷🇼\\",
  \\"flag-sa\\": \\"🇸🇦\\",
  \\"flag-sb\\": \\"🇸🇧\\",
  \\"flag-sc\\": \\"🇸🇨\\",
  \\"flag-sd\\": \\"🇸🇩\\",
  \\"flag-se\\": \\"🇸🇪\\",
  \\"flag-sg\\": \\"🇸🇬\\",
  \\"flag-sh\\": \\"🇸🇭\\",
  \\"flag-si\\": \\"🇸🇮\\",
  \\"flag-sj\\": \\"🇸🇯\\",
  \\"flag-sk\\": \\"🇸🇰\\",
  \\"flag-sl\\": \\"🇸🇱\\",
  \\"flag-sm\\": \\"🇸🇲\\",
  \\"flag-sn\\": \\"🇸🇳\\",
  \\"flag-so\\": \\"🇸🇴\\",
  \\"flag-sr\\": \\"🇸🇷\\",
  \\"flag-ss\\": \\"🇸🇸\\",
  \\"flag-st\\": \\"🇸🇹\\",
  \\"flag-sv\\": \\"🇸🇻\\",
  \\"flag-sx\\": \\"🇸🇽\\",
  \\"flag-sy\\": \\"🇸🇾\\",
  \\"flag-sz\\": \\"🇸🇿\\",
  \\"flag-ta\\": \\"🇹🇦\\",
  \\"flag-tc\\": \\"🇹🇨\\",
  \\"flag-td\\": \\"🇹🇩\\",
  \\"flag-tf\\": \\"🇹🇫\\",
  \\"flag-tg\\": \\"🇹🇬\\",
  \\"flag-th\\": \\"🇹🇭\\",
  \\"flag-tj\\": \\"🇹🇯\\",
  \\"flag-tk\\": \\"🇹🇰\\",
  \\"flag-tl\\": \\"🇹🇱\\",
  \\"flag-tm\\": \\"🇹🇲\\",
  \\"flag-tn\\": \\"🇹🇳\\",
  \\"flag-to\\": \\"🇹🇴\\",
  \\"flag-tr\\": \\"🇹🇷\\",
  \\"flag-tt\\": \\"🇹🇹\\",
  \\"flag-tv\\": \\"🇹🇻\\",
  \\"flag-tw\\": \\"🇹🇼\\",
  \\"flag-tz\\": \\"🇹🇿\\",
  \\"flag-ua\\": \\"🇺🇦\\",
  \\"flag-ug\\": \\"🇺🇬\\",
  \\"flag-um\\": \\"🇺🇲\\",
  \\"flag-un\\": \\"🇺🇳\\",
  us: us,
  \\"flag-us\\": \\"🇺🇸\\",
  \\"flag-uy\\": \\"🇺🇾\\",
  \\"flag-uz\\": \\"🇺🇿\\",
  \\"flag-va\\": \\"🇻🇦\\",
  \\"flag-vc\\": \\"🇻🇨\\",
  \\"flag-ve\\": \\"🇻🇪\\",
  \\"flag-vg\\": \\"🇻🇬\\",
  \\"flag-vi\\": \\"🇻🇮\\",
  \\"flag-vn\\": \\"🇻🇳\\",
  \\"flag-vu\\": \\"🇻🇺\\",
  \\"flag-wf\\": \\"🇼🇫\\",
  \\"flag-ws\\": \\"🇼🇸\\",
  \\"flag-xk\\": \\"🇽🇰\\",
  \\"flag-ye\\": \\"🇾🇪\\",
  \\"flag-yt\\": \\"🇾🇹\\",
  \\"flag-za\\": \\"🇿🇦\\",
  \\"flag-zm\\": \\"🇿🇲\\",
  \\"flag-zw\\": \\"🇿🇼\\",
  koko: koko,
  sa: sa,
  u7121: u7121,
  u6307: u6307,
  u7981: u7981,
  u7a7a: u7a7a,
  u5408: u5408,
  u6e80: u6e80,
  u6709: u6709,
  u6708: u6708,
  u7533: u7533,
  u5272: u5272,
  u55b6: u55b6,
  ideograph_advantage: ideograph_advantage,
  accept: accept,
  cyclone: cyclone,
  foggy: foggy,
  closed_umbrella: closed_umbrella,
  night_with_stars: night_with_stars,
  sunrise_over_mountains: sunrise_over_mountains,
  sunrise: sunrise,
  city_sunset: city_sunset,
  city_sunrise: city_sunrise,
  rainbow: rainbow,
  bridge_at_night: bridge_at_night,
  ocean: ocean,
  volcano: volcano,
  milky_way: milky_way,
  earth_africa: earth_africa,
  earth_americas: earth_americas,
  earth_asia: earth_asia,
  globe_with_meridians: globe_with_meridians,
  new_moon: new_moon,
  waxing_crescent_moon: waxing_crescent_moon,
  first_quarter_moon: first_quarter_moon,
  moon: moon,
  waxing_gibbous_moon: waxing_gibbous_moon,
  full_moon: full_moon,
  waning_gibbous_moon: waning_gibbous_moon,
  last_quarter_moon: last_quarter_moon,
  waning_crescent_moon: waning_crescent_moon,
  crescent_moon: crescent_moon,
  new_moon_with_face: new_moon_with_face,
  first_quarter_moon_with_face: first_quarter_moon_with_face,
  last_quarter_moon_with_face: last_quarter_moon_with_face,
  full_moon_with_face: full_moon_with_face,
  sun_with_face: sun_with_face,
  star2: star2,
  stars: stars,
  thermometer: thermometer,
  mostly_sunny: mostly_sunny,
  sun_small_cloud: sun_small_cloud,
  barely_sunny: barely_sunny,
  sun_behind_cloud: sun_behind_cloud,
  partly_sunny_rain: partly_sunny_rain,
  sun_behind_rain_cloud: sun_behind_rain_cloud,
  rain_cloud: rain_cloud,
  snow_cloud: snow_cloud,
  lightning: lightning,
  lightning_cloud: lightning_cloud,
  tornado: tornado,
  tornado_cloud: tornado_cloud,
  fog: fog,
  wind_blowing_face: wind_blowing_face,
  hotdog: hotdog,
  taco: taco,
  burrito: burrito,
  chestnut: chestnut,
  seedling: seedling,
  evergreen_tree: evergreen_tree,
  deciduous_tree: deciduous_tree,
  palm_tree: palm_tree,
  cactus: cactus,
  hot_pepper: hot_pepper,
  tulip: tulip,
  cherry_blossom: cherry_blossom,
  rose: rose,
  hibiscus: hibiscus,
  sunflower: sunflower,
  blossom: blossom,
  corn: corn,
  ear_of_rice: ear_of_rice,
  herb: herb,
  four_leaf_clover: four_leaf_clover,
  maple_leaf: maple_leaf,
  fallen_leaf: fallen_leaf,
  leaves: leaves,
  mushroom: mushroom,
  tomato: tomato,
  eggplant: eggplant,
  grapes: grapes,
  melon: melon,
  watermelon: watermelon,
  tangerine: tangerine,
  lemon: lemon,
  banana: banana,
  pineapple: pineapple,
  apple: apple,
  green_apple: green_apple,
  pear: pear,
  peach: peach,
  cherries: cherries,
  strawberry: strawberry,
  hamburger: hamburger,
  pizza: pizza,
  meat_on_bone: meat_on_bone,
  poultry_leg: poultry_leg,
  rice_cracker: rice_cracker,
  rice_ball: rice_ball,
  rice: rice,
  curry: curry,
  ramen: ramen,
  spaghetti: spaghetti,
  bread: bread,
  fries: fries,
  sweet_potato: sweet_potato,
  dango: dango,
  oden: oden,
  sushi: sushi,
  fried_shrimp: fried_shrimp,
  fish_cake: fish_cake,
  icecream: icecream,
  shaved_ice: shaved_ice,
  ice_cream: ice_cream,
  doughnut: doughnut,
  cookie: cookie,
  chocolate_bar: chocolate_bar,
  candy: candy,
  lollipop: lollipop,
  custard: custard,
  honey_pot: honey_pot,
  cake: cake,
  bento: bento,
  stew: stew,
  fried_egg: fried_egg,
  cooking: cooking,
  fork_and_knife: fork_and_knife,
  tea: tea,
  sake: sake,
  wine_glass: wine_glass,
  cocktail: cocktail,
  tropical_drink: tropical_drink,
  beer: beer,
  beers: beers,
  baby_bottle: baby_bottle,
  knife_fork_plate: knife_fork_plate,
  champagne: champagne,
  popcorn: popcorn,
  ribbon: ribbon,
  gift: gift,
  birthday: birthday,
  jack_o_lantern: jack_o_lantern,
  christmas_tree: christmas_tree,
  santa: santa,
  fireworks: fireworks,
  sparkler: sparkler,
  balloon: balloon,
  tada: tada,
  confetti_ball: confetti_ball,
  tanabata_tree: tanabata_tree,
  crossed_flags: crossed_flags,
  bamboo: bamboo,
  dolls: dolls,
  flags: flags,
  wind_chime: wind_chime,
  rice_scene: rice_scene,
  school_satchel: school_satchel,
  mortar_board: mortar_board,
  medal: medal,
  reminder_ribbon: reminder_ribbon,
  studio_microphone: studio_microphone,
  level_slider: level_slider,
  control_knobs: control_knobs,
  film_frames: film_frames,
  admission_tickets: admission_tickets,
  carousel_horse: carousel_horse,
  ferris_wheel: ferris_wheel,
  roller_coaster: roller_coaster,
  fishing_pole_and_fish: fishing_pole_and_fish,
  microphone: microphone,
  movie_camera: movie_camera,
  cinema: cinema,
  headphones: headphones,
  art: art,
  tophat: tophat,
  circus_tent: circus_tent,
  ticket: ticket,
  clapper: clapper,
  performing_arts: performing_arts,
  video_game: video_game,
  dart: dart,
  slot_machine: slot_machine,
  \\"8ball\\": \\"🎱\\",
  game_die: game_die,
  bowling: bowling,
  flower_playing_cards: flower_playing_cards,
  musical_note: musical_note,
  notes: notes,
  saxophone: saxophone,
  guitar: guitar,
  musical_keyboard: musical_keyboard,
  trumpet: trumpet,
  violin: violin,
  musical_score: musical_score,
  running_shirt_with_sash: running_shirt_with_sash,
  tennis: tennis,
  ski: ski,
  basketball: basketball,
  checkered_flag: checkered_flag,
  snowboarder: snowboarder,
  \\"woman-running\\": \\"🏃‍♀️\\",
  \\"man-running\\": \\"🏃‍♂️\\",
  runner: runner,
  running: running,
  \\"woman-surfing\\": \\"🏄‍♀️\\",
  \\"man-surfing\\": \\"🏄‍♂️\\",
  surfer: surfer,
  sports_medal: sports_medal,
  trophy: trophy,
  horse_racing: horse_racing,
  football: football,
  rugby_football: rugby_football,
  \\"woman-swimming\\": \\"🏊‍♀️\\",
  \\"man-swimming\\": \\"🏊‍♂️\\",
  swimmer: swimmer,
  \\"woman-lifting-weights\\": \\"🏋️‍♀️\\",
  \\"man-lifting-weights\\": \\"🏋️‍♂️\\",
  weight_lifter: weight_lifter,
  \\"woman-golfing\\": \\"🏌️‍♀️\\",
  \\"man-golfing\\": \\"🏌️‍♂️\\",
  golfer: golfer,
  racing_motorcycle: racing_motorcycle,
  racing_car: racing_car,
  cricket_bat_and_ball: cricket_bat_and_ball,
  volleyball: volleyball,
  field_hockey_stick_and_ball: field_hockey_stick_and_ball,
  ice_hockey_stick_and_puck: ice_hockey_stick_and_puck,
  table_tennis_paddle_and_ball: table_tennis_paddle_and_ball,
  snow_capped_mountain: snow_capped_mountain,
  camping: camping,
  beach_with_umbrella: beach_with_umbrella,
  building_construction: building_construction,
  house_buildings: house_buildings,
  cityscape: cityscape,
  derelict_house_building: derelict_house_building,
  classical_building: classical_building,
  desert: desert,
  desert_island: desert_island,
  national_park: national_park,
  stadium: stadium,
  house: house,
  house_with_garden: house_with_garden,
  office: office,
  post_office: post_office,
  european_post_office: european_post_office,
  hospital: hospital,
  bank: bank,
  atm: atm,
  hotel: hotel,
  love_hotel: love_hotel,
  convenience_store: convenience_store,
  school: school,
  department_store: department_store,
  factory: factory,
  izakaya_lantern: izakaya_lantern,
  lantern: lantern,
  japanese_castle: japanese_castle,
  european_castle: european_castle,
  \\"rainbow-flag\\": \\"🏳️‍🌈\\",
  waving_white_flag: waving_white_flag,
  \\"flag-england\\": \\"🏴󠁧󠁢󠁥󠁮󠁧󠁿\\",
  \\"flag-scotland\\": \\"🏴󠁧󠁢󠁳󠁣󠁴󠁿\\",
  \\"flag-wales\\": \\"🏴󠁧󠁢󠁷󠁬󠁳󠁿\\",
  waving_black_flag: waving_black_flag,
  rosette: rosette,
  label: label,
  badminton_racquet_and_shuttlecock: badminton_racquet_and_shuttlecock,
  bow_and_arrow: bow_and_arrow,
  amphora: amphora,
  \\"skin-tone-2\\": \\"🏻\\",
  \\"skin-tone-3\\": \\"🏼\\",
  \\"skin-tone-4\\": \\"🏽\\",
  \\"skin-tone-5\\": \\"🏾\\",
  \\"skin-tone-6\\": \\"🏿\\",
  rat: rat,
  mouse2: mouse2,
  ox: ox,
  water_buffalo: water_buffalo,
  cow2: cow2,
  tiger2: tiger2,
  leopard: leopard,
  rabbit2: rabbit2,
  cat2: cat2,
  dragon: dragon,
  crocodile: crocodile,
  whale2: whale2,
  snail: snail,
  snake: snake,
  racehorse: racehorse,
  ram: ram,
  goat: goat,
  sheep: sheep,
  monkey: monkey,
  rooster: rooster,
  chicken: chicken,
  dog2: dog2,
  pig2: pig2,
  boar: boar,
  elephant: elephant,
  octopus: octopus,
  shell: shell,
  bug: bug,
  ant: ant,
  bee: bee,
  honeybee: honeybee,
  beetle: beetle,
  fish: fish,
  tropical_fish: tropical_fish,
  blowfish: blowfish,
  turtle: turtle,
  hatching_chick: hatching_chick,
  baby_chick: baby_chick,
  hatched_chick: hatched_chick,
  bird: bird,
  penguin: penguin,
  koala: koala,
  poodle: poodle,
  dromedary_camel: dromedary_camel,
  camel: camel,
  dolphin: dolphin,
  flipper: flipper,
  mouse: mouse,
  cow: cow,
  tiger: tiger,
  rabbit: rabbit,
  cat: cat,
  dragon_face: dragon_face,
  whale: whale,
  horse: horse,
  monkey_face: monkey_face,
  dog: dog,
  pig: pig,
  frog: frog,
  hamster: hamster,
  wolf: wolf,
  bear: bear,
  panda_face: panda_face,
  pig_nose: pig_nose,
  feet: feet,
  paw_prints: paw_prints,
  chipmunk: chipmunk,
  eyes: eyes,
  \\"eye-in-speech-bubble\\": \\"👁️‍🗨️\\",
  eye: eye,
  ear: ear,
  nose: nose,
  lips: lips,
  tongue: tongue,
  point_up_2: point_up_2,
  point_down: point_down,
  point_left: point_left,
  point_right: point_right,
  facepunch: facepunch,
  punch: punch,
  wave: wave,
  ok_hand: ok_hand,
  \\"+1\\": \\"👍\\",
  thumbsup: thumbsup,
  \\"-1\\": \\"👎\\",
  thumbsdown: thumbsdown,
  clap: clap,
  open_hands: open_hands,
  crown: crown,
  womans_hat: womans_hat,
  eyeglasses: eyeglasses,
  necktie: necktie,
  shirt: shirt,
  tshirt: tshirt,
  jeans: jeans,
  dress: dress,
  kimono: kimono,
  bikini: bikini,
  womans_clothes: womans_clothes,
  purse: purse,
  handbag: handbag,
  pouch: pouch,
  mans_shoe: mans_shoe,
  shoe: shoe,
  athletic_shoe: athletic_shoe,
  high_heel: high_heel,
  sandal: sandal,
  boot: boot,
  footprints: footprints,
  bust_in_silhouette: bust_in_silhouette,
  busts_in_silhouette: busts_in_silhouette,
  boy: boy,
  girl: girl,
  \\"male-farmer\\": \\"👨‍🌾\\",
  \\"male-cook\\": \\"👨‍🍳\\",
  \\"male-student\\": \\"👨‍🎓\\",
  \\"male-singer\\": \\"👨‍🎤\\",
  \\"male-artist\\": \\"👨‍🎨\\",
  \\"male-teacher\\": \\"👨‍🏫\\",
  \\"male-factory-worker\\": \\"👨‍🏭\\",
  \\"man-boy-boy\\": \\"👨‍👦‍👦\\",
  \\"man-boy\\": \\"👨‍👦\\",
  \\"man-girl-boy\\": \\"👨‍👧‍👦\\",
  \\"man-girl-girl\\": \\"👨‍👧‍👧\\",
  \\"man-girl\\": \\"👨‍👧\\",
  \\"man-man-boy\\": \\"👨‍👨‍👦\\",
  \\"man-man-boy-boy\\": \\"👨‍👨‍👦‍👦\\",
  \\"man-man-girl\\": \\"👨‍👨‍👧\\",
  \\"man-man-girl-boy\\": \\"👨‍👨‍👧‍👦\\",
  \\"man-man-girl-girl\\": \\"👨‍👨‍👧‍👧\\",
  \\"man-woman-boy\\": \\"👨‍👩‍👦\\",
  family: family,
  \\"man-woman-boy-boy\\": \\"👨‍👩‍👦‍👦\\",
  \\"man-woman-girl\\": \\"👨‍👩‍👧\\",
  \\"man-woman-girl-boy\\": \\"👨‍👩‍👧‍👦\\",
  \\"man-woman-girl-girl\\": \\"👨‍👩‍👧‍👧\\",
  \\"male-technologist\\": \\"👨‍💻\\",
  \\"male-office-worker\\": \\"👨‍💼\\",
  \\"male-mechanic\\": \\"👨‍🔧\\",
  \\"male-scientist\\": \\"👨‍🔬\\",
  \\"male-astronaut\\": \\"👨‍🚀\\",
  \\"male-firefighter\\": \\"👨‍🚒\\",
  \\"male-doctor\\": \\"👨‍⚕️\\",
  \\"male-judge\\": \\"👨‍⚖️\\",
  \\"male-pilot\\": \\"👨‍✈️\\",
  \\"man-heart-man\\": \\"👨‍❤️‍👨\\",
  \\"man-kiss-man\\": \\"👨‍❤️‍💋‍👨\\",
  man: man,
  \\"female-farmer\\": \\"👩‍🌾\\",
  \\"female-cook\\": \\"👩‍🍳\\",
  \\"female-student\\": \\"👩‍🎓\\",
  \\"female-singer\\": \\"👩‍🎤\\",
  \\"female-artist\\": \\"👩‍🎨\\",
  \\"female-teacher\\": \\"👩‍🏫\\",
  \\"female-factory-worker\\": \\"👩‍🏭\\",
  \\"woman-boy-boy\\": \\"👩‍👦‍👦\\",
  \\"woman-boy\\": \\"👩‍👦\\",
  \\"woman-girl-boy\\": \\"👩‍👧‍👦\\",
  \\"woman-girl-girl\\": \\"👩‍👧‍👧\\",
  \\"woman-girl\\": \\"👩‍👧\\",
  \\"woman-woman-boy\\": \\"👩‍👩‍👦\\",
  \\"woman-woman-boy-boy\\": \\"👩‍👩‍👦‍👦\\",
  \\"woman-woman-girl\\": \\"👩‍👩‍👧\\",
  \\"woman-woman-girl-boy\\": \\"👩‍👩‍👧‍👦\\",
  \\"woman-woman-girl-girl\\": \\"👩‍👩‍👧‍👧\\",
  \\"female-technologist\\": \\"👩‍💻\\",
  \\"female-office-worker\\": \\"👩‍💼\\",
  \\"female-mechanic\\": \\"👩‍🔧\\",
  \\"female-scientist\\": \\"👩‍🔬\\",
  \\"female-astronaut\\": \\"👩‍🚀\\",
  \\"female-firefighter\\": \\"👩‍🚒\\",
  \\"female-doctor\\": \\"👩‍⚕️\\",
  \\"female-judge\\": \\"👩‍⚖️\\",
  \\"female-pilot\\": \\"👩‍✈️\\",
  \\"woman-heart-man\\": \\"👩‍❤️‍👨\\",
  couple_with_heart: couple_with_heart,
  \\"woman-heart-woman\\": \\"👩‍❤️‍👩\\",
  \\"woman-kiss-man\\": \\"👩‍❤️‍💋‍👨\\",
  couplekiss: couplekiss,
  \\"woman-kiss-woman\\": \\"👩‍❤️‍💋‍👩\\",
  woman: woman,
  couple: couple,
  man_and_woman_holding_hands: man_and_woman_holding_hands,
  two_men_holding_hands: two_men_holding_hands,
  two_women_holding_hands: two_women_holding_hands,
  \\"female-police-officer\\": \\"👮‍♀️\\",
  \\"male-police-officer\\": \\"👮‍♂️\\",
  cop: cop,
  \\"woman-with-bunny-ears-partying\\": \\"👯‍♀️\\",
  dancers: dancers,
  \\"man-with-bunny-ears-partying\\": \\"👯‍♂️\\",
  bride_with_veil: bride_with_veil,
  \\"blond-haired-woman\\": \\"👱‍♀️\\",
  \\"blond-haired-man\\": \\"👱‍♂️\\",
  person_with_blond_hair: person_with_blond_hair,
  man_with_gua_pi_mao: man_with_gua_pi_mao,
  \\"woman-wearing-turban\\": \\"👳‍♀️\\",
  \\"man-wearing-turban\\": \\"👳‍♂️\\",
  man_with_turban: man_with_turban,
  older_man: older_man,
  older_woman: older_woman,
  baby: baby,
  \\"female-construction-worker\\": \\"👷‍♀️\\",
  \\"male-construction-worker\\": \\"👷‍♂️\\",
  construction_worker: construction_worker,
  princess: princess,
  japanese_ogre: japanese_ogre,
  japanese_goblin: japanese_goblin,
  ghost: ghost,
  angel: angel,
  alien: alien,
  space_invader: space_invader,
  imp: imp,
  skull: skull,
  \\"woman-tipping-hand\\": \\"💁‍♀️\\",
  information_desk_person: information_desk_person,
  \\"man-tipping-hand\\": \\"💁‍♂️\\",
  \\"female-guard\\": \\"💂‍♀️\\",
  \\"male-guard\\": \\"💂‍♂️\\",
  guardsman: guardsman,
  dancer: dancer,
  lipstick: lipstick,
  nail_care: nail_care,
  \\"woman-getting-massage\\": \\"💆‍♀️\\",
  massage: massage,
  \\"man-getting-massage\\": \\"💆‍♂️\\",
  \\"woman-getting-haircut\\": \\"💇‍♀️\\",
  haircut: haircut,
  \\"man-getting-haircut\\": \\"💇‍♂️\\",
  barber: barber,
  syringe: syringe,
  pill: pill,
  kiss: kiss,
  love_letter: love_letter,
  ring: ring,
  gem: gem,
  bouquet: bouquet,
  wedding: wedding,
  heartbeat: heartbeat,
  broken_heart: broken_heart,
  two_hearts: two_hearts,
  sparkling_heart: sparkling_heart,
  heartpulse: heartpulse,
  cupid: cupid,
  blue_heart: blue_heart,
  green_heart: green_heart,
  yellow_heart: yellow_heart,
  purple_heart: purple_heart,
  gift_heart: gift_heart,
  revolving_hearts: revolving_hearts,
  heart_decoration: heart_decoration,
  diamond_shape_with_a_dot_inside: diamond_shape_with_a_dot_inside,
  bulb: bulb,
  anger: anger,
  bomb: bomb,
  zzz: zzz,
  boom: boom,
  collision: collision,
  sweat_drops: sweat_drops,
  droplet: droplet,
  dash: dash,
  hankey: hankey,
  poop: poop,
  shit: shit,
  muscle: muscle,
  dizzy: dizzy,
  speech_balloon: speech_balloon,
  thought_balloon: thought_balloon,
  white_flower: white_flower,
  moneybag: moneybag,
  currency_exchange: currency_exchange,
  heavy_dollar_sign: heavy_dollar_sign,
  credit_card: credit_card,
  yen: yen,
  dollar: dollar,
  euro: euro,
  pound: pound,
  money_with_wings: money_with_wings,
  chart: chart,
  seat: seat,
  computer: computer,
  briefcase: briefcase,
  minidisc: minidisc,
  floppy_disk: floppy_disk,
  cd: cd,
  dvd: dvd,
  file_folder: file_folder,
  open_file_folder: open_file_folder,
  page_with_curl: page_with_curl,
  page_facing_up: page_facing_up,
  date: date,
  calendar: calendar,
  card_index: card_index,
  chart_with_upwards_trend: chart_with_upwards_trend,
  chart_with_downwards_trend: chart_with_downwards_trend,
  bar_chart: bar_chart,
  clipboard: clipboard,
  pushpin: pushpin,
  round_pushpin: round_pushpin,
  paperclip: paperclip,
  straight_ruler: straight_ruler,
  triangular_ruler: triangular_ruler,
  bookmark_tabs: bookmark_tabs,
  ledger: ledger,
  notebook: notebook,
  notebook_with_decorative_cover: notebook_with_decorative_cover,
  closed_book: closed_book,
  book: book,
  open_book: open_book,
  green_book: green_book,
  blue_book: blue_book,
  orange_book: orange_book,
  books: books,
  name_badge: name_badge,
  scroll: scroll,
  memo: memo,
  pencil: pencil,
  telephone_receiver: telephone_receiver,
  pager: pager,
  fax: fax,
  satellite_antenna: satellite_antenna,
  loudspeaker: loudspeaker,
  mega: mega,
  outbox_tray: outbox_tray,
  inbox_tray: inbox_tray,
  \\"package\\": \\"📦\\",
  \\"e-mail\\": \\"📧\\",
  incoming_envelope: incoming_envelope,
  envelope_with_arrow: envelope_with_arrow,
  mailbox_closed: mailbox_closed,
  mailbox: mailbox,
  mailbox_with_mail: mailbox_with_mail,
  mailbox_with_no_mail: mailbox_with_no_mail,
  postbox: postbox,
  postal_horn: postal_horn,
  newspaper: newspaper,
  iphone: iphone,
  calling: calling,
  vibration_mode: vibration_mode,
  mobile_phone_off: mobile_phone_off,
  no_mobile_phones: no_mobile_phones,
  signal_strength: signal_strength,
  camera: camera,
  camera_with_flash: camera_with_flash,
  video_camera: video_camera,
  tv: tv,
  radio: radio,
  vhs: vhs,
  film_projector: film_projector,
  prayer_beads: prayer_beads,
  twisted_rightwards_arrows: twisted_rightwards_arrows,
  repeat: repeat,
  repeat_one: repeat_one,
  arrows_clockwise: arrows_clockwise,
  arrows_counterclockwise: arrows_counterclockwise,
  low_brightness: low_brightness,
  high_brightness: high_brightness,
  mute: mute,
  speaker: speaker,
  sound: sound,
  loud_sound: loud_sound,
  battery: battery,
  electric_plug: electric_plug,
  mag: mag,
  mag_right: mag_right,
  lock_with_ink_pen: lock_with_ink_pen,
  closed_lock_with_key: closed_lock_with_key,
  key: key,
  lock: lock,
  unlock: unlock,
  bell: bell,
  no_bell: no_bell,
  bookmark: bookmark,
  link: link$1,
  radio_button: radio_button,
  back: back,
  end: end,
  on: on,
  soon: soon,
  top: top,
  underage: underage,
  keycap_ten: keycap_ten,
  capital_abcd: capital_abcd,
  abcd: abcd,
  symbols: symbols,
  abc: abc,
  fire: fire,
  flashlight: flashlight,
  wrench: wrench,
  hammer: hammer,
  nut_and_bolt: nut_and_bolt,
  hocho: hocho,
  knife: knife,
  gun: gun,
  microscope: microscope,
  telescope: telescope,
  crystal_ball: crystal_ball,
  six_pointed_star: six_pointed_star,
  beginner: beginner,
  trident: trident,
  black_square_button: black_square_button,
  white_square_button: white_square_button,
  red_circle: red_circle,
  large_blue_circle: large_blue_circle,
  large_orange_diamond: large_orange_diamond,
  large_blue_diamond: large_blue_diamond,
  small_orange_diamond: small_orange_diamond,
  small_blue_diamond: small_blue_diamond,
  small_red_triangle: small_red_triangle,
  small_red_triangle_down: small_red_triangle_down,
  arrow_up_small: arrow_up_small,
  arrow_down_small: arrow_down_small,
  om_symbol: om_symbol,
  dove_of_peace: dove_of_peace,
  kaaba: kaaba,
  mosque: mosque,
  synagogue: synagogue,
  menorah_with_nine_branches: menorah_with_nine_branches,
  clock1: clock1,
  clock2: clock2,
  clock3: clock3,
  clock4: clock4,
  clock5: clock5,
  clock6: clock6,
  clock7: clock7,
  clock8: clock8,
  clock9: clock9,
  clock10: clock10,
  clock11: clock11,
  clock12: clock12,
  clock130: clock130,
  clock230: clock230,
  clock330: clock330,
  clock430: clock430,
  clock530: clock530,
  clock630: clock630,
  clock730: clock730,
  clock830: clock830,
  clock930: clock930,
  clock1030: clock1030,
  clock1130: clock1130,
  clock1230: clock1230,
  candle: candle,
  mantelpiece_clock: mantelpiece_clock,
  hole: hole,
  man_in_business_suit_levitating: man_in_business_suit_levitating,
  \\"female-detective\\": \\"🕵️‍♀️\\",
  \\"male-detective\\": \\"🕵️‍♂️\\",
  sleuth_or_spy: sleuth_or_spy,
  dark_sunglasses: dark_sunglasses,
  spider: spider,
  spider_web: spider_web,
  joystick: joystick,
  man_dancing: man_dancing,
  linked_paperclips: linked_paperclips,
  lower_left_ballpoint_pen: lower_left_ballpoint_pen,
  lower_left_fountain_pen: lower_left_fountain_pen,
  lower_left_paintbrush: lower_left_paintbrush,
  lower_left_crayon: lower_left_crayon,
  raised_hand_with_fingers_splayed: raised_hand_with_fingers_splayed,
  middle_finger: middle_finger,
  reversed_hand_with_middle_finger_extended: reversed_hand_with_middle_finger_extended,
  \\"spock-hand\\": \\"🖖\\",
  black_heart: black_heart,
  desktop_computer: desktop_computer,
  printer: printer,
  three_button_mouse: three_button_mouse,
  trackball: trackball,
  frame_with_picture: frame_with_picture,
  card_index_dividers: card_index_dividers,
  card_file_box: card_file_box,
  file_cabinet: file_cabinet,
  wastebasket: wastebasket,
  spiral_note_pad: spiral_note_pad,
  spiral_calendar_pad: spiral_calendar_pad,
  compression: compression,
  old_key: old_key,
  rolled_up_newspaper: rolled_up_newspaper,
  dagger_knife: dagger_knife,
  speaking_head_in_silhouette: speaking_head_in_silhouette,
  left_speech_bubble: left_speech_bubble,
  right_anger_bubble: right_anger_bubble,
  ballot_box_with_ballot: ballot_box_with_ballot,
  world_map: world_map,
  mount_fuji: mount_fuji,
  tokyo_tower: tokyo_tower,
  statue_of_liberty: statue_of_liberty,
  japan: japan,
  moyai: moyai,
  grinning: grinning,
  grin: grin,
  joy: joy,
  smiley: smiley,
  smile: smile,
  sweat_smile: sweat_smile,
  laughing: laughing,
  satisfied: satisfied,
  innocent: innocent,
  smiling_imp: smiling_imp,
  wink: wink,
  blush: blush,
  yum: yum,
  relieved: relieved,
  heart_eyes: heart_eyes,
  sunglasses: sunglasses,
  smirk: smirk,
  neutral_face: neutral_face,
  expressionless: expressionless,
  unamused: unamused,
  sweat: sweat,
  pensive: pensive,
  confused: confused,
  confounded: confounded,
  kissing: kissing,
  kissing_heart: kissing_heart,
  kissing_smiling_eyes: kissing_smiling_eyes,
  kissing_closed_eyes: kissing_closed_eyes,
  stuck_out_tongue: stuck_out_tongue,
  stuck_out_tongue_winking_eye: stuck_out_tongue_winking_eye,
  stuck_out_tongue_closed_eyes: stuck_out_tongue_closed_eyes,
  disappointed: disappointed,
  worried: worried,
  angry: angry,
  rage: rage,
  cry: cry,
  persevere: persevere,
  triumph: triumph,
  disappointed_relieved: disappointed_relieved,
  frowning: frowning,
  anguished: anguished,
  fearful: fearful,
  weary: weary,
  sleepy: sleepy,
  tired_face: tired_face,
  grimacing: grimacing,
  sob: sob,
  open_mouth: open_mouth,
  hushed: hushed,
  cold_sweat: cold_sweat,
  scream: scream,
  astonished: astonished,
  flushed: flushed,
  sleeping: sleeping,
  dizzy_face: dizzy_face,
  no_mouth: no_mouth,
  mask: mask,
  smile_cat: smile_cat,
  joy_cat: joy_cat,
  smiley_cat: smiley_cat,
  heart_eyes_cat: heart_eyes_cat,
  smirk_cat: smirk_cat,
  kissing_cat: kissing_cat,
  pouting_cat: pouting_cat,
  crying_cat_face: crying_cat_face,
  scream_cat: scream_cat,
  slightly_frowning_face: slightly_frowning_face,
  slightly_smiling_face: slightly_smiling_face,
  upside_down_face: upside_down_face,
  face_with_rolling_eyes: face_with_rolling_eyes,
  \\"woman-gesturing-no\\": \\"🙅‍♀️\\",
  no_good: no_good,
  \\"man-gesturing-no\\": \\"🙅‍♂️\\",
  \\"woman-gesturing-ok\\": \\"🙆‍♀️\\",
  ok_woman: ok_woman,
  \\"man-gesturing-ok\\": \\"🙆‍♂️\\",
  \\"woman-bowing\\": \\"🙇‍♀️\\",
  \\"man-bowing\\": \\"🙇‍♂️\\",
  bow: bow,
  see_no_evil: see_no_evil,
  hear_no_evil: hear_no_evil,
  speak_no_evil: speak_no_evil,
  \\"woman-raising-hand\\": \\"🙋‍♀️\\",
  raising_hand: raising_hand,
  \\"man-raising-hand\\": \\"🙋‍♂️\\",
  raised_hands: raised_hands,
  \\"woman-frowning\\": \\"🙍‍♀️\\",
  person_frowning: person_frowning,
  \\"man-frowning\\": \\"🙍‍♂️\\",
  \\"woman-pouting\\": \\"🙎‍♀️\\",
  person_with_pouting_face: person_with_pouting_face,
  \\"man-pouting\\": \\"🙎‍♂️\\",
  pray: pray,
  rocket: rocket,
  helicopter: helicopter,
  steam_locomotive: steam_locomotive,
  railway_car: railway_car,
  bullettrain_side: bullettrain_side,
  bullettrain_front: bullettrain_front,
  train2: train2,
  metro: metro,
  light_rail: light_rail,
  station: station,
  tram: tram,
  train: train,
  bus: bus,
  oncoming_bus: oncoming_bus,
  trolleybus: trolleybus,
  busstop: busstop,
  minibus: minibus,
  ambulance: ambulance,
  fire_engine: fire_engine,
  police_car: police_car,
  oncoming_police_car: oncoming_police_car,
  taxi: taxi,
  oncoming_taxi: oncoming_taxi,
  car: car,
  red_car: red_car,
  oncoming_automobile: oncoming_automobile,
  blue_car: blue_car,
  truck: truck,
  articulated_lorry: articulated_lorry,
  tractor: tractor,
  monorail: monorail,
  mountain_railway: mountain_railway,
  suspension_railway: suspension_railway,
  mountain_cableway: mountain_cableway,
  aerial_tramway: aerial_tramway,
  ship: ship,
  \\"woman-rowing-boat\\": \\"🚣‍♀️\\",
  \\"man-rowing-boat\\": \\"🚣‍♂️\\",
  rowboat: rowboat,
  speedboat: speedboat,
  traffic_light: traffic_light,
  vertical_traffic_light: vertical_traffic_light,
  construction: construction,
  rotating_light: rotating_light,
  triangular_flag_on_post: triangular_flag_on_post,
  door: door,
  no_entry_sign: no_entry_sign,
  smoking: smoking,
  no_smoking: no_smoking,
  put_litter_in_its_place: put_litter_in_its_place,
  do_not_litter: do_not_litter,
  potable_water: potable_water,
  \\"non-potable_water\\": \\"🚱\\",
  bike: bike,
  no_bicycles: no_bicycles,
  \\"woman-biking\\": \\"🚴‍♀️\\",
  \\"man-biking\\": \\"🚴‍♂️\\",
  bicyclist: bicyclist,
  \\"woman-mountain-biking\\": \\"🚵‍♀️\\",
  \\"man-mountain-biking\\": \\"🚵‍♂️\\",
  mountain_bicyclist: mountain_bicyclist,
  \\"woman-walking\\": \\"🚶‍♀️\\",
  \\"man-walking\\": \\"🚶‍♂️\\",
  walking: walking,
  no_pedestrians: no_pedestrians,
  children_crossing: children_crossing,
  mens: mens,
  womens: womens,
  restroom: restroom,
  baby_symbol: baby_symbol,
  toilet: toilet,
  wc: wc,
  shower: shower,
  bath: bath,
  bathtub: bathtub,
  passport_control: passport_control,
  customs: customs,
  baggage_claim: baggage_claim,
  left_luggage: left_luggage,
  couch_and_lamp: couch_and_lamp,
  sleeping_accommodation: sleeping_accommodation,
  shopping_bags: shopping_bags,
  bellhop_bell: bellhop_bell,
  bed: bed,
  place_of_worship: place_of_worship,
  octagonal_sign: octagonal_sign,
  shopping_trolley: shopping_trolley,
  hammer_and_wrench: hammer_and_wrench,
  shield: shield,
  oil_drum: oil_drum,
  motorway: motorway,
  railway_track: railway_track,
  motor_boat: motor_boat,
  small_airplane: small_airplane,
  airplane_departure: airplane_departure,
  airplane_arriving: airplane_arriving,
  satellite: satellite,
  passenger_ship: passenger_ship,
  scooter: scooter,
  motor_scooter: motor_scooter,
  canoe: canoe,
  sled: sled,
  flying_saucer: flying_saucer,
  zipper_mouth_face: zipper_mouth_face,
  money_mouth_face: money_mouth_face,
  face_with_thermometer: face_with_thermometer,
  nerd_face: nerd_face,
  thinking_face: thinking_face,
  face_with_head_bandage: face_with_head_bandage,
  robot_face: robot_face,
  hugging_face: hugging_face,
  the_horns: the_horns,
  sign_of_the_horns: sign_of_the_horns,
  call_me_hand: call_me_hand,
  raised_back_of_hand: raised_back_of_hand,
  \\"left-facing_fist\\": \\"🤛\\",
  \\"right-facing_fist\\": \\"🤜\\",
  handshake: handshake,
  crossed_fingers: crossed_fingers,
  hand_with_index_and_middle_fingers_crossed: hand_with_index_and_middle_fingers_crossed,
  i_love_you_hand_sign: i_love_you_hand_sign,
  face_with_cowboy_hat: face_with_cowboy_hat,
  clown_face: clown_face,
  nauseated_face: nauseated_face,
  rolling_on_the_floor_laughing: rolling_on_the_floor_laughing,
  drooling_face: drooling_face,
  lying_face: lying_face,
  \\"woman-facepalming\\": \\"🤦‍♀️\\",
  \\"man-facepalming\\": \\"🤦‍♂️\\",
  face_palm: face_palm,
  sneezing_face: sneezing_face,
  face_with_raised_eyebrow: face_with_raised_eyebrow,
  face_with_one_eyebrow_raised: face_with_one_eyebrow_raised,
  \\"star-struck\\": \\"🤩\\",
  grinning_face_with_star_eyes: grinning_face_with_star_eyes,
  zany_face: zany_face,
  grinning_face_with_one_large_and_one_small_eye: grinning_face_with_one_large_and_one_small_eye,
  shushing_face: shushing_face,
  face_with_finger_covering_closed_lips: face_with_finger_covering_closed_lips,
  face_with_symbols_on_mouth: face_with_symbols_on_mouth,
  serious_face_with_symbols_covering_mouth: serious_face_with_symbols_covering_mouth,
  face_with_hand_over_mouth: face_with_hand_over_mouth,
  smiling_face_with_smiling_eyes_and_hand_covering_mouth: smiling_face_with_smiling_eyes_and_hand_covering_mouth,
  face_vomiting: face_vomiting,
  face_with_open_mouth_vomiting: face_with_open_mouth_vomiting,
  exploding_head: exploding_head,
  shocked_face_with_exploding_head: shocked_face_with_exploding_head,
  pregnant_woman: pregnant_woman,
  \\"breast-feeding\\": \\"🤱\\",
  palms_up_together: palms_up_together,
  selfie: selfie,
  prince: prince,
  man_in_tuxedo: man_in_tuxedo,
  mrs_claus: mrs_claus,
  mother_christmas: mother_christmas,
  \\"woman-shrugging\\": \\"🤷‍♀️\\",
  \\"man-shrugging\\": \\"🤷‍♂️\\",
  shrug: shrug,
  \\"woman-cartwheeling\\": \\"🤸‍♀️\\",
  \\"man-cartwheeling\\": \\"🤸‍♂️\\",
  person_doing_cartwheel: person_doing_cartwheel,
  \\"woman-juggling\\": \\"🤹‍♀️\\",
  \\"man-juggling\\": \\"🤹‍♂️\\",
  juggling: juggling,
  fencer: fencer,
  \\"woman-wrestling\\": \\"🤼‍♀️\\",
  \\"man-wrestling\\": \\"🤼‍♂️\\",
  wrestlers: wrestlers,
  \\"woman-playing-water-polo\\": \\"🤽‍♀️\\",
  \\"man-playing-water-polo\\": \\"🤽‍♂️\\",
  water_polo: water_polo,
  \\"woman-playing-handball\\": \\"🤾‍♀️\\",
  \\"man-playing-handball\\": \\"🤾‍♂️\\",
  handball: handball,
  wilted_flower: wilted_flower,
  drum_with_drumsticks: drum_with_drumsticks,
  clinking_glasses: clinking_glasses,
  tumbler_glass: tumbler_glass,
  spoon: spoon,
  goal_net: goal_net,
  first_place_medal: first_place_medal,
  second_place_medal: second_place_medal,
  third_place_medal: third_place_medal,
  boxing_glove: boxing_glove,
  martial_arts_uniform: martial_arts_uniform,
  curling_stone: curling_stone,
  croissant: croissant,
  avocado: avocado,
  cucumber: cucumber,
  bacon: bacon,
  potato: potato,
  carrot: carrot,
  baguette_bread: baguette_bread,
  green_salad: green_salad,
  shallow_pan_of_food: shallow_pan_of_food,
  stuffed_flatbread: stuffed_flatbread,
  egg: egg,
  glass_of_milk: glass_of_milk,
  peanuts: peanuts,
  kiwifruit: kiwifruit,
  pancakes: pancakes,
  dumpling: dumpling,
  fortune_cookie: fortune_cookie,
  takeout_box: takeout_box,
  chopsticks: chopsticks,
  bowl_with_spoon: bowl_with_spoon,
  cup_with_straw: cup_with_straw,
  coconut: coconut,
  broccoli: broccoli,
  pie: pie,
  pretzel: pretzel,
  cut_of_meat: cut_of_meat,
  sandwich: sandwich,
  canned_food: canned_food,
  crab: crab,
  lion_face: lion_face,
  scorpion: scorpion,
  turkey: turkey,
  unicorn_face: unicorn_face,
  eagle: eagle,
  duck: duck,
  bat: bat,
  shark: shark,
  owl: owl,
  fox_face: fox_face,
  butterfly: butterfly,
  deer: deer,
  gorilla: gorilla,
  lizard: lizard,
  rhinoceros: rhinoceros,
  shrimp: shrimp,
  squid: squid,
  giraffe_face: giraffe_face,
  zebra_face: zebra_face,
  hedgehog: hedgehog,
  sauropod: sauropod,
  \\"t-rex\\": \\"🦖\\",
  cricket: cricket,
  cheese_wedge: cheese_wedge,
  face_with_monocle: face_with_monocle,
  adult: adult,
  child: child,
  older_adult: older_adult,
  bearded_person: bearded_person,
  person_with_headscarf: person_with_headscarf,
  woman_in_steamy_room: woman_in_steamy_room,
  man_in_steamy_room: man_in_steamy_room,
  person_in_steamy_room: person_in_steamy_room,
  woman_climbing: woman_climbing,
  person_climbing: person_climbing,
  man_climbing: man_climbing,
  woman_in_lotus_position: woman_in_lotus_position,
  person_in_lotus_position: person_in_lotus_position,
  man_in_lotus_position: man_in_lotus_position,
  female_mage: female_mage,
  mage: mage,
  male_mage: male_mage,
  female_fairy: female_fairy,
  fairy: fairy,
  male_fairy: male_fairy,
  female_vampire: female_vampire,
  vampire: vampire,
  male_vampire: male_vampire,
  mermaid: mermaid,
  merman: merman,
  merperson: merperson,
  female_elf: female_elf,
  male_elf: male_elf,
  elf: elf,
  female_genie: female_genie,
  male_genie: male_genie,
  genie: genie,
  female_zombie: female_zombie,
  male_zombie: male_zombie,
  zombie: zombie,
  brain: brain,
  orange_heart: orange_heart,
  billed_cap: billed_cap,
  scarf: scarf,
  gloves: gloves,
  coat: coat,
  socks: socks,
  bangbang: bangbang,
  interrobang: interrobang,
  tm: tm,
  information_source: information_source,
  left_right_arrow: left_right_arrow,
  arrow_up_down: arrow_up_down,
  arrow_upper_left: arrow_upper_left,
  arrow_upper_right: arrow_upper_right,
  arrow_lower_right: arrow_lower_right,
  arrow_lower_left: arrow_lower_left,
  leftwards_arrow_with_hook: leftwards_arrow_with_hook,
  arrow_right_hook: arrow_right_hook,
  watch: watch,
  hourglass: hourglass,
  keyboard: keyboard,
  eject: eject,
  fast_forward: fast_forward,
  rewind: rewind,
  arrow_double_up: arrow_double_up,
  arrow_double_down: arrow_double_down,
  black_right_pointing_double_triangle_with_vertical_bar: black_right_pointing_double_triangle_with_vertical_bar,
  black_left_pointing_double_triangle_with_vertical_bar: black_left_pointing_double_triangle_with_vertical_bar,
  black_right_pointing_triangle_with_double_vertical_bar: black_right_pointing_triangle_with_double_vertical_bar,
  alarm_clock: alarm_clock,
  stopwatch: stopwatch,
  timer_clock: timer_clock,
  hourglass_flowing_sand: hourglass_flowing_sand,
  double_vertical_bar: double_vertical_bar,
  black_square_for_stop: black_square_for_stop,
  black_circle_for_record: black_circle_for_record,
  m: m,
  black_small_square: black_small_square,
  white_small_square: white_small_square,
  arrow_forward: arrow_forward,
  arrow_backward: arrow_backward,
  white_medium_square: white_medium_square,
  black_medium_square: black_medium_square,
  white_medium_small_square: white_medium_small_square,
  black_medium_small_square: black_medium_small_square,
  sunny: sunny,
  cloud: cloud,
  umbrella: umbrella,
  snowman: snowman,
  comet: comet,
  phone: phone,
  telephone: telephone,
  ballot_box_with_check: ballot_box_with_check,
  shamrock: shamrock,
  point_up: point_up,
  skull_and_crossbones: skull_and_crossbones,
  radioactive_sign: radioactive_sign,
  biohazard_sign: biohazard_sign,
  orthodox_cross: orthodox_cross,
  star_and_crescent: star_and_crescent,
  peace_symbol: peace_symbol,
  yin_yang: yin_yang,
  wheel_of_dharma: wheel_of_dharma,
  white_frowning_face: white_frowning_face,
  relaxed: relaxed,
  female_sign: female_sign,
  male_sign: male_sign,
  gemini: gemini,
  cancer: cancer,
  leo: leo,
  virgo: virgo,
  libra: libra,
  scorpius: scorpius,
  spades: spades,
  clubs: clubs,
  hearts: hearts,
  diamonds: diamonds,
  hotsprings: hotsprings,
  recycle: recycle,
  wheelchair: wheelchair,
  hammer_and_pick: hammer_and_pick,
  crossed_swords: crossed_swords,
  medical_symbol: medical_symbol,
  staff_of_aesculapius: staff_of_aesculapius,
  scales: scales,
  alembic: alembic,
  gear: gear,
  atom_symbol: atom_symbol,
  fleur_de_lis: fleur_de_lis,
  warning: warning,
  zap: zap,
  white_circle: white_circle,
  black_circle: black_circle,
  coffin: coffin,
  funeral_urn: funeral_urn,
  soccer: soccer,
  baseball: baseball,
  snowman_without_snow: snowman_without_snow,
  partly_sunny: partly_sunny,
  thunder_cloud_and_rain: thunder_cloud_and_rain,
  ophiuchus: ophiuchus,
  pick: pick,
  helmet_with_white_cross: helmet_with_white_cross,
  chains: chains,
  no_entry: no_entry,
  shinto_shrine: shinto_shrine,
  church: church,
  mountain: mountain,
  umbrella_on_ground: umbrella_on_ground,
  fountain: fountain,
  golf: golf,
  ferry: ferry,
  boat: boat,
  sailboat: sailboat,
  skier: skier,
  ice_skate: ice_skate,
  \\"woman-bouncing-ball\\": \\"⛹️‍♀️\\",
  \\"man-bouncing-ball\\": \\"⛹️‍♂️\\",
  person_with_ball: person_with_ball,
  tent: tent,
  fuelpump: fuelpump,
  scissors: scissors,
  airplane: airplane,
  email: email,
  envelope: envelope,
  fist: fist,
  hand: hand,
  raised_hand: raised_hand,
  v: v,
  writing_hand: writing_hand,
  pencil2: pencil2,
  black_nib: black_nib,
  heavy_check_mark: heavy_check_mark,
  heavy_multiplication_x: heavy_multiplication_x,
  latin_cross: latin_cross,
  star_of_david: star_of_david,
  eight_spoked_asterisk: eight_spoked_asterisk,
  eight_pointed_black_star: eight_pointed_black_star,
  snowflake: snowflake,
  sparkle: sparkle,
  x: x,
  negative_squared_cross_mark: negative_squared_cross_mark,
  heavy_heart_exclamation_mark_ornament: heavy_heart_exclamation_mark_ornament,
  heart: heart,
  arrow_right: arrow_right,
  curly_loop: curly_loop,
  loop: loop,
  arrow_heading_up: arrow_heading_up,
  arrow_heading_down: arrow_heading_down,
  arrow_left: arrow_left,
  arrow_up: arrow_up,
  arrow_down: arrow_down,
  black_large_square: black_large_square,
  white_large_square: white_large_square,
  star: star,
  o: o,
  wavy_dash: wavy_dash,
  part_alternation_mark: part_alternation_mark,
  congratulations: congratulations,
  secret: secret
};
var emoji$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  umbrella_with_rain_drops: umbrella_with_rain_drops,
  coffee: coffee,
  aries: aries,
  taurus: taurus,
  sagittarius: sagittarius,
  capricorn: capricorn,
  aquarius: aquarius,
  pisces: pisces,
  anchor: anchor,
  white_check_mark: white_check_mark,
  sparkles: sparkles,
  question: question,
  grey_question: grey_question,
  grey_exclamation: grey_exclamation,
  exclamation: exclamation,
  heavy_exclamation_mark: heavy_exclamation_mark,
  heavy_plus_sign: heavy_plus_sign,
  heavy_minus_sign: heavy_minus_sign,
  heavy_division_sign: heavy_division_sign,
  hash: hash,
  keycap_star: keycap_star,
  zero: zero,
  one: one,
  two: two,
  three: three,
  four: four,
  five: five,
  six: six,
  seven: seven,
  eight: eight,
  nine: nine,
  copyright: copyright,
  registered: registered,
  mahjong: mahjong,
  black_joker: black_joker,
  a: a,
  b: b,
  o2: o2,
  parking: parking,
  ab: ab,
  cl: cl,
  cool: cool,
  free: free,
  id: id,
  ng: ng,
  ok: ok,
  sos: sos,
  up: up,
  vs: vs,
  cn: cn,
  de: de,
  es: es,
  fr: fr,
  gb: gb,
  uk: uk,
  it: it,
  jp: jp,
  kr: kr,
  ru: ru,
  us: us,
  koko: koko,
  sa: sa,
  u7121: u7121,
  u6307: u6307,
  u7981: u7981,
  u7a7a: u7a7a,
  u5408: u5408,
  u6e80: u6e80,
  u6709: u6709,
  u6708: u6708,
  u7533: u7533,
  u5272: u5272,
  u55b6: u55b6,
  ideograph_advantage: ideograph_advantage,
  accept: accept,
  cyclone: cyclone,
  foggy: foggy,
  closed_umbrella: closed_umbrella,
  night_with_stars: night_with_stars,
  sunrise_over_mountains: sunrise_over_mountains,
  sunrise: sunrise,
  city_sunset: city_sunset,
  city_sunrise: city_sunrise,
  rainbow: rainbow,
  bridge_at_night: bridge_at_night,
  ocean: ocean,
  volcano: volcano,
  milky_way: milky_way,
  earth_africa: earth_africa,
  earth_americas: earth_americas,
  earth_asia: earth_asia,
  globe_with_meridians: globe_with_meridians,
  new_moon: new_moon,
  waxing_crescent_moon: waxing_crescent_moon,
  first_quarter_moon: first_quarter_moon,
  moon: moon,
  waxing_gibbous_moon: waxing_gibbous_moon,
  full_moon: full_moon,
  waning_gibbous_moon: waning_gibbous_moon,
  last_quarter_moon: last_quarter_moon,
  waning_crescent_moon: waning_crescent_moon,
  crescent_moon: crescent_moon,
  new_moon_with_face: new_moon_with_face,
  first_quarter_moon_with_face: first_quarter_moon_with_face,
  last_quarter_moon_with_face: last_quarter_moon_with_face,
  full_moon_with_face: full_moon_with_face,
  sun_with_face: sun_with_face,
  star2: star2,
  stars: stars,
  thermometer: thermometer,
  mostly_sunny: mostly_sunny,
  sun_small_cloud: sun_small_cloud,
  barely_sunny: barely_sunny,
  sun_behind_cloud: sun_behind_cloud,
  partly_sunny_rain: partly_sunny_rain,
  sun_behind_rain_cloud: sun_behind_rain_cloud,
  rain_cloud: rain_cloud,
  snow_cloud: snow_cloud,
  lightning: lightning,
  lightning_cloud: lightning_cloud,
  tornado: tornado,
  tornado_cloud: tornado_cloud,
  fog: fog,
  wind_blowing_face: wind_blowing_face,
  hotdog: hotdog,
  taco: taco,
  burrito: burrito,
  chestnut: chestnut,
  seedling: seedling,
  evergreen_tree: evergreen_tree,
  deciduous_tree: deciduous_tree,
  palm_tree: palm_tree,
  cactus: cactus,
  hot_pepper: hot_pepper,
  tulip: tulip,
  cherry_blossom: cherry_blossom,
  rose: rose,
  hibiscus: hibiscus,
  sunflower: sunflower,
  blossom: blossom,
  corn: corn,
  ear_of_rice: ear_of_rice,
  herb: herb,
  four_leaf_clover: four_leaf_clover,
  maple_leaf: maple_leaf,
  fallen_leaf: fallen_leaf,
  leaves: leaves,
  mushroom: mushroom,
  tomato: tomato,
  eggplant: eggplant,
  grapes: grapes,
  melon: melon,
  watermelon: watermelon,
  tangerine: tangerine,
  lemon: lemon,
  banana: banana,
  pineapple: pineapple,
  apple: apple,
  green_apple: green_apple,
  pear: pear,
  peach: peach,
  cherries: cherries,
  strawberry: strawberry,
  hamburger: hamburger,
  pizza: pizza,
  meat_on_bone: meat_on_bone,
  poultry_leg: poultry_leg,
  rice_cracker: rice_cracker,
  rice_ball: rice_ball,
  rice: rice,
  curry: curry,
  ramen: ramen,
  spaghetti: spaghetti,
  bread: bread,
  fries: fries,
  sweet_potato: sweet_potato,
  dango: dango,
  oden: oden,
  sushi: sushi,
  fried_shrimp: fried_shrimp,
  fish_cake: fish_cake,
  icecream: icecream,
  shaved_ice: shaved_ice,
  ice_cream: ice_cream,
  doughnut: doughnut,
  cookie: cookie,
  chocolate_bar: chocolate_bar,
  candy: candy,
  lollipop: lollipop,
  custard: custard,
  honey_pot: honey_pot,
  cake: cake,
  bento: bento,
  stew: stew,
  fried_egg: fried_egg,
  cooking: cooking,
  fork_and_knife: fork_and_knife,
  tea: tea,
  sake: sake,
  wine_glass: wine_glass,
  cocktail: cocktail,
  tropical_drink: tropical_drink,
  beer: beer,
  beers: beers,
  baby_bottle: baby_bottle,
  knife_fork_plate: knife_fork_plate,
  champagne: champagne,
  popcorn: popcorn,
  ribbon: ribbon,
  gift: gift,
  birthday: birthday,
  jack_o_lantern: jack_o_lantern,
  christmas_tree: christmas_tree,
  santa: santa,
  fireworks: fireworks,
  sparkler: sparkler,
  balloon: balloon,
  tada: tada,
  confetti_ball: confetti_ball,
  tanabata_tree: tanabata_tree,
  crossed_flags: crossed_flags,
  bamboo: bamboo,
  dolls: dolls,
  flags: flags,
  wind_chime: wind_chime,
  rice_scene: rice_scene,
  school_satchel: school_satchel,
  mortar_board: mortar_board,
  medal: medal,
  reminder_ribbon: reminder_ribbon,
  studio_microphone: studio_microphone,
  level_slider: level_slider,
  control_knobs: control_knobs,
  film_frames: film_frames,
  admission_tickets: admission_tickets,
  carousel_horse: carousel_horse,
  ferris_wheel: ferris_wheel,
  roller_coaster: roller_coaster,
  fishing_pole_and_fish: fishing_pole_and_fish,
  microphone: microphone,
  movie_camera: movie_camera,
  cinema: cinema,
  headphones: headphones,
  art: art,
  tophat: tophat,
  circus_tent: circus_tent,
  ticket: ticket,
  clapper: clapper,
  performing_arts: performing_arts,
  video_game: video_game,
  dart: dart,
  slot_machine: slot_machine,
  game_die: game_die,
  bowling: bowling,
  flower_playing_cards: flower_playing_cards,
  musical_note: musical_note,
  notes: notes,
  saxophone: saxophone,
  guitar: guitar,
  musical_keyboard: musical_keyboard,
  trumpet: trumpet,
  violin: violin,
  musical_score: musical_score,
  running_shirt_with_sash: running_shirt_with_sash,
  tennis: tennis,
  ski: ski,
  basketball: basketball,
  checkered_flag: checkered_flag,
  snowboarder: snowboarder,
  runner: runner,
  running: running,
  surfer: surfer,
  sports_medal: sports_medal,
  trophy: trophy,
  horse_racing: horse_racing,
  football: football,
  rugby_football: rugby_football,
  swimmer: swimmer,
  weight_lifter: weight_lifter,
  golfer: golfer,
  racing_motorcycle: racing_motorcycle,
  racing_car: racing_car,
  cricket_bat_and_ball: cricket_bat_and_ball,
  volleyball: volleyball,
  field_hockey_stick_and_ball: field_hockey_stick_and_ball,
  ice_hockey_stick_and_puck: ice_hockey_stick_and_puck,
  table_tennis_paddle_and_ball: table_tennis_paddle_and_ball,
  snow_capped_mountain: snow_capped_mountain,
  camping: camping,
  beach_with_umbrella: beach_with_umbrella,
  building_construction: building_construction,
  house_buildings: house_buildings,
  cityscape: cityscape,
  derelict_house_building: derelict_house_building,
  classical_building: classical_building,
  desert: desert,
  desert_island: desert_island,
  national_park: national_park,
  stadium: stadium,
  house: house,
  house_with_garden: house_with_garden,
  office: office,
  post_office: post_office,
  european_post_office: european_post_office,
  hospital: hospital,
  bank: bank,
  atm: atm,
  hotel: hotel,
  love_hotel: love_hotel,
  convenience_store: convenience_store,
  school: school,
  department_store: department_store,
  factory: factory,
  izakaya_lantern: izakaya_lantern,
  lantern: lantern,
  japanese_castle: japanese_castle,
  european_castle: european_castle,
  waving_white_flag: waving_white_flag,
  waving_black_flag: waving_black_flag,
  rosette: rosette,
  label: label,
  badminton_racquet_and_shuttlecock: badminton_racquet_and_shuttlecock,
  bow_and_arrow: bow_and_arrow,
  amphora: amphora,
  rat: rat,
  mouse2: mouse2,
  ox: ox,
  water_buffalo: water_buffalo,
  cow2: cow2,
  tiger2: tiger2,
  leopard: leopard,
  rabbit2: rabbit2,
  cat2: cat2,
  dragon: dragon,
  crocodile: crocodile,
  whale2: whale2,
  snail: snail,
  snake: snake,
  racehorse: racehorse,
  ram: ram,
  goat: goat,
  sheep: sheep,
  monkey: monkey,
  rooster: rooster,
  chicken: chicken,
  dog2: dog2,
  pig2: pig2,
  boar: boar,
  elephant: elephant,
  octopus: octopus,
  shell: shell,
  bug: bug,
  ant: ant,
  bee: bee,
  honeybee: honeybee,
  beetle: beetle,
  fish: fish,
  tropical_fish: tropical_fish,
  blowfish: blowfish,
  turtle: turtle,
  hatching_chick: hatching_chick,
  baby_chick: baby_chick,
  hatched_chick: hatched_chick,
  bird: bird,
  penguin: penguin,
  koala: koala,
  poodle: poodle,
  dromedary_camel: dromedary_camel,
  camel: camel,
  dolphin: dolphin,
  flipper: flipper,
  mouse: mouse,
  cow: cow,
  tiger: tiger,
  rabbit: rabbit,
  cat: cat,
  dragon_face: dragon_face,
  whale: whale,
  horse: horse,
  monkey_face: monkey_face,
  dog: dog,
  pig: pig,
  frog: frog,
  hamster: hamster,
  wolf: wolf,
  bear: bear,
  panda_face: panda_face,
  pig_nose: pig_nose,
  feet: feet,
  paw_prints: paw_prints,
  chipmunk: chipmunk,
  eyes: eyes,
  eye: eye,
  ear: ear,
  nose: nose,
  lips: lips,
  tongue: tongue,
  point_up_2: point_up_2,
  point_down: point_down,
  point_left: point_left,
  point_right: point_right,
  facepunch: facepunch,
  punch: punch,
  wave: wave,
  ok_hand: ok_hand,
  thumbsup: thumbsup,
  thumbsdown: thumbsdown,
  clap: clap,
  open_hands: open_hands,
  crown: crown,
  womans_hat: womans_hat,
  eyeglasses: eyeglasses,
  necktie: necktie,
  shirt: shirt,
  tshirt: tshirt,
  jeans: jeans,
  dress: dress,
  kimono: kimono,
  bikini: bikini,
  womans_clothes: womans_clothes,
  purse: purse,
  handbag: handbag,
  pouch: pouch,
  mans_shoe: mans_shoe,
  shoe: shoe,
  athletic_shoe: athletic_shoe,
  high_heel: high_heel,
  sandal: sandal,
  boot: boot,
  footprints: footprints,
  bust_in_silhouette: bust_in_silhouette,
  busts_in_silhouette: busts_in_silhouette,
  boy: boy,
  girl: girl,
  family: family,
  man: man,
  couple_with_heart: couple_with_heart,
  couplekiss: couplekiss,
  woman: woman,
  couple: couple,
  man_and_woman_holding_hands: man_and_woman_holding_hands,
  two_men_holding_hands: two_men_holding_hands,
  two_women_holding_hands: two_women_holding_hands,
  cop: cop,
  dancers: dancers,
  bride_with_veil: bride_with_veil,
  person_with_blond_hair: person_with_blond_hair,
  man_with_gua_pi_mao: man_with_gua_pi_mao,
  man_with_turban: man_with_turban,
  older_man: older_man,
  older_woman: older_woman,
  baby: baby,
  construction_worker: construction_worker,
  princess: princess,
  japanese_ogre: japanese_ogre,
  japanese_goblin: japanese_goblin,
  ghost: ghost,
  angel: angel,
  alien: alien,
  space_invader: space_invader,
  imp: imp,
  skull: skull,
  information_desk_person: information_desk_person,
  guardsman: guardsman,
  dancer: dancer,
  lipstick: lipstick,
  nail_care: nail_care,
  massage: massage,
  haircut: haircut,
  barber: barber,
  syringe: syringe,
  pill: pill,
  kiss: kiss,
  love_letter: love_letter,
  ring: ring,
  gem: gem,
  bouquet: bouquet,
  wedding: wedding,
  heartbeat: heartbeat,
  broken_heart: broken_heart,
  two_hearts: two_hearts,
  sparkling_heart: sparkling_heart,
  heartpulse: heartpulse,
  cupid: cupid,
  blue_heart: blue_heart,
  green_heart: green_heart,
  yellow_heart: yellow_heart,
  purple_heart: purple_heart,
  gift_heart: gift_heart,
  revolving_hearts: revolving_hearts,
  heart_decoration: heart_decoration,
  diamond_shape_with_a_dot_inside: diamond_shape_with_a_dot_inside,
  bulb: bulb,
  anger: anger,
  bomb: bomb,
  zzz: zzz,
  boom: boom,
  collision: collision,
  sweat_drops: sweat_drops,
  droplet: droplet,
  dash: dash,
  hankey: hankey,
  poop: poop,
  shit: shit,
  muscle: muscle,
  dizzy: dizzy,
  speech_balloon: speech_balloon,
  thought_balloon: thought_balloon,
  white_flower: white_flower,
  moneybag: moneybag,
  currency_exchange: currency_exchange,
  heavy_dollar_sign: heavy_dollar_sign,
  credit_card: credit_card,
  yen: yen,
  dollar: dollar,
  euro: euro,
  pound: pound,
  money_with_wings: money_with_wings,
  chart: chart,
  seat: seat,
  computer: computer,
  briefcase: briefcase,
  minidisc: minidisc,
  floppy_disk: floppy_disk,
  cd: cd,
  dvd: dvd,
  file_folder: file_folder,
  open_file_folder: open_file_folder,
  page_with_curl: page_with_curl,
  page_facing_up: page_facing_up,
  date: date,
  calendar: calendar,
  card_index: card_index,
  chart_with_upwards_trend: chart_with_upwards_trend,
  chart_with_downwards_trend: chart_with_downwards_trend,
  bar_chart: bar_chart,
  clipboard: clipboard,
  pushpin: pushpin,
  round_pushpin: round_pushpin,
  paperclip: paperclip,
  straight_ruler: straight_ruler,
  triangular_ruler: triangular_ruler,
  bookmark_tabs: bookmark_tabs,
  ledger: ledger,
  notebook: notebook,
  notebook_with_decorative_cover: notebook_with_decorative_cover,
  closed_book: closed_book,
  book: book,
  open_book: open_book,
  green_book: green_book,
  blue_book: blue_book,
  orange_book: orange_book,
  books: books,
  name_badge: name_badge,
  scroll: scroll,
  memo: memo,
  pencil: pencil,
  telephone_receiver: telephone_receiver,
  pager: pager,
  fax: fax,
  satellite_antenna: satellite_antenna,
  loudspeaker: loudspeaker,
  mega: mega,
  outbox_tray: outbox_tray,
  inbox_tray: inbox_tray,
  incoming_envelope: incoming_envelope,
  envelope_with_arrow: envelope_with_arrow,
  mailbox_closed: mailbox_closed,
  mailbox: mailbox,
  mailbox_with_mail: mailbox_with_mail,
  mailbox_with_no_mail: mailbox_with_no_mail,
  postbox: postbox,
  postal_horn: postal_horn,
  newspaper: newspaper,
  iphone: iphone,
  calling: calling,
  vibration_mode: vibration_mode,
  mobile_phone_off: mobile_phone_off,
  no_mobile_phones: no_mobile_phones,
  signal_strength: signal_strength,
  camera: camera,
  camera_with_flash: camera_with_flash,
  video_camera: video_camera,
  tv: tv,
  radio: radio,
  vhs: vhs,
  film_projector: film_projector,
  prayer_beads: prayer_beads,
  twisted_rightwards_arrows: twisted_rightwards_arrows,
  repeat: repeat,
  repeat_one: repeat_one,
  arrows_clockwise: arrows_clockwise,
  arrows_counterclockwise: arrows_counterclockwise,
  low_brightness: low_brightness,
  high_brightness: high_brightness,
  mute: mute,
  speaker: speaker,
  sound: sound,
  loud_sound: loud_sound,
  battery: battery,
  electric_plug: electric_plug,
  mag: mag,
  mag_right: mag_right,
  lock_with_ink_pen: lock_with_ink_pen,
  closed_lock_with_key: closed_lock_with_key,
  key: key,
  lock: lock,
  unlock: unlock,
  bell: bell,
  no_bell: no_bell,
  bookmark: bookmark,
  link: link$1,
  radio_button: radio_button,
  back: back,
  end: end,
  on: on,
  soon: soon,
  top: top,
  underage: underage,
  keycap_ten: keycap_ten,
  capital_abcd: capital_abcd,
  abcd: abcd,
  symbols: symbols,
  abc: abc,
  fire: fire,
  flashlight: flashlight,
  wrench: wrench,
  hammer: hammer,
  nut_and_bolt: nut_and_bolt,
  hocho: hocho,
  knife: knife,
  gun: gun,
  microscope: microscope,
  telescope: telescope,
  crystal_ball: crystal_ball,
  six_pointed_star: six_pointed_star,
  beginner: beginner,
  trident: trident,
  black_square_button: black_square_button,
  white_square_button: white_square_button,
  red_circle: red_circle,
  large_blue_circle: large_blue_circle,
  large_orange_diamond: large_orange_diamond,
  large_blue_diamond: large_blue_diamond,
  small_orange_diamond: small_orange_diamond,
  small_blue_diamond: small_blue_diamond,
  small_red_triangle: small_red_triangle,
  small_red_triangle_down: small_red_triangle_down,
  arrow_up_small: arrow_up_small,
  arrow_down_small: arrow_down_small,
  om_symbol: om_symbol,
  dove_of_peace: dove_of_peace,
  kaaba: kaaba,
  mosque: mosque,
  synagogue: synagogue,
  menorah_with_nine_branches: menorah_with_nine_branches,
  clock1: clock1,
  clock2: clock2,
  clock3: clock3,
  clock4: clock4,
  clock5: clock5,
  clock6: clock6,
  clock7: clock7,
  clock8: clock8,
  clock9: clock9,
  clock10: clock10,
  clock11: clock11,
  clock12: clock12,
  clock130: clock130,
  clock230: clock230,
  clock330: clock330,
  clock430: clock430,
  clock530: clock530,
  clock630: clock630,
  clock730: clock730,
  clock830: clock830,
  clock930: clock930,
  clock1030: clock1030,
  clock1130: clock1130,
  clock1230: clock1230,
  candle: candle,
  mantelpiece_clock: mantelpiece_clock,
  hole: hole,
  man_in_business_suit_levitating: man_in_business_suit_levitating,
  sleuth_or_spy: sleuth_or_spy,
  dark_sunglasses: dark_sunglasses,
  spider: spider,
  spider_web: spider_web,
  joystick: joystick,
  man_dancing: man_dancing,
  linked_paperclips: linked_paperclips,
  lower_left_ballpoint_pen: lower_left_ballpoint_pen,
  lower_left_fountain_pen: lower_left_fountain_pen,
  lower_left_paintbrush: lower_left_paintbrush,
  lower_left_crayon: lower_left_crayon,
  raised_hand_with_fingers_splayed: raised_hand_with_fingers_splayed,
  middle_finger: middle_finger,
  reversed_hand_with_middle_finger_extended: reversed_hand_with_middle_finger_extended,
  black_heart: black_heart,
  desktop_computer: desktop_computer,
  printer: printer,
  three_button_mouse: three_button_mouse,
  trackball: trackball,
  frame_with_picture: frame_with_picture,
  card_index_dividers: card_index_dividers,
  card_file_box: card_file_box,
  file_cabinet: file_cabinet,
  wastebasket: wastebasket,
  spiral_note_pad: spiral_note_pad,
  spiral_calendar_pad: spiral_calendar_pad,
  compression: compression,
  old_key: old_key,
  rolled_up_newspaper: rolled_up_newspaper,
  dagger_knife: dagger_knife,
  speaking_head_in_silhouette: speaking_head_in_silhouette,
  left_speech_bubble: left_speech_bubble,
  right_anger_bubble: right_anger_bubble,
  ballot_box_with_ballot: ballot_box_with_ballot,
  world_map: world_map,
  mount_fuji: mount_fuji,
  tokyo_tower: tokyo_tower,
  statue_of_liberty: statue_of_liberty,
  japan: japan,
  moyai: moyai,
  grinning: grinning,
  grin: grin,
  joy: joy,
  smiley: smiley,
  smile: smile,
  sweat_smile: sweat_smile,
  laughing: laughing,
  satisfied: satisfied,
  innocent: innocent,
  smiling_imp: smiling_imp,
  wink: wink,
  blush: blush,
  yum: yum,
  relieved: relieved,
  heart_eyes: heart_eyes,
  sunglasses: sunglasses,
  smirk: smirk,
  neutral_face: neutral_face,
  expressionless: expressionless,
  unamused: unamused,
  sweat: sweat,
  pensive: pensive,
  confused: confused,
  confounded: confounded,
  kissing: kissing,
  kissing_heart: kissing_heart,
  kissing_smiling_eyes: kissing_smiling_eyes,
  kissing_closed_eyes: kissing_closed_eyes,
  stuck_out_tongue: stuck_out_tongue,
  stuck_out_tongue_winking_eye: stuck_out_tongue_winking_eye,
  stuck_out_tongue_closed_eyes: stuck_out_tongue_closed_eyes,
  disappointed: disappointed,
  worried: worried,
  angry: angry,
  rage: rage,
  cry: cry,
  persevere: persevere,
  triumph: triumph,
  disappointed_relieved: disappointed_relieved,
  frowning: frowning,
  anguished: anguished,
  fearful: fearful,
  weary: weary,
  sleepy: sleepy,
  tired_face: tired_face,
  grimacing: grimacing,
  sob: sob,
  open_mouth: open_mouth,
  hushed: hushed,
  cold_sweat: cold_sweat,
  scream: scream,
  astonished: astonished,
  flushed: flushed,
  sleeping: sleeping,
  dizzy_face: dizzy_face,
  no_mouth: no_mouth,
  mask: mask,
  smile_cat: smile_cat,
  joy_cat: joy_cat,
  smiley_cat: smiley_cat,
  heart_eyes_cat: heart_eyes_cat,
  smirk_cat: smirk_cat,
  kissing_cat: kissing_cat,
  pouting_cat: pouting_cat,
  crying_cat_face: crying_cat_face,
  scream_cat: scream_cat,
  slightly_frowning_face: slightly_frowning_face,
  slightly_smiling_face: slightly_smiling_face,
  upside_down_face: upside_down_face,
  face_with_rolling_eyes: face_with_rolling_eyes,
  no_good: no_good,
  ok_woman: ok_woman,
  bow: bow,
  see_no_evil: see_no_evil,
  hear_no_evil: hear_no_evil,
  speak_no_evil: speak_no_evil,
  raising_hand: raising_hand,
  raised_hands: raised_hands,
  person_frowning: person_frowning,
  person_with_pouting_face: person_with_pouting_face,
  pray: pray,
  rocket: rocket,
  helicopter: helicopter,
  steam_locomotive: steam_locomotive,
  railway_car: railway_car,
  bullettrain_side: bullettrain_side,
  bullettrain_front: bullettrain_front,
  train2: train2,
  metro: metro,
  light_rail: light_rail,
  station: station,
  tram: tram,
  train: train,
  bus: bus,
  oncoming_bus: oncoming_bus,
  trolleybus: trolleybus,
  busstop: busstop,
  minibus: minibus,
  ambulance: ambulance,
  fire_engine: fire_engine,
  police_car: police_car,
  oncoming_police_car: oncoming_police_car,
  taxi: taxi,
  oncoming_taxi: oncoming_taxi,
  car: car,
  red_car: red_car,
  oncoming_automobile: oncoming_automobile,
  blue_car: blue_car,
  truck: truck,
  articulated_lorry: articulated_lorry,
  tractor: tractor,
  monorail: monorail,
  mountain_railway: mountain_railway,
  suspension_railway: suspension_railway,
  mountain_cableway: mountain_cableway,
  aerial_tramway: aerial_tramway,
  ship: ship,
  rowboat: rowboat,
  speedboat: speedboat,
  traffic_light: traffic_light,
  vertical_traffic_light: vertical_traffic_light,
  construction: construction,
  rotating_light: rotating_light,
  triangular_flag_on_post: triangular_flag_on_post,
  door: door,
  no_entry_sign: no_entry_sign,
  smoking: smoking,
  no_smoking: no_smoking,
  put_litter_in_its_place: put_litter_in_its_place,
  do_not_litter: do_not_litter,
  potable_water: potable_water,
  bike: bike,
  no_bicycles: no_bicycles,
  bicyclist: bicyclist,
  mountain_bicyclist: mountain_bicyclist,
  walking: walking,
  no_pedestrians: no_pedestrians,
  children_crossing: children_crossing,
  mens: mens,
  womens: womens,
  restroom: restroom,
  baby_symbol: baby_symbol,
  toilet: toilet,
  wc: wc,
  shower: shower,
  bath: bath,
  bathtub: bathtub,
  passport_control: passport_control,
  customs: customs,
  baggage_claim: baggage_claim,
  left_luggage: left_luggage,
  couch_and_lamp: couch_and_lamp,
  sleeping_accommodation: sleeping_accommodation,
  shopping_bags: shopping_bags,
  bellhop_bell: bellhop_bell,
  bed: bed,
  place_of_worship: place_of_worship,
  octagonal_sign: octagonal_sign,
  shopping_trolley: shopping_trolley,
  hammer_and_wrench: hammer_and_wrench,
  shield: shield,
  oil_drum: oil_drum,
  motorway: motorway,
  railway_track: railway_track,
  motor_boat: motor_boat,
  small_airplane: small_airplane,
  airplane_departure: airplane_departure,
  airplane_arriving: airplane_arriving,
  satellite: satellite,
  passenger_ship: passenger_ship,
  scooter: scooter,
  motor_scooter: motor_scooter,
  canoe: canoe,
  sled: sled,
  flying_saucer: flying_saucer,
  zipper_mouth_face: zipper_mouth_face,
  money_mouth_face: money_mouth_face,
  face_with_thermometer: face_with_thermometer,
  nerd_face: nerd_face,
  thinking_face: thinking_face,
  face_with_head_bandage: face_with_head_bandage,
  robot_face: robot_face,
  hugging_face: hugging_face,
  the_horns: the_horns,
  sign_of_the_horns: sign_of_the_horns,
  call_me_hand: call_me_hand,
  raised_back_of_hand: raised_back_of_hand,
  handshake: handshake,
  crossed_fingers: crossed_fingers,
  hand_with_index_and_middle_fingers_crossed: hand_with_index_and_middle_fingers_crossed,
  i_love_you_hand_sign: i_love_you_hand_sign,
  face_with_cowboy_hat: face_with_cowboy_hat,
  clown_face: clown_face,
  nauseated_face: nauseated_face,
  rolling_on_the_floor_laughing: rolling_on_the_floor_laughing,
  drooling_face: drooling_face,
  lying_face: lying_face,
  face_palm: face_palm,
  sneezing_face: sneezing_face,
  face_with_raised_eyebrow: face_with_raised_eyebrow,
  face_with_one_eyebrow_raised: face_with_one_eyebrow_raised,
  grinning_face_with_star_eyes: grinning_face_with_star_eyes,
  zany_face: zany_face,
  grinning_face_with_one_large_and_one_small_eye: grinning_face_with_one_large_and_one_small_eye,
  shushing_face: shushing_face,
  face_with_finger_covering_closed_lips: face_with_finger_covering_closed_lips,
  face_with_symbols_on_mouth: face_with_symbols_on_mouth,
  serious_face_with_symbols_covering_mouth: serious_face_with_symbols_covering_mouth,
  face_with_hand_over_mouth: face_with_hand_over_mouth,
  smiling_face_with_smiling_eyes_and_hand_covering_mouth: smiling_face_with_smiling_eyes_and_hand_covering_mouth,
  face_vomiting: face_vomiting,
  face_with_open_mouth_vomiting: face_with_open_mouth_vomiting,
  exploding_head: exploding_head,
  shocked_face_with_exploding_head: shocked_face_with_exploding_head,
  pregnant_woman: pregnant_woman,
  palms_up_together: palms_up_together,
  selfie: selfie,
  prince: prince,
  man_in_tuxedo: man_in_tuxedo,
  mrs_claus: mrs_claus,
  mother_christmas: mother_christmas,
  shrug: shrug,
  person_doing_cartwheel: person_doing_cartwheel,
  juggling: juggling,
  fencer: fencer,
  wrestlers: wrestlers,
  water_polo: water_polo,
  handball: handball,
  wilted_flower: wilted_flower,
  drum_with_drumsticks: drum_with_drumsticks,
  clinking_glasses: clinking_glasses,
  tumbler_glass: tumbler_glass,
  spoon: spoon,
  goal_net: goal_net,
  first_place_medal: first_place_medal,
  second_place_medal: second_place_medal,
  third_place_medal: third_place_medal,
  boxing_glove: boxing_glove,
  martial_arts_uniform: martial_arts_uniform,
  curling_stone: curling_stone,
  croissant: croissant,
  avocado: avocado,
  cucumber: cucumber,
  bacon: bacon,
  potato: potato,
  carrot: carrot,
  baguette_bread: baguette_bread,
  green_salad: green_salad,
  shallow_pan_of_food: shallow_pan_of_food,
  stuffed_flatbread: stuffed_flatbread,
  egg: egg,
  glass_of_milk: glass_of_milk,
  peanuts: peanuts,
  kiwifruit: kiwifruit,
  pancakes: pancakes,
  dumpling: dumpling,
  fortune_cookie: fortune_cookie,
  takeout_box: takeout_box,
  chopsticks: chopsticks,
  bowl_with_spoon: bowl_with_spoon,
  cup_with_straw: cup_with_straw,
  coconut: coconut,
  broccoli: broccoli,
  pie: pie,
  pretzel: pretzel,
  cut_of_meat: cut_of_meat,
  sandwich: sandwich,
  canned_food: canned_food,
  crab: crab,
  lion_face: lion_face,
  scorpion: scorpion,
  turkey: turkey,
  unicorn_face: unicorn_face,
  eagle: eagle,
  duck: duck,
  bat: bat,
  shark: shark,
  owl: owl,
  fox_face: fox_face,
  butterfly: butterfly,
  deer: deer,
  gorilla: gorilla,
  lizard: lizard,
  rhinoceros: rhinoceros,
  shrimp: shrimp,
  squid: squid,
  giraffe_face: giraffe_face,
  zebra_face: zebra_face,
  hedgehog: hedgehog,
  sauropod: sauropod,
  cricket: cricket,
  cheese_wedge: cheese_wedge,
  face_with_monocle: face_with_monocle,
  adult: adult,
  child: child,
  older_adult: older_adult,
  bearded_person: bearded_person,
  person_with_headscarf: person_with_headscarf,
  woman_in_steamy_room: woman_in_steamy_room,
  man_in_steamy_room: man_in_steamy_room,
  person_in_steamy_room: person_in_steamy_room,
  woman_climbing: woman_climbing,
  person_climbing: person_climbing,
  man_climbing: man_climbing,
  woman_in_lotus_position: woman_in_lotus_position,
  person_in_lotus_position: person_in_lotus_position,
  man_in_lotus_position: man_in_lotus_position,
  female_mage: female_mage,
  mage: mage,
  male_mage: male_mage,
  female_fairy: female_fairy,
  fairy: fairy,
  male_fairy: male_fairy,
  female_vampire: female_vampire,
  vampire: vampire,
  male_vampire: male_vampire,
  mermaid: mermaid,
  merman: merman,
  merperson: merperson,
  female_elf: female_elf,
  male_elf: male_elf,
  elf: elf,
  female_genie: female_genie,
  male_genie: male_genie,
  genie: genie,
  female_zombie: female_zombie,
  male_zombie: male_zombie,
  zombie: zombie,
  brain: brain,
  orange_heart: orange_heart,
  billed_cap: billed_cap,
  scarf: scarf,
  gloves: gloves,
  coat: coat,
  socks: socks,
  bangbang: bangbang,
  interrobang: interrobang,
  tm: tm,
  information_source: information_source,
  left_right_arrow: left_right_arrow,
  arrow_up_down: arrow_up_down,
  arrow_upper_left: arrow_upper_left,
  arrow_upper_right: arrow_upper_right,
  arrow_lower_right: arrow_lower_right,
  arrow_lower_left: arrow_lower_left,
  leftwards_arrow_with_hook: leftwards_arrow_with_hook,
  arrow_right_hook: arrow_right_hook,
  watch: watch,
  hourglass: hourglass,
  keyboard: keyboard,
  eject: eject,
  fast_forward: fast_forward,
  rewind: rewind,
  arrow_double_up: arrow_double_up,
  arrow_double_down: arrow_double_down,
  black_right_pointing_double_triangle_with_vertical_bar: black_right_pointing_double_triangle_with_vertical_bar,
  black_left_pointing_double_triangle_with_vertical_bar: black_left_pointing_double_triangle_with_vertical_bar,
  black_right_pointing_triangle_with_double_vertical_bar: black_right_pointing_triangle_with_double_vertical_bar,
  alarm_clock: alarm_clock,
  stopwatch: stopwatch,
  timer_clock: timer_clock,
  hourglass_flowing_sand: hourglass_flowing_sand,
  double_vertical_bar: double_vertical_bar,
  black_square_for_stop: black_square_for_stop,
  black_circle_for_record: black_circle_for_record,
  m: m,
  black_small_square: black_small_square,
  white_small_square: white_small_square,
  arrow_forward: arrow_forward,
  arrow_backward: arrow_backward,
  white_medium_square: white_medium_square,
  black_medium_square: black_medium_square,
  white_medium_small_square: white_medium_small_square,
  black_medium_small_square: black_medium_small_square,
  sunny: sunny,
  cloud: cloud,
  umbrella: umbrella,
  snowman: snowman,
  comet: comet,
  phone: phone,
  telephone: telephone,
  ballot_box_with_check: ballot_box_with_check,
  shamrock: shamrock,
  point_up: point_up,
  skull_and_crossbones: skull_and_crossbones,
  radioactive_sign: radioactive_sign,
  biohazard_sign: biohazard_sign,
  orthodox_cross: orthodox_cross,
  star_and_crescent: star_and_crescent,
  peace_symbol: peace_symbol,
  yin_yang: yin_yang,
  wheel_of_dharma: wheel_of_dharma,
  white_frowning_face: white_frowning_face,
  relaxed: relaxed,
  female_sign: female_sign,
  male_sign: male_sign,
  gemini: gemini,
  cancer: cancer,
  leo: leo,
  virgo: virgo,
  libra: libra,
  scorpius: scorpius,
  spades: spades,
  clubs: clubs,
  hearts: hearts,
  diamonds: diamonds,
  hotsprings: hotsprings,
  recycle: recycle,
  wheelchair: wheelchair,
  hammer_and_pick: hammer_and_pick,
  crossed_swords: crossed_swords,
  medical_symbol: medical_symbol,
  staff_of_aesculapius: staff_of_aesculapius,
  scales: scales,
  alembic: alembic,
  gear: gear,
  atom_symbol: atom_symbol,
  fleur_de_lis: fleur_de_lis,
  warning: warning,
  zap: zap,
  white_circle: white_circle,
  black_circle: black_circle,
  coffin: coffin,
  funeral_urn: funeral_urn,
  soccer: soccer,
  baseball: baseball,
  snowman_without_snow: snowman_without_snow,
  partly_sunny: partly_sunny,
  thunder_cloud_and_rain: thunder_cloud_and_rain,
  ophiuchus: ophiuchus,
  pick: pick,
  helmet_with_white_cross: helmet_with_white_cross,
  chains: chains,
  no_entry: no_entry,
  shinto_shrine: shinto_shrine,
  church: church,
  mountain: mountain,
  umbrella_on_ground: umbrella_on_ground,
  fountain: fountain,
  golf: golf,
  ferry: ferry,
  boat: boat,
  sailboat: sailboat,
  skier: skier,
  ice_skate: ice_skate,
  person_with_ball: person_with_ball,
  tent: tent,
  fuelpump: fuelpump,
  scissors: scissors,
  airplane: airplane,
  email: email,
  envelope: envelope,
  fist: fist,
  hand: hand,
  raised_hand: raised_hand,
  v: v,
  writing_hand: writing_hand,
  pencil2: pencil2,
  black_nib: black_nib,
  heavy_check_mark: heavy_check_mark,
  heavy_multiplication_x: heavy_multiplication_x,
  latin_cross: latin_cross,
  star_of_david: star_of_david,
  eight_spoked_asterisk: eight_spoked_asterisk,
  eight_pointed_black_star: eight_pointed_black_star,
  snowflake: snowflake,
  sparkle: sparkle,
  x: x,
  negative_squared_cross_mark: negative_squared_cross_mark,
  heavy_heart_exclamation_mark_ornament: heavy_heart_exclamation_mark_ornament,
  heart: heart,
  arrow_right: arrow_right,
  curly_loop: curly_loop,
  loop: loop,
  arrow_heading_up: arrow_heading_up,
  arrow_heading_down: arrow_heading_down,
  arrow_left: arrow_left,
  arrow_up: arrow_up,
  arrow_down: arrow_down,
  black_large_square: black_large_square,
  white_large_square: white_large_square,
  star: star,
  o: o,
  wavy_dash: wavy_dash,
  part_alternation_mark: part_alternation_mark,
  congratulations: congratulations,
  secret: secret,
  'default': emoji
});

function getCjsExportFromNamespace(n) {
  return n && n['default'] || n;
}

var emojiByName = getCjsExportFromNamespace(emoji$1);
/**
 * regex to parse emoji in a string - finds emoji, e.g. :coffee:
 */

var emojiNameRegex = /:([a-zA-Z0-9_\\\\-\\\\+]+):/g;
/**
 * regex to trim whitespace
 * use instead of String.prototype.trim() for IE8 support
 */

var trimSpaceRegex = /^[\\\\s\\\\uFEFF\\\\xA0]+|[\\\\s\\\\uFEFF\\\\xA0]+$/g;
/**
 * Removes colons on either side
 * of the string if present
 * @param  {string} str
 * @return {string}
 */

function stripColons(str) {
  var colonIndex = str.indexOf(':');

  if (colonIndex > -1) {
    // :emoji: (http://www.emoji-cheat-sheet.com/)
    if (colonIndex === str.length - 1) {
      str = str.substring(0, colonIndex);
      return stripColons(str);
    } else {
      str = str.substr(colonIndex + 1);
      return stripColons(str);
    }
  }

  return str;
}
/**
 * Adds colons to either side
 * of the string
 * @param {string} str
 * @return {string}
 */


function wrapColons(str) {
  return typeof str === 'string' && str.length > 0 ? ':' + str + ':' : str;
}
/**
 * Ensure that the word is wrapped in colons
 * by only adding them, if they are not there.
 * @param {string} str
 * @return {string}
 */


function ensureColons(str) {
  return typeof str === 'string' && str[0] !== ':' ? wrapColons(str) : str;
} // Non spacing mark, some emoticons have them. It's the 'Variant Form',
// which provides more information so that emoticons can be rendered as
// more colorful graphics. FE0E is a unicode text version, where as FE0F
// should be rendered as a graphical version. The code gracefully degrades.


var NON_SPACING_MARK = String.fromCharCode(65039); // 65039 - '️' - 0xFE0F;

var nonSpacingRegex = new RegExp(NON_SPACING_MARK, 'g'); // Remove the non-spacing-mark from the code, never send a stripped version
// to the client, as it kills graphical emoticons.

function stripNSB(code) {
  return code.replace(nonSpacingRegex, '');
} // Reversed hash table, where as emojiByName contains a { heart: '❤' }
// dictionary emojiByCode contains { ❤: 'heart' }. The codes are normalized
// to the text version.


var emojiByCode = Object.keys(emojiByName).reduce(function (h, k) {
  h[stripNSB(emojiByName[k])] = k;
  return h;
}, {});
/**
 * Emoji namespace
 */

var Emoji = {
  emoji: emojiByName
};
/**
 * get emoji code from name
 * @param  {string} emoji
 * @return {string}
 */

Emoji._get = function _get(emoji) {
  if (emojiByName.hasOwnProperty(emoji)) {
    return emojiByName[emoji];
  }

  return ensureColons(emoji);
};
/**
 * get emoji code from :emoji: string or name
 * @param  {string} emoji
 * @return {string}
 */


Emoji.get = function get(emoji) {
  emoji = stripColons(emoji);
  return Emoji._get(emoji);
};
/**
 * find the emoji by either code or name
 * @param {string} nameOrCode The emoji to find, either \`coffee\`, \`:coffee:\` or \`☕\`;
 * @return {object}
 */


Emoji.find = function find(nameOrCode) {
  return Emoji.findByName(nameOrCode) || Emoji.findByCode(nameOrCode);
};
/**
 * find the emoji by name
 * @param {string} name The emoji to find either \`coffee\` or \`:coffee:\`;
 * @return {object}
 */


Emoji.findByName = function findByName(name) {
  var stripped = stripColons(name);
  var emoji = emojiByName[stripped];
  return emoji ? {
    emoji: emoji,
    key: stripped
  } : undefined;
};
/**
 * find the emoji by code (emoji)
 * @param {string} code The emoji to find; for example \`☕\` or \`☔\`
 * @return {object}
 */


Emoji.findByCode = function findByCode(code) {
  var stripped = stripNSB(code);
  var name = emojiByCode[stripped]; // lookup emoji to ensure the Variant Form is returned

  return name ? {
    emoji: emojiByName[name],
    key: name
  } : undefined;
};
/**
 * Check if an emoji is known by this library
 * @param {string} nameOrCode The emoji to validate, either \`coffee\`, \`:coffee:\` or \`☕\`;
 * @return {object}
 */


Emoji.hasEmoji = function hasEmoji(nameOrCode) {
  return Emoji.hasEmojiByName(nameOrCode) || Emoji.hasEmojiByCode(nameOrCode);
};
/**
 * Check if an emoji with given name is known by this library
 * @param {string} name The emoji to validate either \`coffee\` or \`:coffee:\`;
 * @return {object}
 */


Emoji.hasEmojiByName = function hasEmojiByName(name) {
  var result = Emoji.findByName(name);
  return !!result && result.key === stripColons(name);
};
/**
 * Check if a given emoji is known by this library
 * @param {string} code The emoji to validate; for example \`☕\` or \`☔\`
 * @return {object}
 */


Emoji.hasEmojiByCode = function hasEmojiByCode(code) {
  var result = Emoji.findByCode(code);
  return !!result && stripNSB(result.emoji) === stripNSB(code);
};
/**
 * get emoji name from code
 * @param  {string} emoji
 * @param  {boolean} includeColons should the result include the ::
 * @return {string}
 */


Emoji.which = function which(emoji_code, includeColons) {
  var code = stripNSB(emoji_code);
  var word = emojiByCode[code];
  return includeColons ? wrapColons(word) : word;
};
/**
 * emojify a string (replace :emoji: with an emoji)
 * @param  {string} str
 * @param  {function} on_missing (gets emoji name without :: and returns a proper emoji if no emoji was found)
 * @param  {function} format (wrap the returned emoji in a custom element)
 * @return {string}
 */


Emoji.emojify = function emojify(str, on_missing, format) {
  if (!str) return '';
  return str.split(emojiNameRegex) // parse emoji via regex
  .map(function parseEmoji(s, i) {
    // every second element is an emoji, e.g. \\"test :fast_forward:\\" -> [ \\"test \\", \\"fast_forward\\" ]
    if (i % 2 === 0) return s;

    var emoji = Emoji._get(s);

    var isMissing = emoji.indexOf(':') > -1;

    if (isMissing && typeof on_missing === 'function') {
      return on_missing(s);
    }

    if (!isMissing && typeof format === 'function') {
      return format(emoji, s);
    }

    return emoji;
  }).join('') // convert back to string
  ;
};
/**
 * return a random emoji
 * @return {string}
 */


Emoji.random = function random() {
  var emojiKeys = Object.keys(emojiByName);
  var randomIndex = Math.floor(Math.random() * emojiKeys.length);
  var key = emojiKeys[randomIndex];

  var emoji = Emoji._get(key);

  return {
    key: key,
    emoji: emoji
  };
};
/**
 *  return an collection of potential emoji matches
 *  @param {string} str
 *  @return {Array.<Object>}
 */


Emoji.search = function search(str) {
  var emojiKeys = Object.keys(emojiByName);
  var matcher = stripColons(str);
  var matchingKeys = emojiKeys.filter(function (key) {
    return key.toString().indexOf(matcher) === 0;
  });
  return matchingKeys.map(function (key) {
    return {
      key: key,
      emoji: Emoji._get(key)
    };
  });
};
/**
 * unemojify a string (replace emoji with :emoji:)
 * @param  {string} str
 * @return {string}
 */


Emoji.unemojify = function unemojify(str) {
  if (!str) return '';
  var words = lodash_toarray(str);
  return words.map(function (word) {
    return Emoji.which(word, true) || word;
  }).join('');
};
/**
 * replace emojis with replacement value
 * @param {string} str
 * @param {function|string} the string or callback function to replace the emoji with
 * @param {boolean} should trailing whitespaces be cleaned? Defaults false
 * @return {string}
 */


Emoji.replace = function replace(str, replacement, cleanSpaces) {
  if (!str) return '';
  var replace = typeof replacement === 'function' ? replacement : function () {
    return replacement;
  };
  var words = lodash_toarray(str);
  var replaced = words.map(function (word, idx) {
    var emoji = Emoji.findByCode(word);

    if (emoji && cleanSpaces && words[idx + 1] === ' ') {
      words[idx + 1] = '';
    }

    return emoji ? replace(emoji) : word;
  }).join('');
  return cleanSpaces ? replaced.replace(trimSpaceRegex, '') : replaced;
};
/**
 * remove all emojis from a string
 * @param {string} str
 * @return {string}
 */


Emoji.strip = function strip(str) {
  return Emoji.replace(str, '', true);
};

var emoji$2 = Emoji;
var nodeEmoji = emoji$2;

const {
  get
} = nodeEmoji;
var chalk$2 = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(null), chalk$1, {
  'default': chalk
})); // just a wrapper for console.log

function log(...args) {
  console.log(...args);
}

function info(msg) {
  console.log(format(msg, \\"yellow\\"));
}

function error(msg) {
  console.log(format(msg, \\"red\\"));
}

function action(msg) {
  console.log(format(msg, \\"blue\\"));
}

function findEmojis(str) {
  return str.replace(/(:.*?:)/g, x => \`\${get(x)} \`);
}

function format(msg, color) {
  msg = findEmojis(msg);

  if (!color) {
    return msg;
  }

  return chalk$2[color](msg);
}

var hankey$1 = {
  log,
  info,
  error,
  action,
  format
};

var hankey$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': hankey$1
});

/*
 * [Pika CDN - Package Error] \\"os\\" does not exist.
 *
 * A package that you requested from our CDN depends on a Node.js built-in module.
 * Node.js built-in modules (like \\"fs\\", \\"http\\", etc.) are Node.js-specific, and do
 * not exist in other environments like your web browser. Pika CDN polyfills these
 * modules whenever possible, but this one could not be polyfilled.
 * 
 * How to fix:
 *   - Let the package author know that you'd like to run their package in the browser.
 *   - Use https://pika.dev/ to find a more web-friendly alternative to the package that required this one.
 */
throw new Error('[Pika CDN - Package Error] The Node.js builtin module \\"os\\" does not exist outside of Node.js.');
var node_os = null;

/*
 * [Pika CDN - Package Error] \\"fs\\" does not exist.
 *
 * A package that you requested from our CDN depends on a Node.js built-in module.
 * Node.js built-in modules (like \\"fs\\", \\"http\\", etc.) are Node.js-specific, and do
 * not exist in other environments like your web browser. Pika CDN polyfills these
 * modules whenever possible, but this one could not be polyfilled.
 * 
 * How to fix:
 *   - Let the package author know that you'd like to run their package in the browser.
 *   - Use https://pika.dev/ to find a more web-friendly alternative to the package that required this one.
 */
throw new Error('[Pika CDN - Package Error] The Node.js builtin module \\"fs\\" does not exist outside of Node.js.');
var node_fs = null;

//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// \\"Software\\"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\\\\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)

function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, \`up\` ends up > 0
  var up = 0;

  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];

    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
} // Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.


var splitPathRe = /^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;

var splitPath = function splitPath(filename) {
  return splitPathRe.exec(filename).slice(1);
}; // path.resolve([from ...], to)
// posix version


function resolve() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : '/'; // Skip empty and invalid entries

    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  } // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)
  // Normalize the path


  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
} // path.normalize(path)
// posix version


function normalize(path) {
  var isPathAbsolute = isAbsolute(path),
      trailingSlash = substr(path, -1) === '/'; // Normalize the path

  path = normalizeArray(filter(path.split('/'), function (p) {
    return !!p;
  }), !isPathAbsolute).join('/');

  if (!path && !isPathAbsolute) {
    path = '.';
  }

  if (path && trailingSlash) {
    path += '/';
  }

  return (isPathAbsolute ? '/' : '') + path;
} // posix version


function isAbsolute(path) {
  return path.charAt(0) === '/';
} // posix version


function join() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }

    return p;
  }).join('/'));
} // path.relative(from, to)
// posix version


function relative(from, to) {
  from = resolve(from).substr(1);
  to = resolve(to).substr(1);

  function trim(arr) {
    var start = 0;

    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;

    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;

  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];

  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join('/');
}

var sep = '/';
var delimiter = ':';

function dirname(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
}

function basename(path, ext) {
  var f = splitPath(path)[2]; // TODO: make this comparison case-insensitive on windows?

  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }

  return f;
}

function extname(path) {
  return splitPath(path)[3];
}

var pathModule = {
  extname: extname,
  basename: basename,
  dirname: dirname,
  sep: sep,
  delimiter: delimiter,
  relative: relative,
  join: join,
  isAbsolute: isAbsolute,
  normalize: normalize,
  resolve: resolve
};

function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }

  return res;
} // String.prototype.substr - negative index don't work in IE8


var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  callback = missingCallback;
  return callback;

  function missingCallback(err) {
    if (err) {
      if (process$1.throwDeprecation) throw err; // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process$1.noDeprecation) {
          var msg = 'fs: missing callback ' + (err.stack || err.message);
          if (process$1.traceDeprecation) console.trace(msg);else console.error(msg);
        }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
} // Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']


if (false) {
  var nextPartRe;
} else {
  var nextPartRe = /(.*?)(?:[\\\\/]+|$)/g;
} // Regex to find the device root, including trailing slash. E.g. 'c:\\\\\\\\'.


if (false) {
  var splitRootRe;
} else {
  var splitRootRe = /^[\\\\/]*/;
}

var realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {}; // current character position in p

  var pos; // the partial path so far, including a trailing slash if any

  var current; // the partial path without a trailing slash (except when pointing at a root)

  var base; // the partial path scanned in the previous round, with slash

  var previous;
  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';
  } // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.


  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex; // continue if not a symlink

    if (knownHard[base] || cache && cache[base] === base) {
      continue;
    }

    var resolvedLink;

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = node_fs.lstatSync(base);

      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      } // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.


      var linkTarget = null;
      {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);

        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }

      if (linkTarget === null) {
        node_fs.statSync(base);
        linkTarget = node_fs.readlinkSync(base);
      }

      resolvedLink = pathModule.resolve(previous, linkTarget); // track this, if given a cache.

      if (cache) cache[base] = resolvedLink;
      seenLinks[id] = linkTarget;
    } // resolve the link, then start over


    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;
  return p;
};

var realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  } // make p is absolute


  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process$1.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {}; // current character position in p

  var pos; // the partial path so far, including a trailing slash if any

  var current; // the partial path without a trailing slash (except when pointing at a root)

  var base; // the partial path scanned in the previous round, with slash

  var previous;
  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = ''; // On windows, check that the root exists. On unix there is no need.

    {
      process$1.nextTick(LOOP);
    }
  } // walk down the path, swapping out linked pathparts for their real
  // values


  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    } // find the next part


    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex; // continue if not a symlink

    if (knownHard[base] || cache && cache[base] === base) {
      return process$1.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return node_fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err); // if not a symlink, skip to the next path part

    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process$1.nextTick(LOOP);
    } // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.


    {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);

      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    node_fs.stat(base, function (err) {
      if (err) return cb(err);
      node_fs.readlink(base, function (err, target) {
        seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);
    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};

var old = {
  realpathSync: realpathSync,
  realpath: realpath
};
var fs_realpath = realpath$1;
realpath$1.realpath = realpath$1;
realpath$1.sync = realpathSync$1;
realpath$1.realpathSync = realpathSync$1;
realpath$1.monkeypatch = monkeypatch;
realpath$1.unmonkeypatch = unmonkeypatch;
var origRealpath = node_fs.realpath;
var origRealpathSync = node_fs.realpathSync;
var version = process$1.version;
var ok$1 = /^v[0-5]\\\\./.test(version);

function newError(er) {
  return er && er.syscall === 'realpath' && (er.code === 'ELOOP' || er.code === 'ENOMEM' || er.code === 'ENAMETOOLONG');
}

function realpath$1(p, cache, cb) {
  if (ok$1) {
    return origRealpath(p, cache, cb);
  }

  if (typeof cache === 'function') {
    cb = cache;
    cache = null;
  }

  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb);
    } else {
      cb(er, result);
    }
  });
}

function realpathSync$1(p, cache) {
  if (ok$1) {
    return origRealpathSync(p, cache);
  }

  try {
    return origRealpathSync(p, cache);
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache);
    } else {
      throw er;
    }
  }
}

function monkeypatch() {
  node_fs.realpath = realpath$1;
  node_fs.realpathSync = realpathSync$1;
}

function unmonkeypatch() {
  node_fs.realpath = origRealpath;
  node_fs.realpathSync = origRealpathSync;
}

var concatMap = function concatMap(xs, fn) {
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    var x = fn(xs[i], i);
    if (isArray$1(x)) res.push.apply(res, x);else res.push(x);
  }

  return res;
};

var isArray$1 = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

var balancedMatch = balanced;

function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);
  var r = range(a, b, str);
  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;

function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [begs.pop(), bi];
      } else {
        beg = begs.pop();

        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [left, right];
    }
  }

  return result;
}

var braceExpansion = expandTop;
var escSlash = '\\\\0SLASH' + Math.random() + '\\\\0';
var escOpen = '\\\\0OPEN' + Math.random() + '\\\\0';
var escClose = '\\\\0CLOSE' + Math.random() + '\\\\0';
var escComma = '\\\\0COMMA' + Math.random() + '\\\\0';
var escPeriod = '\\\\0PERIOD' + Math.random() + '\\\\0';

function numeric(str) {
  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\\\\\\\\\\\\\').join(escSlash).split('\\\\\\\\{').join(escOpen).split('\\\\\\\\}').join(escClose).split('\\\\\\\\,').join(escComma).split('\\\\\\\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\\\\\\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');
} // Basically just str.split(\\",\\"), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}


function parseCommaParts(str) {
  if (!str) return [''];
  var parts = [];
  var m = balancedMatch('{', '}', str);
  if (!m) return str.split(',');
  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');
  p[p.length - 1] += '{' + body + '}';
  var postParts = parseCommaParts(post);

  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);
  return parts;
}

function expandTop(str) {
  if (!str) return []; // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}

  if (str.substr(0, 2) === '{}') {
    str = '\\\\\\\\{\\\\\\\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function embrace(str) {
  return '{' + str + '}';
}

function isPadded(el) {
  return /^-?0\\\\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}

function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];
  var m = balancedMatch('{', '}', str);
  if (!m || /\\\\$$/.test(m.pre)) return [str];
  var isNumericSequence = /^-?\\\\d+\\\\.\\\\.-?\\\\d+(?:\\\\.\\\\.-?\\\\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\\\\.\\\\.[a-zA-Z](?:\\\\.\\\\.-?\\\\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;

  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\\\\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }

    return [str];
  }

  var n;

  if (isSequence) {
    n = m.body.split(/\\\\.\\\\./);
  } else {
    n = parseCommaParts(m.body);

    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);

      if (n.length === 1) {
        var post = m.post.length ? expand(m.post, false) : [''];
        return post.map(function (p) {
          return m.pre + n[0] + p;
        });
      }
    }
  } // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.
  // no need to expand pre, since it is guaranteed to be free of brace-sets


  var pre = m.pre;
  var post = m.post.length ? expand(m.post, false) : [''];
  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length);
    var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
    var test = lte;
    var reverse = y < x;

    if (reverse) {
      incr *= -1;
      test = gte;
    }

    var pad = n.some(isPadded);
    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;

      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\\\\\\\') c = '';
      } else {
        c = String(i);

        if (pad) {
          var need = width - c.length;

          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0) c = '-' + z + c.slice(1);else c = z + c;
          }
        }
      }

      N.push(c);
    }
  } else {
    N = concatMap(n, function (el) {
      return expand(el, false);
    });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion) expansions.push(expansion);
    }
  }

  return expansions;
}

//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// \\"Software\\"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\\\\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)

function normalizeArray$1(parts, allowAboveRoot) {
  // if the path tries to go above the root, \`up\` ends up > 0
  var up = 0;

  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];

    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
} // Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.


var splitPathRe$1 = /^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;

var splitPath$1 = function splitPath(filename) {
  return splitPathRe$1.exec(filename).slice(1);
}; // path.resolve([from ...], to)
// posix version


function resolve$1() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : '/'; // Skip empty and invalid entries

    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  } // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)
  // Normalize the path


  resolvedPath = normalizeArray$1(filter$1(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
} // path.normalize(path)
// posix version


function normalize$1(path) {
  var isPathAbsolute = isAbsolute$1(path),
      trailingSlash = substr$1(path, -1) === '/'; // Normalize the path

  path = normalizeArray$1(filter$1(path.split('/'), function (p) {
    return !!p;
  }), !isPathAbsolute).join('/');

  if (!path && !isPathAbsolute) {
    path = '.';
  }

  if (path && trailingSlash) {
    path += '/';
  }

  return (isPathAbsolute ? '/' : '') + path;
} // posix version


function isAbsolute$1(path) {
  return path.charAt(0) === '/';
} // posix version


function join$1() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize$1(filter$1(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }

    return p;
  }).join('/'));
} // path.relative(from, to)
// posix version


function relative$1(from, to) {
  from = resolve$1(from).substr(1);
  to = resolve$1(to).substr(1);

  function trim(arr) {
    var start = 0;

    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;

    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;

  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];

  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join('/');
}

var sep$1 = '/';
var delimiter$1 = ':';

function dirname$1(path) {
  var result = splitPath$1(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
}

function basename$1(path, ext) {
  var f = splitPath$1(path)[2]; // TODO: make this comparison case-insensitive on windows?

  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }

  return f;
}

function extname$1(path) {
  return splitPath$1(path)[3];
}

var require$$0 = {
  extname: extname$1,
  basename: basename$1,
  dirname: dirname$1,
  sep: sep$1,
  delimiter: delimiter$1,
  relative: relative$1,
  join: join$1,
  isAbsolute: isAbsolute$1,
  normalize: normalize$1,
  resolve: resolve$1
};

function filter$1(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }

  return res;
} // String.prototype.substr - negative index don't work in IE8


var substr$1 = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};
var minimatch_1 = minimatch;
minimatch.Minimatch = Minimatch;
var path = {
  sep: '/'
};

try {
  path = require$$0;
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
var plTypes = {
  '!': {
    open: '(?:(?!(?:',
    close: '))[^/]*?)'
  },
  '?': {
    open: '(?:',
    close: ')?'
  },
  '+': {
    open: '(?:',
    close: ')+'
  },
  '*': {
    open: '(?:',
    close: ')*'
  },
  '@': {
    open: '(?:',
    close: ')'
  }
}; // any single thing other than /
// don't need to escape / when using new RegExp()

var qmark = '[^/]'; // * => any number of characters

var star$1 = qmark + '*?'; // ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.

var twoStarDot = '(?:(?!(?:\\\\\\\\\\\\/|^)(?:\\\\\\\\.{1,2})($|\\\\\\\\\\\\/)).)*?'; // not a ^ or / followed by a dot,
// followed by anything, any number of times.

var twoStarNoDot = '(?:(?!(?:\\\\\\\\\\\\/|^)\\\\\\\\.).)*?'; // characters that need to be escaped in RegExp.

var reSpecials = charSet('().*{}+?[]^$\\\\\\\\!'); // \\"abc\\" -> { a:true, b:true, c:true }

function charSet(s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true;
    return set;
  }, {});
} // normalizes slashes.


var slashSplit = /\\\\/+/;
minimatch.filter = filter$1$1;

function filter$1$1(pattern, options) {
  options = options || {};
  return function (p, i, list) {
    return minimatch(p, pattern, options);
  };
}

function ext(a, b) {
  a = a || {};
  b = b || {};
  var t = {};
  Object.keys(b).forEach(function (k) {
    t[k] = b[k];
  });
  Object.keys(a).forEach(function (k) {
    t[k] = a[k];
  });
  return t;
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch;
  var orig = minimatch;

  var m = function minimatch(p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options));
  };

  m.Minimatch = function Minimatch(pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options));
  };

  return m;
};

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch;
  return minimatch.defaults(def).Minimatch;
};

function minimatch(p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required');
  }

  if (!options) options = {}; // shortcut: comments match nothing.

  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false;
  } // \\"\\" only matches \\"\\"


  if (pattern.trim() === '') return p === '';
  return new Minimatch(pattern, options).match(p);
}

function Minimatch(pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options);
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required');
  }

  if (!options) options = {};
  pattern = pattern.trim(); // windows support: need to use /, not \\\\

  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/');
  }

  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false; // make the set of regexps etc.

  this.make();
}

Minimatch.prototype.debug = function () {};

Minimatch.prototype.make = make;

function make() {
  // don't do it more than once.
  if (this._made) return;
  var pattern = this.pattern;
  var options = this.options; // empty patterns and comments match nothing.

  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true;
    return;
  }

  if (!pattern) {
    this.empty = true;
    return;
  } // step 1: figure out negation, etc.


  this.parseNegate(); // step 2: expand braces

  var set = this.globSet = this.braceExpand();
  if (options.debug) this.debug = console.error;
  this.debug(this.pattern, set); // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of \\"**\\", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters

  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit);
  });
  this.debug(this.pattern, set); // glob --> regexps

  set = set.map(function (s, si, set) {
    return s.map(this.parse, this);
  }, this);
  this.debug(this.pattern, set); // filter out everything that didn't compile properly.

  set = set.filter(function (s) {
    return s.indexOf(false) === -1;
  });
  this.debug(this.pattern, set);
  this.set = set;
}

Minimatch.prototype.parseNegate = parseNegate;

function parseNegate() {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;
  if (options.nonegate) return;

  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
    negate = !negate;
    negateOffset++;
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
} // Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c


minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options);
};

Minimatch.prototype.braceExpand = braceExpand;

function braceExpand(pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options;
    } else {
      options = {};
    }
  }

  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern');
  }

  if (options.nobrace || !pattern.match(/\\\\{.*\\\\}/)) {
    // shortcut. no need to expand.
    return [pattern];
  }

  return braceExpansion(pattern);
} // parse a component of the expanded set.
// At this point, no pattern may contain \\"/\\" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that \\"**\\" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.


Minimatch.prototype.parse = parse;
var SUBPARSE = {};

function parse(pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long');
  }

  var options = this.options; // shortcuts

  if (!options.noglobstar && pattern === '**') return GLOBSTAR;
  if (pattern === '') return '';
  var re = '';
  var hasMagic = !!options.nocase;
  var escaping = false; // ? => one single character

  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1; // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.

  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\\\\\\\\\\/)\\\\\\\\.{1,2}(?:$|\\\\\\\\\\\\/))' : '(?!\\\\\\\\.)';
  var self = this;

  function clearStateChar() {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star$1;
          hasMagic = true;
          break;

        case '?':
          re += qmark;
          hasMagic = true;
          break;

        default:
          re += '\\\\\\\\' + stateChar;
          break;
      }

      self.debug('clearStateChar %j %j', stateChar, re);
      stateChar = false;
    }
  }

  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
    this.debug('%s\\\\t%s %s %j', pattern, i, re, c); // skip over any that are escaped.

    if (escaping && reSpecials[c]) {
      re += '\\\\\\\\' + c;
      escaping = false;
      continue;
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false;

      case '\\\\\\\\':
        clearStateChar();
        escaping = true;
        continue;
      // the various stateChar values
      // for the \\"extglob\\" stuff.

      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\\\\t%s %s %j <-- stateChar', pattern, i, re, c); // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp

        if (inClass) {
          this.debug('  in class');
          if (c === '!' && i === classStart + 1) c = '^';
          re += c;
          continue;
        } // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.


        self.debug('call clearStateChar %j', stateChar);
        clearStateChar();
        stateChar = c; // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.

        if (options.noext) clearStateChar();
        continue;

      case '(':
        if (inClass) {
          re += '(';
          continue;
        }

        if (!stateChar) {
          re += '\\\\\\\\(';
          continue;
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        }); // negation is (?:(?!js)[^/]*)

        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
        this.debug('plType %j %j', stateChar, re);
        stateChar = false;
        continue;

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\\\\\\\)';
          continue;
        }

        clearStateChar();
        hasMagic = true;
        var pl = patternListStack.pop(); // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>

        re += pl.close;

        if (pl.type === '!') {
          negativeLists.push(pl);
        }

        pl.reEnd = re.length;
        continue;

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\\\\\\\|';
          escaping = false;
          continue;
        }

        clearStateChar();
        re += '|';
        continue;
      // these are mostly the same in regexp and glob

      case '[':
        // swallow any state-tracking char before the [
        clearStateChar();

        if (inClass) {
          re += '\\\\\\\\' + c;
          continue;
        }

        inClass = true;
        classStart = i;
        reClassStart = re.length;
        re += c;
        continue;

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\\\\\\\' + c;
          escaping = false;
          continue;
        } // handle the case where we left a class open.
        // \\"[z-a]\\" is valid, equivalent to \\"\\\\[z-a\\\\]\\"


        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i);

          try {
            RegExp('[' + cs + ']');
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + '\\\\\\\\[' + sp[0] + '\\\\\\\\]';
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
        } // finish up the class.


        hasMagic = true;
        inClass = false;
        re += c;
        continue;

      default:
        // swallow any state char that wasn't consumed
        clearStateChar();

        if (escaping) {
          // no need
          escaping = false;
        } else if (reSpecials[c] && !(c === '^' && inClass)) {
          re += '\\\\\\\\';
        }

        re += c;
    } // switch

  } // for
  // handle the case where we left a class open.
  // \\"[abc\\" is valid, equivalent to \\"\\\\[abc\\"


  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1);
    sp = this.parse(cs, SUBPARSE);
    re = re.substr(0, reClassStart) + '\\\\\\\\[' + sp[0];
    hasMagic = hasMagic || sp[1];
  } // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.


  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length);
    this.debug('setting tail', re, pl); // maybe some even number of \\\\, then maybe 1 \\\\, followed by a |

    tail = tail.replace(/((?:\\\\\\\\{2}){0,64})(\\\\\\\\?)\\\\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\\\\\\\';
      } // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.


      return $1 + $1 + $2 + '|';
    });
    this.debug('tail=%j\\\\n   %s', tail, tail, pl, re);
    var t = pl.type === '*' ? star$1 : pl.type === '?' ? qmark : '\\\\\\\\' + pl.type;
    hasMagic = true;
    re = re.slice(0, pl.reStart) + t + '\\\\\\\\(' + tail;
  } // handle trailing things that only matter at the very end.


  clearStateChar();

  if (escaping) {
    // trailing \\\\\\\\
    re += '\\\\\\\\\\\\\\\\';
  } // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot


  var addPatternStart = false;

  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(':
      addPatternStart = true;
  } // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.


  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n];
    var nlBefore = re.slice(0, nl.reStart);
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
    var nlAfter = re.slice(nl.reEnd);
    nlLast += nlAfter; // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // \\"after\\" the negated section.

    var openParensBefore = nlBefore.split('(').length - 1;
    var cleanAfter = nlAfter;

    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\\\\)[+*?]?/, '');
    }

    nlAfter = cleanAfter;
    var dollar = '';

    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$';
    }

    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re = newRe;
  } // if the re is not \\"\\" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.


  if (re !== '' && hasMagic) {
    re = '(?=.)' + re;
  }

  if (addPatternStart) {
    re = patternStart + re;
  } // parsing just a piece of a larger pattern.


  if (isSub === SUBPARSE) {
    return [re, hasMagic];
  } // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.


  if (!hasMagic) {
    return globUnescape(pattern);
  }

  var flags = options.nocase ? 'i' : '';

  try {
    var regExp = new RegExp('^' + re + '$', flags);
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.');
  }

  regExp._glob = pattern;
  regExp._src = re;
  return regExp;
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe();
};

Minimatch.prototype.makeRe = makeRe;

function makeRe() {
  if (this.regexp || this.regexp === false) return this.regexp; // at this point, this.set is a 2d array of partial
  // pattern strings, or \\"**\\".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.

  var set = this.set;

  if (!set.length) {
    this.regexp = false;
    return this.regexp;
  }

  var options = this.options;
  var twoStar = options.noglobstar ? star$1 : options.dot ? twoStarDot : twoStarNoDot;
  var flags = options.nocase ? 'i' : '';
  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;
    }).join('\\\\\\\\\\\\/');
  }).join('|'); // must match entire pattern
  // ending in a * or ** will make it less strict.

  re = '^(?:' + re + ')$'; // can match anything, as long as it's not this.

  if (this.negate) re = '^(?!' + re + ').*$';

  try {
    this.regexp = new RegExp(re, flags);
  } catch (ex) {
    this.regexp = false;
  }

  return this.regexp;
}

minimatch.match = function (list, pattern, options) {
  options = options || {};
  var mm = new Minimatch(pattern, options);
  list = list.filter(function (f) {
    return mm.match(f);
  });

  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }

  return list;
};

Minimatch.prototype.match = match;

function match(f, partial) {
  this.debug('match', f, this.pattern); // short-circuit in the case of busted things.
  // comments, etc.

  if (this.comment) return false;
  if (this.empty) return f === '';
  if (f === '/' && partial) return true;
  var options = this.options; // windows: need to use /, not \\\\

  if (path.sep !== '/') {
    f = f.split(path.sep).join('/');
  } // treat the test path as a set of pathparts.


  f = f.split(slashSplit);
  this.debug(this.pattern, 'split', f); // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set;
  this.debug(this.pattern, 'set', set); // Find the basename of the path by looking for the last non-empty segment

  var filename;
  var i;

  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i];
    if (filename) break;
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i];
    var file = f;

    if (options.matchBase && pattern.length === 1) {
      file = [filename];
    }

    var hit = this.matchOne(file, pattern, partial);

    if (hit) {
      if (options.flipNegate) return true;
      return !this.negate;
    }
  } // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.


  if (options.flipNegate) return false;
  return this.negate;
} // set partial to true to test if, for example,
// \\"/a/b\\" matches the start of \\"/*/b/*/d\\"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.


Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options;
  this.debug('matchOne', {
    'this': this,
    file: file,
    pattern: pattern
  });
  this.debug('matchOne', file.length, pattern.length);

  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
    this.debug('matchOne loop');
    var p = pattern[pi];
    var f = file[fi];
    this.debug(pattern, p, f); // should be impossible.
    // some invalid regexp stuff in the set.

    if (p === false) return false;

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f]); // \\"**\\"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** \\"swallows\\" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit

      var fr = fi;
      var pr = pi + 1;

      if (pr === pl) {
        this.debug('** at the end'); // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.

        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;
        }

        return true;
      } // ok, let's see if we can swallow whatever we can.


      while (fr < fl) {
        var swallowee = file[fr];
        this.debug('\\\\nglobstar while', file, fr, pattern, pr, swallowee); // XXX remove this slice.  Just pass the start index.

        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee); // found a match.

          return true;
        } else {
          // can't swallow \\".\\" or \\"..\\" ever.
          // can only swallow \\".foo\\" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
            this.debug('dot detected!', file, fr, pattern, pr);
            break;
          } // ** swallows a segment, and continue.


          this.debug('globstar swallow a segment, and continue');
          fr++;
        }
      } // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then


      if (partial) {
        // ran out of file
        this.debug('\\\\n>>> no match, partial?', file, fr, pattern, pr);
        if (fr === fl) return true;
      }

      return false;
    } // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.


    var hit;

    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase();
      } else {
        hit = f === p;
      }

      this.debug('string match', p, f, hit);
    } else {
      hit = f.match(p);
      this.debug('pattern match', p, f, hit);
    }

    if (!hit) return false;
  } // Note: ending in / means that we'll get a final \\"\\"
  // at the end of the pattern.  This can only match a
  // corresponding \\"\\" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match \\"a/b/*\\", even though \\"\\" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*
  // now either we fell off the end of the pattern, or we're done.


  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true;
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial;
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = fi === fl - 1 && file[fi] === '';
    return emptyFileEnd;
  } // should be unreachable.


  throw new Error('wtf?');
}; // replace stuff like \\\\* with *


function globUnescape(s) {
  return s.replace(/\\\\\\\\(.)/g, '$1');
}

function regExpEscape(s) {
  return s.replace(/[-[\\\\]{}()*+?.,\\\\\\\\^$|#\\\\s]/g, '\\\\\\\\$&');
}

function createCommonjsModule$3(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var inherits_browser = createCommonjsModule$3(function (module) {
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function TempCtor() {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

function posix(path) {
  return path.charAt(0) === '/';
}

function win32(path) {
  // https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
  var splitDeviceRe = /^([a-zA-Z]:|[\\\\\\\\\\\\/]{2}[^\\\\\\\\\\\\/]+[\\\\\\\\\\\\/]+[^\\\\\\\\\\\\/]+)?([\\\\\\\\\\\\/])?([\\\\s\\\\S]*?)$/;
  var result = splitDeviceRe.exec(path);
  var device = result[1] || '';
  var isUnc = Boolean(device && device.charAt(1) !== ':'); // UNC paths are always absolute

  return Boolean(result[2] || isUnc);
}

var pathIsAbsolute = posix;
var posix_1 = posix;
var win32_1 = win32;
pathIsAbsolute.posix = posix_1;
pathIsAbsolute.win32 = win32_1;

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
var wrappy_1 = wrappy;

function wrappy(fn, cb) {
  if (fn && cb) return wrappy(fn)(cb);
  if (typeof fn !== 'function') throw new TypeError('need wrapper function');
  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });
  return wrapper;

  function wrapper() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    var ret = fn.apply(this, args);
    var cb = args[args.length - 1];

    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }

    return ret;
  }
}

var once_1 = wrappy_1(once);
var strict = wrappy_1(onceStrict);
once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this);
    },
    configurable: true
  });
  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this);
    },
    configurable: true
  });
});

function once(fn) {
  var f = function f() {
    if (f.called) return f.value;
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };

  f.called = false;
  return f;
}

function onceStrict(fn) {
  var f = function f() {
    if (f.called) throw new Error(f.onceError);
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };

  var name = fn.name || 'Function wrapped with \`once\`';
  f.onceError = name + \\" shouldn't be called more than once\\";
  f.called = false;
  return f;
}

once_1.strict = strict;

var reqs = Object.create(null);
var inflight_1 = wrappy_1(inflight);

function inflight(key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb);
    return null;
  } else {
    reqs[key] = [cb];
    return makeres(key);
  }
}

function makeres(key) {
  return once_1(function RES() {
    var cbs = reqs[key];
    var len = cbs.length;
    var args = slice(arguments); // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.

    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args);
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len);
        process$1.nextTick(function () {
          RES.apply(null, args);
        });
      } else {
        delete reqs[key];
      }
    }
  });
}

function slice(args) {
  var length = args.length;
  var array = [];

  for (var i = 0; i < length; i++) array[i] = args[i];

  return array;
}

var domain; // This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling \`Object.create(null)\` to get a \\"clean\\" empty
// object (tested with v8 v4.9).

function EventHandlers() {}

EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
} // nodejs oddity
// require('events') === require('events').EventEmitter


EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function () {
  this.domain = null;

  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active) ;
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('\\"n\\" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
}; // These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.


function emitNone(handler, isFn, self) {
  if (isFn) handler.call(self);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) listeners[i].call(self);
  }
}

function emitOne(handler, isFn, self, arg1) {
  if (isFn) handler.call(self, arg1);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);
  }
}

function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn) handler.call(self, arg1, arg2);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
  }
}

function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn) handler.call(self, arg1, arg2, arg3);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn) handler.apply(self, args);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = type === 'error';
  events = this._events;
  if (events) doError = doError && events.error == null;else if (!doError) return false;
  domain = this.domain; // If there is no 'error' event listener then throw.

  if (doError) {
    er = arguments[1];

    if (domain) {
      if (!er) er = new Error('Uncaught, unspecified \\"error\\" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified \\"error\\" event. (' + er + ')');
      err.context = er;
      throw err;
    }

    return false;
  }

  handler = events[type];
  if (!handler) return false;
  var isFn = typeof handler === 'function';
  len = arguments.length;

  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;

    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;

    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;

    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower

    default:
      args = new Array(len - 1);

      for (i = 1; i < len; i++) args[i - 1] = arguments[i];

      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== 'function') throw new TypeError('\\"listener\\" argument must be a function');
  events = target._events;

  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === \\"newListener\\"! Before
    // adding it to the listeners, first emit \\"newListener\\".
    if (events.newListener) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign \`events\` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    } // Check for listener leak


    if (!existing.warned) {
      m = $getMaxListeners(target);

      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}

function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function _onceWrap(target, type, listener) {
  var fired = false;

  function g() {
    target.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }

  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') throw new TypeError('\\"listener\\" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== 'function') throw new TypeError('\\"listener\\" argument must be a function');
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // emits a 'removeListener' event iff the listener was removed


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  if (typeof listener !== 'function') throw new TypeError('\\"listener\\" argument must be a function');
  events = this._events;
  if (!events) return this;
  list = events[type];
  if (!list) return this;

  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0) this._events = new EventHandlers();else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length; i-- > 0;) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (list.length === 1) {
      list[0] = undefined;

      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events[type];
      }
    } else {
      spliceOne(list, position);
    }

    if (events.removeListener) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events;
  events = this._events;
  if (!events) return this; // not listening for removeListener, no need to emit

  if (!events.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events[type]) {
      if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);

    for (var i = 0, key; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    do {
      this.removeListener(type, listeners[listeners.length - 1]);
    } while (listeners[0]);
  }

  return this;
};

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;
  if (!events) ret = [];else {
    evlistener = events[type];
    if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);
  }
  return ret;
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
}; // About 1.5x faster than the two-arg version of Array#splice().


function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];

  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);

  while (i--) copy[i] = arr[i];

  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
} // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// \\"Software\\"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\\\\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)


function normalizeArray$2(parts, allowAboveRoot) {
  // if the path tries to go above the root, \`up\` ends up > 0
  var up = 0;

  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];

    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
} // Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.


var splitPathRe$2 = /^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;

var splitPath$2 = function splitPath(filename) {
  return splitPathRe$2.exec(filename).slice(1);
}; // path.resolve([from ...], to)
// posix version


function resolve$2() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : '/'; // Skip empty and invalid entries

    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  } // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)
  // Normalize the path


  resolvedPath = normalizeArray$2(filter$2(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
} // path.normalize(path)
// posix version


function normalize$2(path) {
  var isPathAbsolute = isAbsolute$2(path),
      trailingSlash = substr$2(path, -1) === '/'; // Normalize the path

  path = normalizeArray$2(filter$2(path.split('/'), function (p) {
    return !!p;
  }), !isPathAbsolute).join('/');

  if (!path && !isPathAbsolute) {
    path = '.';
  }

  if (path && trailingSlash) {
    path += '/';
  }

  return (isPathAbsolute ? '/' : '') + path;
} // posix version


function isAbsolute$2(path) {
  return path.charAt(0) === '/';
} // posix version


function join$2() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize$2(filter$2(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }

    return p;
  }).join('/'));
} // path.relative(from, to)
// posix version


function relative$2(from, to) {
  from = resolve$2(from).substr(1);
  to = resolve$2(to).substr(1);

  function trim(arr) {
    var start = 0;

    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;

    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;

  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];

  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join('/');
}

var sep$2 = '/';
var delimiter$2 = ':';

function dirname$2(path) {
  var result = splitPath$2(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
}

function basename$2(path, ext) {
  var f = splitPath$2(path)[2]; // TODO: make this comparison case-insensitive on windows?

  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }

  return f;
}

function extname$2(path) {
  return splitPath$2(path)[3];
}

var path$1 = {
  extname: extname$2,
  basename: basename$2,
  dirname: dirname$2,
  sep: sep$2,
  delimiter: delimiter$2,
  relative: relative$2,
  join: join$2,
  isAbsolute: isAbsolute$2,
  normalize: normalize$2,
  resolve: resolve$2
};

function filter$2(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }

  return res;
} // String.prototype.substr - negative index don't work in IE8


var substr$2 = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;

function init() {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray(b64) {
  if (!inited) {
    init();
  }

  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice


  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data

  arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  if (!inited) {
    init();
  }

  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);
  return parts.join('');
}

function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}

function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString = {}.toString;

var isArray$2 = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */


var INSPECT_MAX_BYTES = 50;
/**
 * If \`Buffer.TYPED_ARRAY_SUPPORT\`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to \`Uint8Array\` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the \`TypedArray.prototype.subarray\` function.
 *
 *   - IE10 has a broken \`TypedArray.prototype.subarray\` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set \`Buffer.TYPED_ARRAY_SUPPORT\` to \`false\` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : true;

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented \`Uint8Array\` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of \`Uint8Array\` that have their
 * prototype changed to \`Buffer.prototype\`. Furthermore, \`Buffer\` is a subclass of
 * \`Uint8Array\`, so the returned instances will have all the node \`Buffer\` methods
 * and the \`Uint8Array\` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The \`Uint8Array\` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('\\"value\\" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('\\"size\\" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('\\"size\\" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('\\"encoding\\" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if \`array\` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\\\\'offset\\\\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\\\\'length\\\\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented \`Uint8Array\` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray$2(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use \`length < kMaxLength()\` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

Buffer.isBuffer = isBuffer;

function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}

Buffer.compare = function compare(a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray$2(list)) {
    throw new TypeError('\\"list\\" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!internalIsBuffer(buf)) {
      throw new TypeError('\\"list\\" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that \\"this.length <= MAX_UINT32\\" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by \`Buffer.isBuffer\` and \`is-buffer\` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of \`val\` in \`buffer\` at offset >= \`byteOffset\`,
// OR the last index of \`val\` in \`buffer\` at offset <= \`byteOffset\`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into \`buffer\`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, \\"foo\\", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid \\"call stack size exceeded\\".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('\\"buffer\\" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('\\"value\\" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }

  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }

  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\\\\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \\\\n and \\\\t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\\\\s+|\\\\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
} // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually


function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}

function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
}

var inherits;

if (typeof Object.create === 'function') {
  inherits = function inherits(ctor, superCtor) {
    // implementation from standard node.js 'util' module
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;

    var TempCtor = function TempCtor() {};

    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

var inherits$1 = inherits; // Copyright Joyent, Inc. and other Node contributors.

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/

function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an \\"options\\" object
    _extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
} // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics


inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // \\"name\\": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\\\\u001b[' + inspect.colors[style][0] + 'm' + str + '\\\\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction$1(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString$1(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction$1(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray$1$1(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction$1(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString$1(value)) {
    var simple = '\\\\'' + JSON.stringify(value).replace(/^\\"|\\"$/g, '').replace(/'/g, \\"\\\\\\\\'\\").replace(/\\\\\\\\\\"/g, '\\"') + '\\\\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is \\"object\\", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty$1(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\\\\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty$1(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\\\\n') > -1) {
        if (array) {
          str = str.split('\\\\n').map(function (line) {
            return '  ' + line;
          }).join('\\\\n').substr(2);
        } else {
          str = '\\\\n' + str.split('\\\\n').map(function (line) {
            return '   ' + line;
          }).join('\\\\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\\\\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^\\"([a-zA-Z_][a-zA-Z_0-9]*)\\"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, \\"\\\\\\\\'\\").replace(/\\\\\\\\\\"/g, '\\"').replace(/(^\\"|\\"$)/g, \\"'\\");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var length = output.reduce(function (prev, cur) {
    if (cur.indexOf('\\\\n') >= 0) ;
    return prev + cur.replace(/\\\\u001b\\\\[\\\\d\\\\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\\\\n ') + ' ' + output.join(',\\\\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use \`instanceof\`
// because it is fragile and can be easily faked with \`Object.create()\`.


function isArray$1$1(ar) {
  return Array.isArray(ar);
}

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

function isNull(arg) {
  return arg === null;
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isString$1(arg) {
  return typeof arg === 'string';
}

function isUndefined(arg) {
  return arg === void 0;
}

function isRegExp(re) {
  return isObject$1(re) && objectToString$1(re) === '[object RegExp]';
}

function isObject$1(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isDate(d) {
  return isObject$1(d) && objectToString$1(d) === '[object Date]';
}

function isError(e) {
  return isObject$1(e) && (objectToString$1(e) === '[object Error]' || e instanceof Error);
}

function isFunction$1(arg) {
  return typeof arg === 'function';
}

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

function objectToString$1(o) {
  return Object.prototype.toString.call(o);
}

function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject$1(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
}

function hasOwnProperty$1(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

var hasOwn = Object.prototype.hasOwnProperty;

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }

  return keys;
};

var pSlice = Array.prototype.slice;

var _functionsHaveNames;

function functionsHaveNames() {
  if (typeof _functionsHaveNames !== 'undefined') {
    return _functionsHaveNames;
  }

  return _functionsHaveNames = function () {
    return function foo() {}.name === 'foo';
  }();
}

function pToString(obj) {
  return Object.prototype.toString.call(obj);
}

function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }

  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }

  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }

  if (!arrbuf) {
    return false;
  }

  if (arrbuf instanceof DataView) {
    return true;
  }

  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }

  return false;
} // 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.


function assert(value, message) {
  if (!value) fail(value, true, message, '==', ok$2);
} // 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })


var regex = /\\\\s*function\\\\s+([^\\\\(\\\\s]*)\\\\s*/; // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js

function getName(func) {
  if (!isFunction$1(func)) {
    return;
  }

  if (functionsHaveNames()) {
    return func.name;
  }

  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}

assert.AssertionError = AssertionError;

function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;

  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }

  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();

    if (err.stack) {
      var out = err.stack; // try to strip useless frames

      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\\\\n' + fn_name);

      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\\\\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
} // assert.AssertionError instanceof Error


inherits$1(AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function inspect$1(something) {
  if (functionsHaveNames() || !isFunction$1(something)) {
    return inspect(something);
  }

  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}

function getMessage(self) {
  return truncate(inspect$1(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect$1(self.expected), 128);
} // At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.
// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.


function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
} // EXTENSION! allows for well behaved errors defined elsewhere.


assert.fail = fail; // 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok$2(value, message) {
  if (!value) fail(value, true, message, '==', ok$2);
}

assert.ok = ok$2; // 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = equal;

function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', equal);
} // 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);


assert.notEqual = notEqual;

function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', notEqual);
  }
} // 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);


assert.deepEqual = deepEqual;

function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', deepEqual);
  }
}

assert.deepStrictEqual = deepStrictEqual;

function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
  }
}

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0; // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is
    // equivalent if it is also a RegExp object with the same source and
    // properties (\`global\`, \`multiline\`, \`lastIndex\`, \`ignoreCase\`).
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected; // If both values are instances of typed arrays, wrap their underlying
    // ArrayBuffers in a Buffer each to increase performance
    // This optimization requires the arrays to have the same type as checked by
    // Object.prototype.toString (aka pToString). Never perform binary
    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
    // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0; // 7.5 For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {
      actual: [],
      expected: []
    };
    var actualIndex = memos.actual.indexOf(actual);

    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments$1(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false; // if one is a primitive, the other must be same

  if (isPrimitive(a) || isPrimitive(b)) return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
  var aIsArgs = isArguments$1(a);
  var bIsArgs = isArguments$1(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;

  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }

  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i; // having the same number of owned properties (keys incorporates
  // hasOwnProperty)

  if (ka.length !== kb.length) return false; //the same set of keys (although not necessarily the same order),

  ka.sort();
  kb.sort(); //~~~cheap key test

  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i]) return false;
  } //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test


  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }

  return true;
} // 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);


assert.notDeepEqual = notDeepEqual;

function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', notDeepEqual);
  }
}

assert.notDeepStrictEqual = notDeepStrictEqual;

function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
} // 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);


assert.strictEqual = strictEqual;

function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', strictEqual);
  }
} // 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);


assert.notStrictEqual = notStrictEqual;

function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', notStrictEqual);
  }
}

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {// Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;

  try {
    block();
  } catch (e) {
    error = e;
  }

  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('\\"block\\" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);
  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
} // 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);


assert.throws = throws;

function throws(block,
/*optional*/
error,
/*optional*/
message) {
  _throws(true, block, error, message);
} // EXTENSION! This is annoying to write outside this module.


assert.doesNotThrow = doesNotThrow;

function doesNotThrow(block,
/*optional*/
error,
/*optional*/
message) {
  _throws(false, block, error, message);
}

assert.ifError = ifError;

function ifError(err) {
  if (err) throw err;
}

var alphasort_1 = alphasort;
var alphasorti_1 = alphasorti;
var setopts_1 = setopts;
var ownProp_1 = ownProp;
var makeAbs_1 = makeAbs;
var finish_1 = finish;
var mark_1 = mark;
var isIgnored_1 = isIgnored;
var childrenIgnored_1 = childrenIgnored;

function ownProp(obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field);
}

var Minimatch$1 = minimatch_1.Minimatch;

function alphasorti(a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase());
}

function alphasort(a, b) {
  return a.localeCompare(b);
}

function setupIgnores(self, options) {
  self.ignore = options.ignore || [];
  if (!Array.isArray(self.ignore)) self.ignore = [self.ignore];

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap);
  }
} // ignore patterns are always in dot:true mode.


function ignoreMap(pattern) {
  var gmatcher = null;

  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\\\\/\\\\*\\\\*)+$/, '');
    gmatcher = new Minimatch$1(gpattern, {
      dot: true
    });
  }

  return {
    matcher: new Minimatch$1(pattern, {
      dot: true
    }),
    gmatcher: gmatcher
  };
}

function setopts(self, pattern, options) {
  if (!options) options = {}; // base-matching: just use globstar for that.

  if (options.matchBase && -1 === pattern.indexOf(\\"/\\")) {
    if (options.noglobstar) {
      throw new Error(\\"base matching requires globstar\\");
    }

    pattern = \\"**/\\" + pattern;
  }

  self.silent = !!options.silent;
  self.pattern = pattern;
  self.strict = options.strict !== false;
  self.realpath = !!options.realpath;
  self.realpathCache = options.realpathCache || Object.create(null);
  self.follow = !!options.follow;
  self.dot = !!options.dot;
  self.mark = !!options.mark;
  self.nodir = !!options.nodir;
  if (self.nodir) self.mark = true;
  self.sync = !!options.sync;
  self.nounique = !!options.nounique;
  self.nonull = !!options.nonull;
  self.nosort = !!options.nosort;
  self.nocase = !!options.nocase;
  self.stat = !!options.stat;
  self.noprocess = !!options.noprocess;
  self.absolute = !!options.absolute;
  self.maxLength = options.maxLength || Infinity;
  self.cache = options.cache || Object.create(null);
  self.statCache = options.statCache || Object.create(null);
  self.symlinks = options.symlinks || Object.create(null);
  setupIgnores(self, options);
  self.changedCwd = false;
  var cwd = process$1.cwd();
  if (!ownProp(options, \\"cwd\\")) self.cwd = cwd;else {
    self.cwd = path$1.resolve(options.cwd);
    self.changedCwd = self.cwd !== cwd;
  }
  self.root = options.root || path$1.resolve(self.cwd, \\"/\\");
  self.root = path$1.resolve(self.root); // TODO: is an absolute \`cwd\` supposed to be resolved against \`root\`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')

  self.cwdAbs = pathIsAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
  self.nomount = !!options.nomount; // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.

  options.nonegate = true;
  options.nocomment = true;
  self.minimatch = new Minimatch$1(pattern, options);
  self.options = self.minimatch.options;
}

function finish(self) {
  var nou = self.nounique;
  var all = nou ? [] : Object.create(null);

  for (var i = 0, l = self.matches.length; i < l; i++) {
    var matches = self.matches[i];

    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i];
        if (nou) all.push(literal);else all[literal] = true;
      }
    } else {
      // had matches
      var m = Object.keys(matches);
      if (nou) all.push.apply(all, m);else m.forEach(function (m) {
        all[m] = true;
      });
    }
  }

  if (!nou) all = Object.keys(all);
  if (!self.nosort) all = all.sort(self.nocase ? alphasorti : alphasort); // at *some* point we statted all of these

  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i]);
    }

    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !/\\\\/$/.test(e);
        var c = self.cache[e] || self.cache[makeAbs(self, e)];
        if (notDir && c) notDir = c !== 'DIR' && !Array.isArray(c);
        return notDir;
      });
    }
  }

  if (self.ignore.length) all = all.filter(function (m) {
    return !isIgnored(self, m);
  });
  self.found = all;
}

function mark(self, p) {
  var abs = makeAbs(self, p);
  var c = self.cache[abs];
  var m = p;

  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c);
    var slash = p.slice(-1) === '/';
    if (isDir && !slash) m += '/';else if (!isDir && slash) m = m.slice(0, -1);

    if (m !== p) {
      var mabs = makeAbs(self, m);
      self.statCache[mabs] = self.statCache[abs];
      self.cache[mabs] = self.cache[abs];
    }
  }

  return m;
} // lotta situps...


function makeAbs(self, f) {
  var abs = f;

  if (f.charAt(0) === '/') {
    abs = path$1.join(self.root, f);
  } else if (pathIsAbsolute(f) || f === '') {
    abs = f;
  } else if (self.changedCwd) {
    abs = path$1.resolve(self.cwd, f);
  } else {
    abs = path$1.resolve(f);
  }

  return abs;
} // Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents


function isIgnored(self, path) {
  if (!self.ignore.length) return false;
  return self.ignore.some(function (item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path));
  });
}

function childrenIgnored(self, path) {
  if (!self.ignore.length) return false;
  return self.ignore.some(function (item) {
    return !!(item.gmatcher && item.gmatcher.match(path));
  });
}

var common = {
  alphasort: alphasort_1,
  alphasorti: alphasorti_1,
  setopts: setopts_1,
  ownProp: ownProp_1,
  makeAbs: makeAbs_1,
  finish: finish_1,
  mark: mark_1,
  isIgnored: isIgnored_1,
  childrenIgnored: childrenIgnored_1
};
var sync = globSync;
globSync.GlobSync = GlobSync;
var Glob = glob_1.__moduleExports.Glob;
var setopts$1 = common.setopts;
var ownProp$1 = common.ownProp;
var childrenIgnored$1 = common.childrenIgnored;
var isIgnored$1 = common.isIgnored;

function globSync(pattern, options) {
  if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\\\\n' + 'See: https://github.com/isaacs/node-glob/issues/167');
  return new GlobSync(pattern, options).found;
}

function GlobSync(pattern, options) {
  if (!pattern) throw new Error('must provide pattern');
  if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\\\\n' + 'See: https://github.com/isaacs/node-glob/issues/167');
  if (!(this instanceof GlobSync)) return new GlobSync(pattern, options);
  setopts$1(this, pattern, options);
  if (this.noprocess) return this;
  var n = this.minimatch.set.length;
  this.matches = new Array(n);

  for (var i = 0; i < n; i++) {
    this._process(this.minimatch.set[i], i, false);
  }

  this._finish();
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync);

  if (this.realpath) {
    var self = this;
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null);

      for (var p in matchset) {
        try {
          p = self._makeAbs(p);
          var real = fs_realpath.realpathSync(p, self.realpathCache);
          set[real] = true;
        } catch (er) {
          if (er.syscall === 'stat') set[self._makeAbs(p)] = true;else throw er;
        }
      }
    });
  }

  common.finish(this);
};

GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync); // Get the first [n] parts of pattern that are all strings.

  var n = 0;

  while (typeof pattern[n] === 'string') {
    n++;
  } // now n is the index of the first one that is *not* a string.
  // See if there's anything else


  var prefix;

  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index);

      return;

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null;
      break;

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/');
      break;
  }

  var remain = pattern.slice(n); // get the list of entries.

  var read;
  if (prefix === null) read = '.';else if (pathIsAbsolute(prefix) || pathIsAbsolute(pattern.join('/'))) {
    if (!prefix || !pathIsAbsolute(prefix)) prefix = '/' + prefix;
    read = prefix;
  } else read = prefix;

  var abs = this._makeAbs(read); //if ignored, skip processing


  if (childrenIgnored$1(this, read)) return;
  var isGlobStar = remain[0] === minimatch_1.GLOBSTAR;
  if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
};

GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar); // if the abs isn't a dir, then nothing can match!


  if (!entries) return; // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.

  var pn = remain[0];
  var negate = !!this.minimatch.negate;
  var rawGlob = pn._glob;
  var dotOk = this.dot || rawGlob.charAt(0) === '.';
  var matchedEntries = [];

  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];

    if (e.charAt(0) !== '.' || dotOk) {
      var m;

      if (negate && !prefix) {
        m = !e.match(pn);
      } else {
        m = e.match(pn);
      }

      if (m) matchedEntries.push(e);
    }
  }

  var len = matchedEntries.length; // If there are no matched entries, then nothing matches.

  if (len === 0) return; // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index]) this.matches[index] = Object.create(null);

    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];

      if (prefix) {
        if (prefix.slice(-1) !== '/') e = prefix + '/' + e;else e = prefix + e;
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path$1.join(this.root, e);
      }

      this._emitMatch(index, e);
    } // This was the last one, and no stats were needed


    return;
  } // now test all matched entries as stand-ins for that part
  // of the pattern.


  remain.shift();

  for (var i = 0; i < len; i++) {
    var e = matchedEntries[i];
    var newPattern;
    if (prefix) newPattern = [prefix, e];else newPattern = [e];

    this._process(newPattern.concat(remain), index, inGlobStar);
  }
};

GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored$1(this, e)) return;

  var abs = this._makeAbs(e);

  if (this.mark) e = this._mark(e);

  if (this.absolute) {
    e = abs;
  }

  if (this.matches[index][e]) return;

  if (this.nodir) {
    var c = this.cache[abs];
    if (c === 'DIR' || Array.isArray(c)) return;
  }

  this.matches[index][e] = true;
  if (this.stat) this._stat(e);
};

GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow) return this._readdir(abs, false);
  var entries;
  var lstat;

  try {
    lstat = node_fs.lstatSync(abs);
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null;
    }
  }

  var isSym = lstat && lstat.isSymbolicLink();
  this.symlinks[abs] = isSym; // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.

  if (!isSym && lstat && !lstat.isDirectory()) this.cache[abs] = 'FILE';else entries = this._readdir(abs, false);
  return entries;
};

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  if (inGlobStar && !ownProp$1(this.symlinks, abs)) return this._readdirInGlobStar(abs);

  if (ownProp$1(this.cache, abs)) {
    var c = this.cache[abs];
    if (!c || c === 'FILE') return null;
    if (Array.isArray(c)) return c;
  }

  try {
    return this._readdirEntries(abs, node_fs.readdirSync(abs));
  } catch (er) {
    this._readdirError(abs, er);

    return null;
  }
};

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (abs === '/') e = abs + e;else e = abs + '/' + e;
      this.cache[e] = true;
    }
  }

  this.cache[abs] = entries; // mark and cache dir-ness

  return entries;
};

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205

    case 'ENOTDIR':
      // totally normal. means it *does* exist.
      var abs = this._makeAbs(f);

      this.cache[abs] = 'FILE';

      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd);
        error.path = this.cwd;
        error.code = er.code;
        throw error;
      }

      break;

    case 'ENOENT': // not terribly unusual

    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false;
      break;

    default:
      // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false;
      if (this.strict) throw er;
      if (!this.silent) console.error('glob error', er);
      break;
  }
};

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar); // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt


  if (!entries) return; // test without the globstar, and with every child both below
  // and replacing the globstar.

  var remainWithoutGlobStar = remain.slice(1);
  var gspref = prefix ? [prefix] : [];
  var noGlobStar = gspref.concat(remainWithoutGlobStar); // the noGlobStar pattern exits the inGlobStar state

  this._process(noGlobStar, index, false);

  var len = entries.length;
  var isSym = this.symlinks[abs]; // If it's a symlink, and we're in a globstar, then stop

  if (isSym && inGlobStar) return;

  for (var i = 0; i < len; i++) {
    var e = entries[i];
    if (e.charAt(0) === '.' && !this.dot) continue; // these two cases enter the inGlobStar state

    var instead = gspref.concat(entries[i], remainWithoutGlobStar);

    this._process(instead, index, true);

    var below = gspref.concat(entries[i], remain);

    this._process(below, index, true);
  }
};

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix);

  if (!this.matches[index]) this.matches[index] = Object.create(null); // If it doesn't exist, then just mark the lack of results

  if (!exists) return;

  if (prefix && pathIsAbsolute(prefix) && !this.nomount) {
    var trail = /[\\\\/\\\\\\\\]$/.test(prefix);

    if (prefix.charAt(0) === '/') {
      prefix = path$1.join(this.root, prefix);
    } else {
      prefix = path$1.resolve(this.root, prefix);
      if (trail) prefix += '/';
    }
  } // Mark this as a match


  this._emitMatch(index, prefix);
}; // Returns either 'DIR', 'FILE', or false


GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f);

  var needDir = f.slice(-1) === '/';
  if (f.length > this.maxLength) return false;

  if (!this.stat && ownProp$1(this.cache, abs)) {
    var c = this.cache[abs];
    if (Array.isArray(c)) c = 'DIR'; // It exists, but maybe not how we need it

    if (!needDir || c === 'DIR') return c;
    if (needDir && c === 'FILE') return false; // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var stat = this.statCache[abs];

  if (!stat) {
    var lstat;

    try {
      lstat = node_fs.lstatSync(abs);
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false;
        return false;
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = node_fs.statSync(abs);
      } catch (er) {
        stat = lstat;
      }
    } else {
      stat = lstat;
    }
  }

  this.statCache[abs] = stat;
  var c = true;
  if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';
  this.cache[abs] = this.cache[abs] || c;
  if (needDir && c === 'FILE') return false;
  return c;
};

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p);
};

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f);
}; // Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   \`true\` for files, and [children,...] for directories, or \`false\` for
//   things that don't exist.


var glob_1 = glob;
var EE = EventEmitter.EventEmitter;
var setopts$2 = common.setopts;
var ownProp$2 = common.ownProp;
var childrenIgnored$2 = common.childrenIgnored;
var isIgnored$2 = common.isIgnored;

function glob(pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {};
  if (!options) options = {};

  if (options.sync) {
    if (cb) throw new TypeError('callback provided to sync glob');
    return sync(pattern, options);
  }

  return new Glob$1(pattern, options, cb);
}

glob.sync = sync;
var GlobSync$1 = glob.GlobSync = sync.GlobSync; // old api surface

glob.glob = glob;

function extend(origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin;
  }

  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_);
  options.noprocess = true;
  var g = new Glob$1(pattern, options);
  var set = g.minimatch.set;
  if (!pattern) return false;
  if (set.length > 1) return true;

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string') return true;
  }

  return false;
};

glob.Glob = Glob$1;
inherits_browser(Glob$1, EE);

function Glob$1(pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = null;
  }

  if (options && options.sync) {
    if (cb) throw new TypeError('callback provided to sync glob');
    return new GlobSync$1(pattern, options);
  }

  if (!(this instanceof Glob$1)) return new Glob$1(pattern, options, cb);
  setopts$2(this, pattern, options);
  this._didRealPath = false; // process each pattern in the minimatch set

  var n = this.minimatch.set.length; // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.

  this.matches = new Array(n);

  if (typeof cb === 'function') {
    cb = once_1(cb);
    this.on('error', cb);
    this.on('end', function (matches) {
      cb(null, matches);
    });
  }

  var self = this;
  this._processing = 0;
  this._emitQueue = [];
  this._processQueue = [];
  this.paused = false;
  if (this.noprocess) return this;
  if (n === 0) return done();
  var sync = true;

  for (var i = 0; i < n; i++) {
    this._process(this.minimatch.set[i], i, false, done);
  }

  sync = false;

  function done() {
    --self._processing;

    if (self._processing <= 0) {
      if (sync) {
        process$1.nextTick(function () {
          self._finish();
        });
      } else {
        self._finish();
      }
    }
  }
}

Glob$1.prototype._finish = function () {
  assert(this instanceof Glob$1);
  if (this.aborted) return;
  if (this.realpath && !this._didRealpath) return this._realpath();
  common.finish(this);
  this.emit('end', this.found);
};

Glob$1.prototype._realpath = function () {
  if (this._didRealpath) return;
  this._didRealpath = true;
  var n = this.matches.length;
  if (n === 0) return this._finish();
  var self = this;

  for (var i = 0; i < this.matches.length; i++) this._realpathSet(i, next);

  function next() {
    if (--n === 0) self._finish();
  }
};

Glob$1.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index];
  if (!matchset) return cb();
  var found = Object.keys(matchset);
  var self = this;
  var n = found.length;
  if (n === 0) return cb();
  var set = this.matches[index] = Object.create(null);
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p);
    fs_realpath.realpath(p, self.realpathCache, function (er, real) {
      if (!er) set[real] = true;else if (er.syscall === 'stat') set[p] = true;else self.emit('error', er); // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set;
        cb();
      }
    });
  });
};

Glob$1.prototype._mark = function (p) {
  return common.mark(this, p);
};

Glob$1.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f);
};

Glob$1.prototype.abort = function () {
  this.aborted = true;
  this.emit('abort');
};

Glob$1.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true;
    this.emit('pause');
  }
};

Glob$1.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume');
    this.paused = false;

    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0);

      this._emitQueue.length = 0;

      for (var i = 0; i < eq.length; i++) {
        var e = eq[i];

        this._emitMatch(e[0], e[1]);
      }
    }

    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0);

      this._processQueue.length = 0;

      for (var i = 0; i < pq.length; i++) {
        var p = pq[i];
        this._processing--;

        this._process(p[0], p[1], p[2], p[3]);
      }
    }
  }
};

Glob$1.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob$1);
  assert(typeof cb === 'function');
  if (this.aborted) return;
  this._processing++;

  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb]);

    return;
  } //console.error('PROCESS %d', this._processing, pattern)
  // Get the first [n] parts of pattern that are all strings.


  var n = 0;

  while (typeof pattern[n] === 'string') {
    n++;
  } // now n is the index of the first one that is *not* a string.
  // see if there's anything else


  var prefix;

  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb);

      return;

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null;
      break;

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/');
      break;
  }

  var remain = pattern.slice(n); // get the list of entries.

  var read;
  if (prefix === null) read = '.';else if (pathIsAbsolute(prefix) || pathIsAbsolute(pattern.join('/'))) {
    if (!prefix || !pathIsAbsolute(prefix)) prefix = '/' + prefix;
    read = prefix;
  } else read = prefix;

  var abs = this._makeAbs(read); //if ignored, skip _processing


  if (childrenIgnored$2(this, read)) return cb();
  var isGlobStar = remain[0] === minimatch_1.GLOBSTAR;
  if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
};

Glob$1.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this;

  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
  });
};

Glob$1.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  // if the abs isn't a dir, then nothing can match!
  if (!entries) return cb(); // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.

  var pn = remain[0];
  var negate = !!this.minimatch.negate;
  var rawGlob = pn._glob;
  var dotOk = this.dot || rawGlob.charAt(0) === '.';
  var matchedEntries = [];

  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];

    if (e.charAt(0) !== '.' || dotOk) {
      var m;

      if (negate && !prefix) {
        m = !e.match(pn);
      } else {
        m = e.match(pn);
      }

      if (m) matchedEntries.push(e);
    }
  } //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)


  var len = matchedEntries.length; // If there are no matched entries, then nothing matches.

  if (len === 0) return cb(); // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index]) this.matches[index] = Object.create(null);

    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];

      if (prefix) {
        if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path$1.join(this.root, e);
      }

      this._emitMatch(index, e);
    } // This was the last one, and no stats were needed


    return cb();
  } // now test all matched entries as stand-ins for that part
  // of the pattern.


  remain.shift();

  for (var i = 0; i < len; i++) {
    var e = matchedEntries[i];

    if (prefix) {
      if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;
    }

    this._process([e].concat(remain), index, inGlobStar, cb);
  }

  cb();
};

Glob$1.prototype._emitMatch = function (index, e) {
  if (this.aborted) return;
  if (isIgnored$2(this, e)) return;

  if (this.paused) {
    this._emitQueue.push([index, e]);

    return;
  }

  var abs = pathIsAbsolute(e) ? e : this._makeAbs(e);
  if (this.mark) e = this._mark(e);
  if (this.absolute) e = abs;
  if (this.matches[index][e]) return;

  if (this.nodir) {
    var c = this.cache[abs];
    if (c === 'DIR' || Array.isArray(c)) return;
  }

  this.matches[index][e] = true;
  var st = this.statCache[abs];
  if (st) this.emit('stat', e, st);
  this.emit('match', e);
};

Glob$1.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted) return; // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation

  if (this.follow) return this._readdir(abs, false, cb);
  var lstatkey = 'lstat\\\\0' + abs;
  var self = this;
  var lstatcb = inflight_1(lstatkey, lstatcb_);
  if (lstatcb) node_fs.lstat(abs, lstatcb);

  function lstatcb_(er, lstat) {
    if (er && er.code === 'ENOENT') return cb();
    var isSym = lstat && lstat.isSymbolicLink();
    self.symlinks[abs] = isSym; // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.

    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE';
      cb();
    } else self._readdir(abs, false, cb);
  }
};

Glob$1.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted) return;
  cb = inflight_1('readdir\\\\0' + abs + '\\\\0' + inGlobStar, cb);
  if (!cb) return; //console.error('RD %j %j', +inGlobStar, abs)

  if (inGlobStar && !ownProp$2(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);

  if (ownProp$2(this.cache, abs)) {
    var c = this.cache[abs];
    if (!c || c === 'FILE') return cb();
    if (Array.isArray(c)) return cb(null, c);
  }

  node_fs.readdir(abs, readdirCb(this, abs, cb));
};

function readdirCb(self, abs, cb) {
  return function (er, entries) {
    if (er) self._readdirError(abs, er, cb);else self._readdirEntries(abs, entries, cb);
  };
}

Glob$1.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted) return; // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.

  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (abs === '/') e = abs + e;else e = abs + '/' + e;
      this.cache[e] = true;
    }
  }

  this.cache[abs] = entries;
  return cb(null, entries);
};

Glob$1.prototype._readdirError = function (f, er, cb) {
  if (this.aborted) return; // handle errors, and cache the information

  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205

    case 'ENOTDIR':
      // totally normal. means it *does* exist.
      var abs = this._makeAbs(f);

      this.cache[abs] = 'FILE';

      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd);
        error.path = this.cwd;
        error.code = er.code;
        this.emit('error', error);
        this.abort();
      }

      break;

    case 'ENOENT': // not terribly unusual

    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false;
      break;

    default:
      // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false;

      if (this.strict) {
        this.emit('error', er); // If the error is handled, then we abort
        // if not, we threw out of here

        this.abort();
      }

      if (!this.silent) console.error('glob error', er);
      break;
  }

  return cb();
};

Glob$1.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this;

  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
  });
};

Glob$1.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)
  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries) return cb(); // test without the globstar, and with every child both below
  // and replacing the globstar.

  var remainWithoutGlobStar = remain.slice(1);
  var gspref = prefix ? [prefix] : [];
  var noGlobStar = gspref.concat(remainWithoutGlobStar); // the noGlobStar pattern exits the inGlobStar state

  this._process(noGlobStar, index, false, cb);

  var isSym = this.symlinks[abs];
  var len = entries.length; // If it's a symlink, and we're in a globstar, then stop

  if (isSym && inGlobStar) return cb();

  for (var i = 0; i < len; i++) {
    var e = entries[i];
    if (e.charAt(0) === '.' && !this.dot) continue; // these two cases enter the inGlobStar state

    var instead = gspref.concat(entries[i], remainWithoutGlobStar);

    this._process(instead, index, true, cb);

    var below = gspref.concat(entries[i], remain);

    this._process(below, index, true, cb);
  }

  cb();
};

Glob$1.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this;

  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb);
  });
};

Glob$1.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
  //console.error('ps2', prefix, exists)
  if (!this.matches[index]) this.matches[index] = Object.create(null); // If it doesn't exist, then just mark the lack of results

  if (!exists) return cb();

  if (prefix && pathIsAbsolute(prefix) && !this.nomount) {
    var trail = /[\\\\/\\\\\\\\]$/.test(prefix);

    if (prefix.charAt(0) === '/') {
      prefix = path$1.join(this.root, prefix);
    } else {
      prefix = path$1.resolve(this.root, prefix);
      if (trail) prefix += '/';
    }
  } // Mark this as a match


  this._emitMatch(index, prefix);

  cb();
}; // Returns either 'DIR', 'FILE', or false


Glob$1.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f);

  var needDir = f.slice(-1) === '/';
  if (f.length > this.maxLength) return cb();

  if (!this.stat && ownProp$2(this.cache, abs)) {
    var c = this.cache[abs];
    if (Array.isArray(c)) c = 'DIR'; // It exists, but maybe not how we need it

    if (!needDir || c === 'DIR') return cb(null, c);
    if (needDir && c === 'FILE') return cb(); // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var stat = this.statCache[abs];

  if (stat !== undefined) {
    if (stat === false) return cb(null, stat);else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE';
      if (needDir && type === 'FILE') return cb();else return cb(null, type, stat);
    }
  }

  var self = this;
  var statcb = inflight_1('stat\\\\0' + abs, lstatcb_);
  if (statcb) node_fs.lstat(abs, statcb);

  function lstatcb_(er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return node_fs.stat(abs, function (er, stat) {
        if (er) self._stat2(f, abs, null, lstat, cb);else self._stat2(f, abs, er, stat, cb);
      });
    } else {
      self._stat2(f, abs, er, lstat, cb);
    }
  }
};

Glob$1.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false;
    return cb();
  }

  var needDir = f.slice(-1) === '/';
  this.statCache[abs] = stat;
  if (abs.slice(-1) === '/' && stat && !stat.isDirectory()) return cb(null, false, stat);
  var c = true;
  if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';
  this.cache[abs] = this.cache[abs] || c;
  if (needDir && c === 'FILE') return cb();
  return cb(null, c, stat);
};

const {
  sync: sync$1
} = glob_1;

function commonjsRequire() {
  throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var lookup$1 = [];
var revLookup$1 = [];
var Arr$1 = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited$1 = false;

function init$1() {
  inited$1 = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup$1[i] = code[i];
    revLookup$1[code.charCodeAt(i)] = i;
  }

  revLookup$1['-'.charCodeAt(0)] = 62;
  revLookup$1['_'.charCodeAt(0)] = 63;
}

function toByteArray$1(b64) {
  if (!inited$1) {
    init$1();
  }

  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice


  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data

  arr = new Arr$1(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 18 | revLookup$1[b64.charCodeAt(i + 1)] << 12 | revLookup$1[b64.charCodeAt(i + 2)] << 6 | revLookup$1[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 2 | revLookup$1[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 10 | revLookup$1[b64.charCodeAt(i + 1)] << 4 | revLookup$1[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64$1(num) {
  return lookup$1[num >> 18 & 0x3F] + lookup$1[num >> 12 & 0x3F] + lookup$1[num >> 6 & 0x3F] + lookup$1[num & 0x3F];
}

function encodeChunk$1(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64$1(tmp));
  }

  return output.join('');
}

function fromByteArray$1(uint8) {
  if (!inited$1) {
    init$1();
  }

  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk$1(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup$1[tmp >> 2];
    output += lookup$1[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup$1[tmp >> 10];
    output += lookup$1[tmp >> 4 & 0x3F];
    output += lookup$1[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);
  return parts.join('');
}

function read$1(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}

function write$1(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString$1 = {}.toString;

var isArray$3 = Array.isArray || function (arr) {
  return toString$1.call(arr) == '[object Array]';
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */


var INSPECT_MAX_BYTES$1 = 50;
/**
 * If \`Buffer.TYPED_ARRAY_SUPPORT\`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to \`Uint8Array\` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the \`TypedArray.prototype.subarray\` function.
 *
 *   - IE10 has a broken \`TypedArray.prototype.subarray\` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set \`Buffer.TYPED_ARRAY_SUPPORT\` to \`false\` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer$1.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : true;

function kMaxLength$1() {
  return Buffer$1.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer$1(that, length) {
  if (kMaxLength$1() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented \`Uint8Array\` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer$1(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of \`Uint8Array\` that have their
 * prototype changed to \`Buffer.prototype\`. Furthermore, \`Buffer\` is a subclass of
 * \`Uint8Array\`, so the returned instances will have all the node \`Buffer\` methods
 * and the \`Uint8Array\` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The \`Uint8Array\` prototype remains unmodified.
 */


function Buffer$1(arg, encodingOrOffset, length) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe$1(this, arg);
  }

  return from$1(this, arg, encodingOrOffset, length);
}

Buffer$1.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer$1._augment = function (arr) {
  arr.__proto__ = Buffer$1.prototype;
  return arr;
};

function from$1(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('\\"value\\" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer$1(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString$1(that, value, encodingOrOffset);
  }

  return fromObject$1(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer$1.from = function (value, encodingOrOffset, length) {
  return from$1(null, value, encodingOrOffset, length);
};

if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;
}

function assertSize$1(size) {
  if (typeof size !== 'number') {
    throw new TypeError('\\"size\\" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('\\"size\\" argument must not be negative');
  }
}

function alloc$1(that, size, fill, encoding) {
  assertSize$1(size);

  if (size <= 0) {
    return createBuffer$1(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer$1(that, size).fill(fill, encoding) : createBuffer$1(that, size).fill(fill);
  }

  return createBuffer$1(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer$1.alloc = function (size, fill, encoding) {
  return alloc$1(null, size, fill, encoding);
};

function allocUnsafe$1(that, size) {
  assertSize$1(size);
  that = createBuffer$1(that, size < 0 ? 0 : checked$1(size) | 0);

  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer$1.allocUnsafe = function (size) {
  return allocUnsafe$1(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer$1.allocUnsafeSlow = function (size) {
  return allocUnsafe$1(null, size);
};

function fromString$1(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError('\\"encoding\\" must be a valid string encoding');
  }

  var length = byteLength$1(string, encoding) | 0;
  that = createBuffer$1(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike$1(that, array) {
  var length = array.length < 0 ? 0 : checked$1(array.length) | 0;
  that = createBuffer$1(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer$1(that, array, byteOffset, length) {
  array.byteLength; // this throws if \`array\` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\\\\'offset\\\\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\\\\'length\\\\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented \`Uint8Array\` instance, for best performance
    that = array;
    that.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike$1(that, array);
  }

  return that;
}

function fromObject$1(that, obj) {
  if (internalIsBuffer$1(obj)) {
    var len = checked$1(obj.length) | 0;
    that = createBuffer$1(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan$1(obj.length)) {
        return createBuffer$1(that, 0);
      }

      return fromArrayLike$1(that, obj);
    }

    if (obj.type === 'Buffer' && isArray$3(obj.data)) {
      return fromArrayLike$1(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked$1(length) {
  // Note: cannot use \`length < kMaxLength()\` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength$1()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength$1().toString(16) + ' bytes');
  }

  return length | 0;
}

Buffer$1.isBuffer = isBuffer$1;

function internalIsBuffer$1(b) {
  return !!(b != null && b._isBuffer);
}

Buffer$1.compare = function compare(a, b) {
  if (!internalIsBuffer$1(a) || !internalIsBuffer$1(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer$1.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer$1.concat = function concat(list, length) {
  if (!isArray$3(list)) {
    throw new TypeError('\\"list\\" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer$1.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer$1.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!internalIsBuffer$1(buf)) {
      throw new TypeError('\\"list\\" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength$1(string, encoding) {
  if (internalIsBuffer$1(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes$1(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes$1(string).length;

      default:
        if (loweredCase) return utf8ToBytes$1(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer$1.byteLength = byteLength$1;

function slowToString$1(encoding, start, end) {
  var loweredCase = false; // No need to verify that \\"this.length <= MAX_UINT32\\" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice$1(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice$1(this, start, end);

      case 'ascii':
        return asciiSlice$1(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice$1(this, start, end);

      case 'base64':
        return base64Slice$1(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice$1(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by \`Buffer.isBuffer\` and \`is-buffer\` (in Safari 5-7) to detect
// Buffer instances.


Buffer$1.prototype._isBuffer = true;

function swap$1(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer$1.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap$1(this, i, i + 1);
  }

  return this;
};

Buffer$1.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap$1(this, i, i + 3);
    swap$1(this, i + 1, i + 2);
  }

  return this;
};

Buffer$1.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap$1(this, i, i + 7);
    swap$1(this, i + 1, i + 6);
    swap$1(this, i + 2, i + 5);
    swap$1(this, i + 3, i + 4);
  }

  return this;
};

Buffer$1.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice$1(this, 0, length);
  return slowToString$1.apply(this, arguments);
};

Buffer$1.prototype.equals = function equals(b) {
  if (!internalIsBuffer$1(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer$1.compare(this, b) === 0;
};

Buffer$1.prototype.inspect = function inspect() {
  var str = '';
  var max = INSPECT_MAX_BYTES$1;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer$1.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer$1(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of \`val\` in \`buffer\` at offset >= \`byteOffset\`,
// OR the last index of \`val\` in \`buffer\` at offset <= \`byteOffset\`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into \`buffer\`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf$1(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, \\"foo\\", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer$1.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (internalIsBuffer$1(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf$1(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf$1(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf$1(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer$1.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer$1.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf$1(this, val, byteOffset, encoding, true);
};

Buffer$1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf$1(this, val, byteOffset, encoding, false);
};

function hexWrite$1(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write$1(buf, string, offset, length) {
  return blitBuffer$1(utf8ToBytes$1(string, buf.length - offset), buf, offset, length);
}

function asciiWrite$1(buf, string, offset, length) {
  return blitBuffer$1(asciiToBytes$1(string), buf, offset, length);
}

function latin1Write$1(buf, string, offset, length) {
  return asciiWrite$1(buf, string, offset, length);
}

function base64Write$1(buf, string, offset, length) {
  return blitBuffer$1(base64ToBytes$1(string), buf, offset, length);
}

function ucs2Write$1(buf, string, offset, length) {
  return blitBuffer$1(utf16leToBytes$1(string, buf.length - offset), buf, offset, length);
}

Buffer$1.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite$1(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write$1(this, string, offset, length);

      case 'ascii':
        return asciiWrite$1(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write$1(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write$1(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write$1(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer$1.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice$1(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray$1(buf);
  } else {
    return fromByteArray$1(buf.slice(start, end));
  }
}

function utf8Slice$1(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray$1(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH$1 = 0x1000;

function decodeCodePointsArray$1(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH$1) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid \\"call stack size exceeded\\".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH$1));
  }

  return res;
}

function asciiSlice$1(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice$1(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice$1(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex$1(buf[i]);
  }

  return out;
}

function utf16leSlice$1(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer$1.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$1(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset$1(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer$1.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset$1(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer$1.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset$1(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer$1.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 1, this.length);
  return this[offset];
};

Buffer$1.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer$1.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer$1.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer$1.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer$1.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset$1(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer$1.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset$1(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer$1.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer$1.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer$1.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer$1.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer$1.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer$1.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 4, this.length);
  return read$1(this, offset, true, 23, 4);
};

Buffer$1.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 4, this.length);
  return read$1(this, offset, false, 23, 4);
};

Buffer$1.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 8, this.length);
  return read$1(this, offset, true, 52, 8);
};

Buffer$1.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset$1(offset, 8, this.length);
  return read$1(this, offset, false, 52, 8);
};

function checkInt$1(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer$1(buf)) throw new TypeError('\\"buffer\\" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('\\"value\\" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer$1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt$1(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer$1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt$1(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer$1.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 1, 0xff, 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16$1(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer$1.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 2, 0xffff, 0);

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16$1(this, value, offset, true);
  }

  return offset + 2;
};

Buffer$1.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 2, 0xffff, 0);

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16$1(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32$1(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer$1.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32$1(this, value, offset, true);
  }

  return offset + 4;
};

Buffer$1.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32$1(this, value, offset, false);
  }

  return offset + 4;
};

Buffer$1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt$1(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer$1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt$1(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer$1.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer$1.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16$1(this, value, offset, true);
  }

  return offset + 2;
};

Buffer$1.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16$1(this, value, offset, false);
  }

  return offset + 2;
};

Buffer$1.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32$1(this, value, offset, true);
  }

  return offset + 4;
};

Buffer$1.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt$1(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32$1(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754$1(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat$1(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754$1(buf, value, offset, 4);
  }

  write$1(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer$1.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat$1(this, value, offset, true, noAssert);
};

Buffer$1.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat$1(this, value, offset, false, noAssert);
};

function writeDouble$1(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754$1(buf, value, offset, 8);
  }

  write$1(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer$1.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble$1(this, value, offset, true, noAssert);
};

Buffer$1.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble$1(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer$1.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer$1.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer$1(val) ? val : utf8ToBytes$1(new Buffer$1(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE$1 = /[^+\\\\/0-9A-Za-z-_]/g;

function base64clean$1(str) {
  // Node strips out invalid characters like \\\\n and \\\\t from the string, base64-js does not
  str = stringtrim$1(str).replace(INVALID_BASE64_RE$1, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim$1(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\\\\s+|\\\\s+$/g, '');
}

function toHex$1(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes$1(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes$1(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes$1(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes$1(str) {
  return toByteArray$1(base64clean$1(str));
}

function blitBuffer$1(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan$1(val) {
  return val !== val; // eslint-disable-line no-self-compare
} // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually


function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer$1(obj) || isSlowBuffer$1(obj));
}

function isFastBuffer$1(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer$1(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer$1(obj.slice(0, 0));
}

var shellMethods = Object.create(shell$1.__moduleExports); // objectAssign(target_obj, source_obj1 [, source_obj2 ...])
// \\"Ponyfill\\" for Object.assign
//    objectAssign({A:1}, {b:2}, {c:3}) returns {A:1, b:2, c:3}

var objectAssign = typeof Object.assign === 'function' ? Object.assign : function objectAssign(target) {
  var sources = [].slice.call(arguments, 1);
  sources.forEach(function (source) {
    Object.keys(source).forEach(function (key) {
      target[key] = source[key];
    });
  });
  return target;
};
var extend$1 = objectAssign; // Check if we're running under electron

var isElectron = Boolean(process$1.versions.electron); // Module globals (assume no execPath by default)

var DEFAULT_CONFIG = {
  fatal: false,
  globOptions: {},
  maxdepth: 255,
  noglob: false,
  silent: false,
  verbose: false,
  execPath: null,
  bufLength: 64 * 1024 // 64KB

};
var config = {
  reset: function () {
    objectAssign(this, DEFAULT_CONFIG);

    if (!isElectron) {
      this.execPath = process$1.execPath;
    }
  },
  resetForTesting: function () {
    this.reset();
    this.silent = true;
  }
};
config.reset();
var config_1 = config;
var state = {
  error: null,
  errorCode: 0,
  currentCmd: 'shell.js',
  tempDir: null
};
var state_1 = state; // This is populated by calls to commonl.wrap()

var pipeMethods = []; // Reliably test if something is any sort of javascript object

function isObject$2(a) {
  return typeof a === 'object' && a !== null;
}

var isObject_1 = isObject$2;

function log$1() {
  /* istanbul ignore next */
  if (!config.silent) {
    console.error.apply(console, arguments);
  }
}

var log_1 = log$1; // Converts strings to be equivalent across all platforms. Primarily responsible
// for making sure we use '/' instead of '\\\\' as path separators, but this may be
// expanded in the future if necessary

function convertErrorOutput(msg) {
  if (typeof msg !== 'string') {
    throw new TypeError('input must be a string');
  }

  return msg.replace(/\\\\\\\\/g, '/');
}

var convertErrorOutput_1 = convertErrorOutput; // Shows error message. Throws if config.fatal is true

function error$1(msg, _code, options) {
  // Validate input
  if (typeof msg !== 'string') throw new Error('msg must be a string');
  var DEFAULT_OPTIONS = {
    continue: false,
    code: 1,
    prefix: state.currentCmd + ': ',
    silent: false
  };

  if (typeof _code === 'number' && isObject$2(options)) {
    options.code = _code;
  } else if (isObject$2(_code)) {
    // no 'code'
    options = _code;
  } else if (typeof _code === 'number') {
    // no 'options'
    options = {
      code: _code
    };
  } else if (typeof _code !== 'number') {
    // only 'msg'
    options = {};
  }

  options = objectAssign({}, DEFAULT_OPTIONS, options);
  if (!state.errorCode) state.errorCode = options.code;
  var logEntry = convertErrorOutput(options.prefix + msg);
  state.error = state.error ? state.error + '\\\\n' : '';
  state.error += logEntry; // Throw an error, or log the entry

  if (config.fatal) throw new Error(logEntry);
  if (msg.length > 0 && !options.silent) log$1(logEntry);

  if (!options.continue) {
    throw {
      msg: 'earlyExit',
      retValue: new ShellString('', state.error, state.errorCode)
    };
  }
}

var error_1 = error$1; //@
//@ ### ShellString(str)
//@
//@ Examples:
//@
//@ \`\`\`javascript
//@ var foo = ShellString('hello world');
//@ \`\`\`
//@
//@ Turns a regular string into a string-like object similar to what each
//@ command returns. This has special methods, like \`.to()\` and \`.toEnd()\`

function ShellString(stdout, stderr, code) {
  var that;

  if (stdout instanceof Array) {
    that = stdout;
    that.stdout = stdout.join('\\\\n');
    if (stdout.length > 0) that.stdout += '\\\\n';
  } else {
    that = new String(stdout);
    that.stdout = stdout;
  }

  that.stderr = stderr;
  that.code = code; // A list of all commands that can appear on the right-hand side of a pipe
  // (populated by calls to common.wrap())

  pipeMethods.forEach(function (cmd) {
    that[cmd] = shellMethods[cmd].bind(that);
  });
  return that;
}

var ShellString_1 = ShellString; // Return the home directory in a platform-agnostic way, with consideration for
// older versions of node

function getUserHome() {
  var result;

  if (node_os.homedir) {
    result = node_os.homedir(); // node 3+
  } else {
    result = process$1.env['HOME'];
  }

  return result;
}

var getUserHome_1 = getUserHome; // Returns {'alice': true, 'bob': false} when passed a string and dictionary as follows:
//   parseOptions('-a', {'a':'alice', 'b':'bob'});
// Returns {'reference': 'string-value', 'bob': false} when passed two dictionaries of the form:
//   parseOptions({'-r': 'string-value'}, {'r':'reference', 'b':'bob'});

function parseOptions(opt, map, errorOptions) {
  // Validate input
  if (typeof opt !== 'string' && !isObject$2(opt)) {
    throw new Error('options must be strings or key-value pairs');
  } else if (!isObject$2(map)) {
    throw new Error('parseOptions() internal error: map must be an object');
  } else if (errorOptions && !isObject$2(errorOptions)) {
    throw new Error('parseOptions() internal error: errorOptions must be object');
  } // All options are false by default


  var options = {};
  Object.keys(map).forEach(function (letter) {
    var optName = map[letter];

    if (optName[0] !== '!') {
      options[optName] = false;
    }
  });
  if (opt === '') return options; // defaults

  if (typeof opt === 'string') {
    if (opt[0] !== '-') {
      error$1(\\"Options string must start with a '-'\\", errorOptions || {});
    } // e.g. chars = ['R', 'f']


    var chars = opt.slice(1).split('');
    chars.forEach(function (c) {
      if (c in map) {
        var optionName = map[c];

        if (optionName[0] === '!') {
          options[optionName.slice(1)] = false;
        } else {
          options[optionName] = true;
        }
      } else {
        error$1('option not recognized: ' + c, errorOptions || {});
      }
    });
  } else {
    // opt is an Object
    Object.keys(opt).forEach(function (key) {
      // key is a string of the form '-r', '-d', etc.
      var c = key[1];

      if (c in map) {
        var optionName = map[c];
        options[optionName] = opt[key]; // assign the given value
      } else {
        error$1('option not recognized: ' + c, errorOptions || {});
      }
    });
  }

  return options;
}

var parseOptions_1 = parseOptions; // Expands wildcards with matching (ie. existing) file names.
// For example:
//   expand(['file*.js']) = ['file1.js', 'file2.js', ...]
//   (if the files 'file1.js', 'file2.js', etc, exist in the current dir)

function expand$1(list) {
  if (!Array.isArray(list)) {
    throw new TypeError('must be an array');
  }

  var expanded = [];
  list.forEach(function (listEl) {
    // Don't expand non-strings
    if (typeof listEl !== 'string') {
      expanded.push(listEl);
    } else {
      var ret;

      try {
        ret = sync$1(listEl, config.globOptions); // if nothing matched, interpret the string literally

        ret = ret.length > 0 ? ret : [listEl];
      } catch (e) {
        // if glob fails, interpret the string literally
        ret = [listEl];
      }

      expanded = expanded.concat(ret);
    }
  });
  return expanded;
}

var expand_1 = expand$1; // Normalizes Buffer creation, using Buffer.alloc if possible.
// Also provides a good default buffer length for most use cases.

var buffer = typeof Buffer$1.alloc === 'function' ? function (len) {
  return Buffer$1.alloc(len || config.bufLength);
} : function (len) {
  return new Buffer$1(len || config.bufLength);
};
var buffer_1 = buffer; // Normalizes _unlinkSync() across platforms to match Unix behavior, i.e.
// file can be unlinked even if it's read-only, see https://github.com/joyent/node/issues/3006

function unlinkSync(file) {
  try {
    node_fs.unlinkSync(file);
  } catch (e) {
    // Try to override file permission

    /* istanbul ignore next */
    if (e.code === 'EPERM') {
      node_fs.chmodSync(file, '0666');
      node_fs.unlinkSync(file);
    } else {
      throw e;
    }
  }
}

var unlinkSync_1 = unlinkSync; // e.g. 'shelljs_a5f185d0443ca...'

function randomFileName() {
  function randomHash(count) {
    if (count === 1) {
      return parseInt(16 * Math.random(), 10).toString(16);
    }

    var hash = '';

    for (var i = 0; i < count; i++) {
      hash += randomHash(1);
    }

    return hash;
  }

  return 'shelljs_' + randomHash(20);
}

var randomFileName_1 = randomFileName; // Common wrapper for all Unix-like commands that performs glob expansion,
// command-logging, and other nice things

function wrap(cmd, fn, options) {
  options = options || {};

  if (options.canReceivePipe) {
    pipeMethods.push(cmd);
  }

  return function () {
    var retValue = null;
    state.currentCmd = cmd;
    state.error = null;
    state.errorCode = 0;

    try {
      var args = [].slice.call(arguments, 0); // Log the command to stderr, if appropriate

      if (config.verbose) {
        console.error.apply(console, [cmd].concat(args));
      } // If this is coming from a pipe, let's set the pipedValue (otherwise, set
      // it to the empty string)


      state.pipedValue = this && typeof this.stdout === 'string' ? this.stdout : '';

      if (options.unix === false) {
        // this branch is for exec()
        retValue = fn.apply(this, args);
      } else {
        // and this branch is for everything else
        if (isObject$2(args[0]) && args[0].constructor.name === 'Object') {// a no-op, allowing the syntax \`touch({'-r': file}, ...)\`
        } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length <= 1 || args[0][0] !== '-') {
          args.unshift(''); // only add dummy option if '-option' not already present
        } // flatten out arrays that are arguments, to make the syntax:
        //    \`cp([file1, file2, file3], dest);\`
        // equivalent to:
        //    \`cp(file1, file2, file3, dest);\`


        args = args.reduce(function (accum, cur) {
          if (Array.isArray(cur)) {
            return accum.concat(cur);
          }

          accum.push(cur);
          return accum;
        }, []); // Convert ShellStrings (basically just String objects) to regular strings

        args = args.map(function (arg) {
          if (isObject$2(arg) && arg.constructor.name === 'String') {
            return arg.toString();
          }

          return arg;
        }); // Expand the '~' if appropriate

        var homeDir = getUserHome();
        args = args.map(function (arg) {
          if (typeof arg === 'string' && arg.slice(0, 2) === '~/' || arg === '~') {
            return arg.replace(/^~/, homeDir);
          }

          return arg;
        }); // Perform glob-expansion on all arguments after globStart, but preserve
        // the arguments before it (like regexes for sed and grep)

        if (!config.noglob && options.allowGlobbing === true) {
          args = args.slice(0, options.globStart).concat(expand$1(args.slice(options.globStart)));
        }

        try {
          // parse options if options are provided
          if (isObject$2(options.cmdOptions)) {
            args[0] = parseOptions(args[0], options.cmdOptions);
          }

          retValue = fn.apply(this, args);
        } catch (e) {
          /* istanbul ignore else */
          if (e.msg === 'earlyExit') {
            retValue = e.retValue;
          } else {
            throw e; // this is probably a bug that should be thrown up the call stack
          }
        }
      }
    } catch (e) {
      /* istanbul ignore next */
      if (!state.error) {
        // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...
        console.error('ShellJS: internal error');
        console.error(e.stack || e);
        process$1.exit(1);
      }

      if (config.fatal) throw e;
    }

    if (options.wrapOutput && (typeof retValue === 'string' || Array.isArray(retValue))) {
      retValue = new ShellString(retValue, state.error, state.errorCode);
    }

    state.currentCmd = 'shell.js';
    return retValue;
  };
} // wrap


var wrap_1 = wrap; // This returns all the input that is piped into the current command (or the
// empty string, if this isn't on the right-hand side of a pipe

function _readFromPipe() {
  return state.pipedValue;
}

var readFromPipe = _readFromPipe;
var DEFAULT_WRAP_OPTIONS = {
  allowGlobbing: true,
  canReceivePipe: false,
  cmdOptions: false,
  globStart: 1,
  pipeOnly: false,
  unix: true,
  wrapOutput: true,
  overWrite: false
}; // Register a new ShellJS command

function _register(name, implementation, wrapOptions) {
  wrapOptions = wrapOptions || {}; // If an option isn't specified, use the default

  wrapOptions = objectAssign({}, DEFAULT_WRAP_OPTIONS, wrapOptions);

  if (shell$1.__moduleExports[name] && !wrapOptions.overWrite) {
    throw new Error('unable to overwrite \`' + name + '\` command');
  }

  if (wrapOptions.pipeOnly) {
    wrapOptions.canReceivePipe = true;
    shellMethods[name] = wrap(name, implementation, wrapOptions);
  } else {
    shell$1.__moduleExports[name] = wrap(name, implementation, wrapOptions);
  }
}

var register = _register;
var common$1 = {
  extend: extend$1,
  config: config_1,
  state: state_1,
  isObject: isObject_1,
  log: log_1,
  convertErrorOutput: convertErrorOutput_1,
  error: error_1,
  ShellString: ShellString_1,
  getUserHome: getUserHome_1,
  parseOptions: parseOptions_1,
  expand: expand_1,
  buffer: buffer_1,
  unlinkSync: unlinkSync_1,
  randomFileName: randomFileName_1,
  wrap: wrap_1,
  readFromPipe: readFromPipe,
  register: register
};
var commands = ['cat', 'cd', 'chmod', 'cp', 'dirs', 'echo', 'exec', 'find', 'grep', 'head', 'ln', 'ls', 'mkdir', 'mv', 'pwd', 'rm', 'sed', 'set', 'sort', 'tail', 'tempdir', 'test', 'to', 'toEnd', 'touch', 'uniq', 'which']; //@
//@ ### error()
//@ Tests if error occurred in the last command. Returns a truthy value if an
//@ error returned and a falsy value otherwise.
//@
//@ **Note**: do not rely on the
//@ return value to be an error message. If you need the last error message, use
//@ the \`.stderr\` attribute from the last command's return value instead.

function error$1$1() {
  return common$1.state.error;
}

var error_1$1 = error$1$1; //
// ShellJS
// Unix shell commands on top of Node's API
//
// Copyright (c) 2012 Artur Adib
// http://github.com/shelljs/shelljs
//
//@
//@ All commands run synchronously, unless otherwise stated.
//@ All commands accept standard bash globbing characters (\`*\`, \`?\`, etc.),
//@ compatible with the [node glob module](https://github.com/isaacs/node-glob).
//@
//@ For less-commonly used commands and features, please check out our [wiki
//@ page](https://github.com/shelljs/shelljs/wiki).
//@
// Include the docs for all the default commands
//@commands
// Load all default commands

commands.forEach(function (command) {
  commonjsRequire();
}); //@
//@ ### exit(code)
//@ Exits the current process with the given exit code.

var exit = process$1.exit; //@include ./src/error

var error$2 = error_1$1; //@include ./src/common

var ShellString$1 = common$1.ShellString; //@
//@ ### env['VAR_NAME']
//@ Object containing environment variables (both getter and setter). Shortcut
//@ to process.env.

var env = process$1.env; //@
//@ ### Pipes
//@
//@ Examples:
//@
//@ \`\`\`javascript
//@ grep('foo', 'file1.txt', 'file2.txt').sed(/o/g, 'a').to('output.txt');
//@ echo('files with o\\\\'s in the name:\\\\n' + ls().grep('o'));
//@ cat('test.js').exec('node'); // pipe to exec() call
//@ \`\`\`
//@
//@ Commands can send their output to another command in a pipe-like fashion.
//@ \`sed\`, \`grep\`, \`cat\`, \`exec\`, \`to\`, and \`toEnd\` can appear on the right-hand
//@ side of a pipe. Pipes can be chained.
//@
//@ ## Configuration
//@

var config$1 = common$1.config; //@
//@ ### config.silent
//@
//@ Example:
//@
//@ \`\`\`javascript
//@ var sh = require('shelljs');
//@ var silentState = sh.config.silent; // save old silent state
//@ sh.config.silent = true;
//@ /* ... */
//@ sh.config.silent = silentState; // restore old silent state
//@ \`\`\`
//@
//@ Suppresses all command output if \`true\`, except for \`echo()\` calls.
//@ Default is \`false\`.
//@
//@ ### config.fatal
//@
//@ Example:
//@
//@ \`\`\`javascript
//@ require('shelljs/global');
//@ config.fatal = true; // or set('-e');
//@ cp('this_file_does_not_exist', '/dev/null'); // throws Error here
//@ /* more commands... */
//@ \`\`\`
//@
//@ If \`true\` the script will throw a Javascript error when any shell.js
//@ command encounters an error. Default is \`false\`. This is analogous to
//@ Bash's \`set -e\`
//@
//@ ### config.verbose
//@
//@ Example:
//@
//@ \`\`\`javascript
//@ config.verbose = true; // or set('-v');
//@ cd('dir/');
//@ rm('-rf', 'foo.txt', 'bar.txt');
//@ exec('echo hello');
//@ \`\`\`
//@
//@ Will print each command as follows:
//@
//@ \`\`\`
//@ cd dir/
//@ rm -rf foo.txt bar.txt
//@ exec echo hello
//@ \`\`\`
//@
//@ ### config.globOptions
//@
//@ Example:
//@
//@ \`\`\`javascript
//@ config.globOptions = {nodir: true};
//@ \`\`\`
//@
//@ Use this value for calls to \`glob.sync()\` instead of the default options.
//@
//@ ### config.reset()
//@
//@ Example:
//@
//@ \`\`\`javascript
//@ var shell = require('shelljs');
//@ // Make changes to shell.config, and do stuff...
//@ /* ... */
//@ shell.config.reset(); // reset to original state
//@ // Do more stuff, but with original settings
//@ /* ... */
//@ \`\`\`
//@
//@ Reset shell.config to the defaults:
//@
//@ \`\`\`javascript
//@ {
//@   fatal: false,
//@   globOptions: {},
//@   maxdepth: 255,
//@   noglob: false,
//@   silent: false,
//@   verbose: false,
//@ }
//@ \`\`\`

var shell$1 = {
  exit: exit,
  error: error$2,
  ShellString: ShellString$1,
  env: env,
  config: config$1
};

/**
 * Helpers.
 */
var s = 1000;
var m$1 = s * 60;
var h = m$1 * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given \`val\`.
 *
 * Options:
 *
 *  - \`long\` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms = function ms(val, options) {
  options = options || {};
  var type = typeof val;

  if (type === 'string' && val.length > 0) {
    return parse$1(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given \`str\` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse$1(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\\\\d+)?\\\\.?\\\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m$1;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for \`ms\`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (msAbs >= m$1) {
    return Math.round(ms / m$1) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for \`ms\`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }

  if (msAbs >= m$1) {
    return plural(ms, msAbs, m$1, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

function createCommonjsModule$4(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of \`debug()\`.
 */


function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = ms;
  Object.keys(env).forEach(key => {
    createDebug[key] = env[key];
  });
  /**
  * Active \`debug\` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special \\"%n\\" handling functions, for the debug \\"format\\" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. \\"n\\" and \\"N\\".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    let hash = 0;

    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given \`namespace\`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    let prevTime;

    function debug(...args) {
      // Disabled?
      if (!debug.enabled) {
        return;
      }

      const self = debug; // Set \`diff\` timestamp

      const curr = Number(new Date());
      const ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any \`formatters\` transformations


      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        const formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          const val = args[index];
          match = formatter.call(self, val); // Now we need to remove \`args[index]\` since it's inlined in the \`format\`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      const logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    const index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\\\s,]+/);
    const len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\\\\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      const instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)].join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    let i;
    let len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\\\.\\\\*\\\\?$/, '*');
  }
  /**
  * Coerce \`val\`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

var common$2 = setup;
var browser$1 = createCommonjsModule$4(function (module, exports) {
  /* eslint-env browser */

  /**
   * This is the web browser implementation of \`debug()\`.
   */
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  /**
   * Colors.
   */

  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support \\"%c\\" CSS customizations.
   *
   * TODO: add a \`localStorage\` variable to explicitly enable/disable colors
   */
  // eslint-disable-next-line complexity

  function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
      return true;
    } // Internet Explorer and Edge do not support colors.


    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\\\/(\\\\d+)/)) {
      return false;
    } // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\\\/(\\\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\\\/(\\\\d+)/);
  }
  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */


  function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

    if (!this.useColors) {
      return;
    }

    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit'); // The final \\"%c\\" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into

    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, match => {
      if (match === '%%') {
        return;
      }

      index++;

      if (match === '%c') {
        // We only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  /**
   * Invokes \`console.log()\` when available.
   * No-op when \`console.log\` is not a \\"function\\".
   *
   * @api public
   */


  function log(...args) {
    // This hackery is required for IE8/9, where
    // the \`console.log\` function doesn't have 'apply'
    return typeof console === 'object' && console.log && console.log(...args);
  }
  /**
   * Save \`namespaces\`.
   *
   * @param {String} namespaces
   * @api private
   */


  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem('debug', namespaces);
      } else {
        exports.storage.removeItem('debug');
      }
    } catch (error) {// Swallow
      // XXX (@Qix-) should we be logging these?
    }
  }
  /**
   * Load \`namespaces\`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */


  function load() {
    let r;

    try {
      r = exports.storage.getItem('debug');
    } catch (error) {} // Swallow
    // XXX (@Qix-) should we be logging these?
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = {}.DEBUG;
    }

    return r;
  }
  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */


  function localstorage() {
    try {
      // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
      // The Browser also has localStorage in the global context.
      return localStorage;
    } catch (error) {// Swallow
      // XXX (@Qix-) should we be logging these?
    }
  }

  module.exports = common$2(exports);
  const {
    formatters
  } = module.exports;
  /**
   * Map %j to \`JSON.stringify()\`, since no Web Inspectors do that by default.
   */

  formatters.j = function (v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return '[UnexpectedJSONParseError]: ' + error.message;
    }
  };
});
var browser_1 = browser$1.log;
var browser_2 = browser$1.formatArgs;
var browser_3 = browser$1.save;
var browser_4 = browser$1.load;
var browser_5 = browser$1.useColors;
var browser_6 = browser$1.storage;
var browser_7 = browser$1.colors;

/*
 * [Pika CDN - Package Error] \\"child_process\\" does not exist.
 *
 * A package that you requested from our CDN depends on a Node.js built-in module.
 * Node.js built-in modules (like \\"fs\\", \\"http\\", etc.) are Node.js-specific, and do
 * not exist in other environments like your web browser. Pika CDN polyfills these
 * modules whenever possible, but this one could not be polyfilled.
 * 
 * How to fix:
 *   - Let the package author know that you'd like to run their package in the browser.
 *   - Use https://pika.dev/ to find a more web-friendly alternative to the package that required this one.
 */
throw new Error('[Pika CDN - Package Error] The Node.js builtin module \\"child_process\\" does not exist outside of Node.js.');
var node_child_process = null;

const {
  spawnSync
} = node_child_process;

var src = string => {
  return new Promise(resolve => {
    {
      const command = \`(\\\\ncat << \\"EOF\\"\\\\n\${string}\\\\nEOF\\\\n) | less -R\`;
      spawnSync(command, [], {
        shell: true,
        stdio: 'inherit'
      });
    }
    resolve();
  });
};

const {
  exec
} = shell$1;

function commonjsRequire$1() {
  throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
} // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// \\"Software\\"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\\\\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)


function normalizeArray$3(parts, allowAboveRoot) {
  // if the path tries to go above the root, \`up\` ends up > 0
  var up = 0;

  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];

    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
} // Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.


var splitPathRe$3 = /^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;

var splitPath$3 = function splitPath(filename) {
  return splitPathRe$3.exec(filename).slice(1);
}; // path.resolve([from ...], to)
// posix version


function resolve$3() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : '/'; // Skip empty and invalid entries

    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  } // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)
  // Normalize the path


  resolvedPath = normalizeArray$3(filter$3(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
} // path.normalize(path)
// posix version


function normalize$3(path) {
  var isPathAbsolute = isAbsolute$3(path),
      trailingSlash = substr$3(path, -1) === '/'; // Normalize the path

  path = normalizeArray$3(filter$3(path.split('/'), function (p) {
    return !!p;
  }), !isPathAbsolute).join('/');

  if (!path && !isPathAbsolute) {
    path = '.';
  }

  if (path && trailingSlash) {
    path += '/';
  }

  return (isPathAbsolute ? '/' : '') + path;
} // posix version


function isAbsolute$3(path) {
  return path.charAt(0) === '/';
} // posix version


function join$3() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize$3(filter$3(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }

    return p;
  }).join('/'));
} // path.relative(from, to)
// posix version


function relative$3(from, to) {
  from = resolve$3(from).substr(1);
  to = resolve$3(to).substr(1);

  function trim(arr) {
    var start = 0;

    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;

    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;

  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];

  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join('/');
}

var sep$3 = '/';
var delimiter$3 = ':';

function dirname$3(path) {
  var result = splitPath$3(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
}

function basename$3(path, ext) {
  var f = splitPath$3(path)[2]; // TODO: make this comparison case-insensitive on windows?

  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }

  return f;
}

function extname$3(path) {
  return splitPath$3(path)[3];
}

var path$2 = {
  extname: extname$3,
  basename: basename$3,
  dirname: dirname$3,
  sep: sep$3,
  delimiter: delimiter$3,
  relative: relative$3,
  join: join$3,
  isAbsolute: isAbsolute$3,
  normalize: normalize$3,
  resolve: resolve$3
};

function filter$3(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }

  return res;
} // String.prototype.substr - negative index don't work in IE8


var substr$3 = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};
const debug = browser$1(\\"foo\\");

function gitCmd(command) {
  const {
    code,
    stdout,
    stderr
  } = exec(\`git \${command}\`, {
    silent: true
  });
  const data = debug(command, {
    code,
    stdout,
    stderr
  });
  return {
    code,
    stdout,
    stderr
  };
}

var gitCmd_1 = gitCmd;
var utils = {
  gitCmd: gitCmd_1
};
var require$$0$1 = /*#__PURE__*/Object.freeze( /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(null), hankey$2, {
  'default': hankey$1
}));
const {
  action: action$1
} = require$$0$1;
const {
  gitCmd: gitCmd$1
} = utils;

function getRepoName() {
  const {
    repository: {
      url
    }
  } = commonjsRequire$1(path$2.join(process$1.cwd(), \\"package.json\\"));
  const repo = path$2.basename(url);
  return repo.replace(/\\\\.git$/, \\"\\");
}

function addRemote(remote) {
  const repo = getRepoName();
  gitCmd$1(\`remote add \${remote} https://github.com/\${remote}/\${repo}.git\`);
}

function parseCheckout(cmd) {
  const [, remote, branch] = cmd.match(/^@(.+):(.+)$/);
  return {
    remote,
    branch
  };
}

function checkout(cmd) {
  const matches = cmd.match(/^@(.+)[:|\\\\/](.+)$/);

  if (!matches) {
    return;
  }

  const [, remote, branch] = matches;
  addRemote(remote);
  gitCmd$1(\`fetch \${remote}\`);
  const {
    stderr,
    code
  } = gitCmd$1(\`checkout --track \${remote}/\${branch}\`);

  if (code != 0) {
    console.log(stderr);
  }

  action$1(\`:dancer: Current branch \${branch}\`);
}

var checkout_1 = {
  checkout,
  parseCheckout
};
const {
  gitCmd: gitCmd$2
} = utils;

function getRemote() {
  const {
    stdout
  } = gitCmd$2(\`branch -vv\`); // check for a remote/branch pair

  const matches = stdout.match(/\\\\*.*\\\\[(\\\\S+)\\\\].*/);

  if (!matches) {
    const [, _branch] = gitCmd$2(\`branch\`).stdout.match(/\\\\* (\\\\S+).*/);
    return {
      remote: null,
      branch: _branch
    };
  }

  const [remote, branch] = remoteBranch.split(\\"/\\");
  return {
    remote,
    branch
  };
}

function push() {
  const {
    remote,
    branch
  } = getRemote();

  if (remote) {
    gitCmd$2(\`push --no-verify -f \${remote} \${branch} \`);
    return;
  }

  gitCmd$2(\`push --no-verify -f me \${branch} \`);
}

var push_1 = {
  getRemote,
  push
};
const {
  gitCmd: gitCmd$3
} = utils;

async function log$2() {
  const {
    stdout
  } = gitCmd$3(\\"log  --color=always\\");
  src(stdout);
}

var log_1$1 = log$2;
const {
  gitCmd: gitCmd$4
} = utils;

function diff() {
  const {
    stdout
  } = gitCmd$4(\\"diff  --color=always\\");
  console.log(stdout);
}

var diff_1 = diff;
const {
  checkout: checkout$1
} = checkout_1;
const {
  push: push$1
} = push_1;
var tasks = {
  checkout: checkout$1,
  push: push$1,
  log: log_1$1,
  diff: diff_1
};

var foo = function foo(opts) {
  tasks[opts.args[0]](opts.args[1]);
};

console.log('hello', foo);
",
  "dynamicImports": Array [],
  "exports": Array [],
  "facadeModuleId": "/index.tsx",
  "fileName": "index.js",
  "implicitlyLoadedBefore": Array [],
  "imports": Array [],
  "isDynamicEntry": false,
  "isEntry": true,
  "isImplicitEntry": false,
  "map": null,
  "modules": Object {
    "/index.tsx": Object {
      "originalLength": 48,
      "removedExports": Array [],
      "renderedExports": Array [],
      "renderedLength": 26,
    },
    "https://cdn.pika.dev/-/ansi-styles@v3.2.1-V5GOWAzTBIdjH6cR3Yl9/dist=es2017/ansi-styles.js": Object {
      "originalLength": 4379,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 4253,
    },
    "https://cdn.pika.dev/-/balanced-match@v1.0.0-jEDaZvxhQQ5IbXks9UCV/dist=es2017/balanced-match.js": Object {
      "originalLength": 1190,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 1159,
    },
    "https://cdn.pika.dev/-/brace-expansion@v1.1.11-2VzdVQEfexFJgvb7my3e/dist=es2017/brace-expansion.js": Object {
      "originalLength": 4729,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 4499,
    },
    "https://cdn.pika.dev/-/chalk@v2.4.2-vadMBWNAtdZRRnpmp4V8/dist=es2017/chalk.js": Object {
      "originalLength": 10734,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
        "supportsColor",
      ],
      "renderedLength": 10316,
    },
    "https://cdn.pika.dev/-/color-convert@v1.9.3-ZN4XwYb6ybaV2PalJzex/dist=es2017/color-convert.js": Object {
      "originalLength": 24186,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 24063,
    },
    "https://cdn.pika.dev/-/color-name@v1.1.3-UTEeFwbszxLdwMAO4Ypc/dist=es2017/color-name.js": Object {
      "originalLength": 4623,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 4597,
    },
    "https://cdn.pika.dev/-/concat-map@v0.0.1-mPK4tnWcNQdev0YXqd5t/dist=es2017/concat-map.js": Object {
      "originalLength": 354,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 331,
    },
    "https://cdn.pika.dev/-/debug@v4.1.1-WGHl5F4BV3bPLtFoB0h0/dist=es2017/debug.js": Object {
      "originalLength": 13053,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
        "colors",
        "formatArgs",
        "load",
        "log",
        "save",
        "storage",
        "useColors",
      ],
      "renderedLength": 12823,
    },
    "https://cdn.pika.dev/-/escape-string-regexp@v1.0.5-h8Z16ibkgz1DcdtBz1li/dist=es2017/escape-string-regexp.js": Object {
      "originalLength": 277,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 241,
    },
    "https://cdn.pika.dev/-/foo@v0.0.7-5yAKC8NDzuCuaUBumGaL/dist=es2017/foo.js": Object {
      "originalLength": 9669,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 9255,
    },
    "https://cdn.pika.dev/-/fs.realpath@v1.0.0-0aRkHJG4sWCGxHQiIBiQ/dist=es2017/fs.realpath.js": Object {
      "originalLength": 14065,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 13930,
    },
    "https://cdn.pika.dev/-/glob@v7.1.6-SgyLjCK8T1NNoH2SIqOV/dist=es2017/glob.js": Object {
      "originalLength": 133231,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 132733,
    },
    "https://cdn.pika.dev/-/hankey@v0.0.3-QjVSuhjSuWis7ZJjCaxb/dist=es2017/hankey.js": Object {
      "originalLength": 1021,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 709,
    },
    "https://cdn.pika.dev/-/inflight@v1.0.6-410Xe43bxrAQGovDliSu/dist=es2017/inflight.js": Object {
      "originalLength": 1542,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 1323,
    },
    "https://cdn.pika.dev/-/inherits@v2.0.4-ffRfw6EZygatgjevbei3/dist=es2017/inherits.js": Object {
      "originalLength": 1057,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 1028,
    },
    "https://cdn.pika.dev/-/lodash.toarray@v4.4.0-wfgijvC2b9BtDxMHoer0/dist=es2017/lodash.toarray.js": Object {
      "originalLength": 22924,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 22925,
    },
    "https://cdn.pika.dev/-/minimatch@v3.0.4-ecoiUBf88yFApjWli9V5/dist=es2017/minimatch.js": Object {
      "originalLength": 31803,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 31700,
    },
    "https://cdn.pika.dev/-/ms@v2.1.2-tsbffql3b6LEspFwvo4H/dist=es2017/ms.js": Object {
      "originalLength": 3037,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 3035,
    },
    "https://cdn.pika.dev/-/node-emoji@v1.10.0-lfQe4sk9xhMPiAI4aFFI/dist=es2017/node-emoji.js": Object {
      "originalLength": 114397,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 114295,
    },
    "https://cdn.pika.dev/-/node-pager@v0.3.3-zenim1duUXslckEvxjjW/dist=es2017/node-pager.js": Object {
      "originalLength": 370,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 293,
    },
    "https://cdn.pika.dev/-/node:child_process": Object {
      "originalLength": 751,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 759,
    },
    "https://cdn.pika.dev/-/node:fs": Object {
      "originalLength": 729,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 726,
    },
    "https://cdn.pika.dev/-/node:os": Object {
      "originalLength": 729,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 726,
    },
    "https://cdn.pika.dev/-/node:process": Object {
      "originalLength": 739,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 738,
    },
    "https://cdn.pika.dev/-/once@v1.4.0-IHbNwftGdlk71aL3nOJX/dist=es2017/once.js": Object {
      "originalLength": 1052,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
        "strict",
      ],
      "renderedLength": 932,
    },
    "https://cdn.pika.dev/-/path-is-absolute@v1.0.1-m9Ec4SCEMg1lHo1Ermb9/dist=es2017/path-is-absolute.js": Object {
      "originalLength": 690,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
        "posix",
        "win32",
      ],
      "renderedLength": 612,
    },
    "https://cdn.pika.dev/-/shelljs@v0.7.8-WbVQ1LY5FFfTVU7NYuEQ/dist=es2017/shelljs.js": Object {
      "originalLength": 71875,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
        "ShellString",
        "config",
        "env",
        "error",
        "exit",
      ],
      "renderedLength": 72340,
    },
    "https://cdn.pika.dev/-/supports-color@v5.5.0-T8JsYqXGL5gJbc0pQdmh/dist=es2017/supports-color.js": Object {
      "originalLength": 192,
      "removedExports": Array [
        "stderr",
        "stdout",
      ],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 51,
    },
    "https://cdn.pika.dev/-/wrappy@v1.0.2-uApSBRU2gqMqB6LTouq2/dist=es2017/wrappy.js": Object {
      "originalLength": 940,
      "removedExports": Array [],
      "renderedExports": Array [
        "default",
      ],
      "renderedLength": 914,
    },
  },
  "name": "index",
  "type": "chunk",
}
`;
